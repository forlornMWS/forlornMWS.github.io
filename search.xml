<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Chapter10 对象和类</title>
    <url>/2021/03/26/Chapter10_%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="Chapter10-类和对象"><a href="#Chapter10-类和对象" class="headerlink" title="Chapter10 类和对象"></a>Chapter10 类和对象</h2><h3 id="10-1-抽象和类"><a href="#10-1-抽象和类" class="headerlink" title="10.1 抽象和类"></a>10.1 抽象和类</h3><p>一般来说，类规范由两个部分组成：<br>（1）类声明：以数据成员的方式描述数据部分，以成员函数（被称为方法）的方式描述公有接口。<br>（2）类方法定义：描述如何实现类成员函数。<br>（<em>简单地说，类声明提供了类的蓝图，而方法定义则提供了细节</em>）</p>
<p>接口是一个共享框架，供两个系统交互时使用。</p>
<p>使用类对象的程序都可以直接访问公有部分，但只能通过公有成员函数（或友元函数）来访问对象的私有成员。公有成员函数是程序和对象的私有成员之间的桥梁，提供了对象和程序之间的接口，防止程序直接访问数据（数据隐藏）。</p>
<p>类设计应尽可能将公有接口和实现细节分开，公有接口表示设计的抽象组件，将实现细节放在一起并将它们与抽象分开被称为封装。</p>
<p>C++对结构进行了扩展，使它之具有与类相同的特性。它们之间唯一的区别是，结构的默认访问类型为public，而类为private。</p>
<p>成员函数定义与常规函数定义非常相似，它们有函数头和函数体，也可以有返回类型和参数，但是它们还有两个特殊的特征：（1）定义成员函数时，使用作用域解析运算符（::）来标识函数所属的类（<em>类方法的完整名称中包括类名</em>）（2）类方法可以访问类的private组件。</p>
<p>定义位于类声明中的函数都将自动称为内联函数，此外也可以在类声明之外定义成员函数，并使其称为内联函数，为此，只需在类实现部分中定义函数时使用inline限定符即可。</p>
<p>内联函数的特殊规则要求在每个使用它们的文件中都对其进行定义。（根据改写规则，在类声明中定义方法，等同于用原型替换方法定义，然后在类声明的后面将定义改写为内联函数）。</p>
<p>创建的每个新对象都有自己的存储空间，用于存储其内部变量和类成员；但同一个类的所有对象共享同一组类方法，即每种方法只有一个副本。在OOP中，调用成员函数被称为发送消息，因此将同样的消息发送给两个不同的对象将调用同一个方法，但该方法被用于两个不同的对象。<img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20201023160922.png" alt="image-20201023160915489"></p>
<p>要创建对象，可以声明类变量，也可以使用new为类对象分配存储空间。可以将对象作为函数的参数和返回值，也可以将一个对象赋给另一个。</p>
<p>指定类设计的第一步是提供类声明。类声明类似结构声明，可以包括数据成员和函数成员。声明有四有部分，在其中生命的成员只能通过成员函数进行访问；声明还具有公有部分，在其中生命的成员可被使用类对象的程序直接访问。典型的类声明格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">className</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	data member declarations</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	member function prototypes</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="10-2-类的构造函数和析构函数"><a href="#10-2-类的构造函数和析构函数" class="headerlink" title="10.2 类的构造函数和析构函数"></a>10.2 类的构造函数和析构函数</h3><h4 id="10-2-1-构造函数"><a href="#10-2-1-构造函数" class="headerlink" title="10.2.1 构造函数"></a>10.2.1 构造函数</h4><p>程序声明对象时，将自动调用构造函数。（*构造函数的参数表示的不是类成员，而是赋给类成员的值，因此，参数名不能与类成员相同）</p>
<p>C++提供了两种使用构造函数来初始化对象的方式，一种是显式地调用构造函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Stock food = <span class="built_in">Stock</span>(<span class="string">&quot;test&quot;</span>, <span class="number">230</span>, <span class="number">1.25</span>);</span><br></pre></td></tr></table></figure>

<p>另一种是隐式地调用构造函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Stock <span class="title">food</span><span class="params">(<span class="string">&quot;test&quot;</span>, <span class="number">230</span>, <span class="number">1.25</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>也可以使用new运算符创建对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Stock * pt = <span class="keyword">new</span> <span class="built_in">Stock</span>(<span class="string">&quot;test&quot;</span>, <span class="number">230</span>, <span class="number">1.25</span>);</span><br></pre></td></tr></table></figure>

<p>C++无法使用对象来调用构造函数，<strong>因为在构造函数构造出对象之前，对象是不存在的</strong>。</p>
<p>默认构造函数是在未提供显式初始值时，用来创建对象的构造函数。默认构造函数没有参数，因为声明中不包含值。<em>当且仅当没有定义任何构造函数时，编译器才会提供默认构造函数</em>。</p>
<p>如果要创建对象而不显式地初始化，则必须定义一个不接受任何参数的默认构造函数。定义默认构造函数的方式有两种。一种是<strong>给已有构造函数的所有参数提供默认值</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Stock</span>(<span class="keyword">const</span> String &amp; co = <span class="string">&quot;Error&quot;</span>, <span class="keyword">int</span> n = <span class="number">0</span>, <span class="keyword">double</span> pr = <span class="number">0.0</span>);</span><br></pre></td></tr></table></figure>

<p>另一种方式是通过函数重载来定义另一个构造函数——<strong>没有参数的构造函数</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Stock</span>();</span><br></pre></td></tr></table></figure>

<h4 id="10-2-2-析构函数"><a href="#10-2-2-析构函数" class="headerlink" title="10.2.2 析构函数"></a>10.2.2 析构函数</h4><p>和构造函数一样，析构函数的名称也很特殊：在类名前加上~，另外析构函数和构造函数一样，也没有返回值和声明类型。与构造函数不同的是，析构函数没有参数。</p>
<p>如果创建的是静态存储类对象，则其析构函数将在程序结束时自动被调用。如果创建的是自动存储类对象，则将其析构函数将在程序执行完代码块时自动被调用给。如果对象是通过new创建的，则它将驻留在占内存或自由存储区中，当使用delete来释放内存时，其析构函数将自动被调用。</p>
<p>由于在类对象过期时析构函数将被自动调用，因此必须有一个析构函数。如果程序员没有提供析构函数，编译器将隐式地声明一个默认析构函数，并在发现导致对象被删除的代码后，提供析构函数的定义。</p>
<p>在默认情况下，将一个对象赋给同类型的另一个对象时，C++将源对象的每个数据成员的内容复制到目标对象中相应的数据成员中。</p>
<p>如果既可以通过初始化，也可以通过复制来设置对象的值，则应采用初始化方式。通常这种方式的效率更高。（<em>在赋值语句中使用构造函数总会导致在赋值前创建一个临时对象，而初始化语句则不一定</em>）</p>
<h4 id="10-2-3-构造函数和析构函数小结"><a href="#10-2-3-构造函数和析构函数小结" class="headerlink" title="10.2.3 构造函数和析构函数小结"></a>10.2.3 构造函数和析构函数小结</h4><p>构造函数是一种特殊的类成员函数，在创建类对象时被调用。构造函数的名称和类名相同，但通过函数重载，可以创建多个同名的构造函数，条件是每个函数的特征标（函数参数）都不同。另外，构造函数没有声明类型。</p>
<p>接受一个参数的构造函数允许使用赋值语法将一个对象初始化为一个值。但这种方法可能会导致问题。（可以使用关键字explicit关闭隐式转换）</p>
<p>默认构造函数没有参数，因此如果创建对象时候没有进行显示地初始化，则将调用默认构造函数。如果程序中没有提供任何构造函数，则编译器会为程序定义一个默认构造函数；否则，必须自己提供默认构造函数。默认构造函数可以没有任何参数；如果有，则必须给所有参数都提供默认值。</p>
<p>如果构造函数使用了new，则必须提供使用delete的析构函数。</p>
<h3 id="10-3-this指针"><a href="#10-3-this指针" class="headerlink" title="10.3 this指针"></a>10.3 this指针</h3><p>每个成员函数（包括构造函数和析构函数）都有一个this指针。this指针指向调用对象，如果方法需要引用整个调用对象，则可以使用表达式*this。</p>
<p>初始化数组的方案式，首先使用默认构造函数创建数组元素，然后花括号中的构造函数将创建临时对象，然后将临时对象的内容复制到相应的元素中。因此，<strong>要创建类对象数组，则这个类必须有默认构造函数</strong>。</p>
<h3 id="10-4-类作用域"><a href="#10-4-类作用域" class="headerlink" title="10.4 类作用域"></a>10.4 类作用域</h3><p>在类中定义的名称的作用域都为整个类，作用域为整个类的名称只在该类种是已知的，在类外是不可知的。类作用域意味着不能从外部直接访问类的成员，公有成员函数也是如此，要调用公有成员函数，必须通过对象，同样，在定义成员函数时，必须使用作用域解析运算符。</p>
<p>在类声明种声明的枚举的作用域为整个类，因此可以用枚举为整型常量提供作用域为整个类的符号名称。例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bakery</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="class"><span class="keyword">enum</span> &#123;</span>Months = <span class="number">12</span>&#125;;</span><br><span class="line">    	<span class="keyword">double</span> costs[Months];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用这种方式声明枚举并不会创建类数据成员。也就是说，所有对象中都不包含枚举。</p>
<p>C++提供了另一种在类中定义常量的方法——使用关键字static：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bakery</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> Months = <span class="number">12</span>;<span class="comment">/*创建名为Months的常量，该常量将与其他静态变量存储在一起</span></span><br><span class="line"><span class="comment">    	，而不是存储在对象中*/</span></span><br><span class="line">    	<span class="keyword">double</span> costs[Months];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用域内枚举不能隐式地转换为整型。</p>
<h3 id="10-5-总结"><a href="#10-5-总结" class="headerlink" title="10.5 总结"></a>10.5 总结</h3><p>面向对象编程强调的是程序如何表示数据。使用OOP方法解决编程问题的第一步是根据它与程序之间的接口来描述数据，从而指定如何使用数据。然后，设计一个类来实现该接口，一般来说，私有数据成员存储信息，公有成员函数（又称为方法）提供访问数据的唯一途径。</p>
<p>类是用户定义的类型，对象是类的实例。</p>
<p>如果希望成员函数对多个对象进行操作，可以将额外的对象作为参数传递给它。如果方法需要显式地引用调用它的对象，则可以使用this指针，由于this指针被设置为调用对象的地址，因此*this是该对象的别名。</p>
]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>C++ premier plus学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Chapter11 使用类</title>
    <url>/2021/03/26/Chapter11_%E4%BD%BF%E7%94%A8%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="Chapter11-使用类"><a href="#Chapter11-使用类" class="headerlink" title="Chapter11 使用类"></a>Chapter11 使用类</h2><h3 id="11-1-运算符重载"><a href="#11-1-运算符重载" class="headerlink" title="11.1 运算符重载"></a>11.1 运算符重载</h3><p>C++根据操作数的数目和类型决定采取哪种操作。要重载运算符，需使用被称为运算符函数的特殊函数形式，运算符函数的格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">operator</span></span>(argument-list)</span><br></pre></td></tr></table></figure>

<p><em>不要返回指向局部变量或临时变量的引用。函数执行完毕后，局部变量和临时对象将消失，引用将指向不存在的数据</em>。</p>
<p>在运算符表示法中，运算符左侧的对象是调用对象，运算符右边的对象是作为参数被传递的对象。如<code>total=coding+fixing</code>与<code>total=coding.operator+(fixing)</code>等价。</p>
<ul>
<li><p>重载的限制</p>
<p>（1）重载后的运算符必须至少有一个操作数是用户定义的类型</p>
<p>（2）使用运算符时不能违反运算符原来的句法规则。</p>
<p>（3）不能创建新运算符。</p>
<p>（4）赋值运算符（=）、函数调用运算符（()）、下标运算符（[]）、通过指针访问类成员的运算符（-&gt;）都只能通过成员函数进行重载。</p>
</li>
</ul>
<h3 id="11-2-友元"><a href="#11-2-友元" class="headerlink" title="11.2 友元"></a>11.2 友元</h3><p>通过让函数称为类的友元，可以赋予该函数与类的成员函数相同的访问权限。</p>
<p>创建友元函数的第一步是将其原型放在类声明中，并在原型声明前加上关键字friend，如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> Time <span class="keyword">operator</span>*(<span class="keyword">double</span> m, <span class="keyword">const</span> Time &amp; t);</span><br></pre></td></tr></table></figure>

<p>该原型意味着如下两点：<br>(1) 虽然operator*()函数实在类声明中声明的，但它不是成员函数，因此不能使用成员运算符来调用。<br>(2) 虽然operator*()函数不是成员函数，但它与成员函数的访问权限相同。</p>
<p>第二步是编写函数定义，因为他不是成员函数，所以不需要使用Time::限定符，另外定义中不需要使用关键字friend，其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Time <span class="keyword">operator</span>*(<span class="keyword">double</span> m, <span class="keyword">const</span> Time &amp; t)</span><br><span class="line">&#123;</span><br><span class="line">    Time result;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说，要冲在&lt;&lt;运算符来显示c_name的对象，可使用一个友元函数，其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="keyword">const</span> c_name &amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; ...;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非成员版本的重载运算符函数所需的形参数目与运算符使用的操作数目相同；而成员版本所需的参数数目少了一个，因为其中一个操作数是被隐式地传递的调用对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Time <span class="keyword">operator</span>+(<span class="keyword">const</span> Time &amp; t) <span class="keyword">const</span>;<span class="comment">//member version</span></span><br><span class="line"><span class="keyword">friend</span> Time <span class="keyword">operator</span>+(<span class="keyword">const</span> Time &amp; t1, <span class="keyword">const</span> Time &amp; t2); <span class="comment">// nonmember version</span></span><br></pre></td></tr></table></figure>

<p>因为运算符重载是通过函数来实现的，所以只要运算符函数的特征标不同，使用的运算符数量与相应的内置C++运算符相同，就可以多次重载同一个运算符。</p>
<p>只有一个参数的构造函数可以用于将某种类型转换为类类型（explicit可以防止隐式转换）。如果要进行相反的转换，需要使用转换函数，转换函数是用户定义的强制类型转换，可以像使用强制类型转换那样使用它们。</p>
<p>将类类型转换为typeName类型的转换函数为:<code>operator typeName()</code>.（转换函数必须是类方法，转换函数不能指定返回类型但必须返回转换后的值，转换函数不能有参数）。</p>
]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>C++ premier plus学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Chapter12 类和动态内存分配</title>
    <url>/2021/03/26/Chapter12_%E7%B1%BB%E5%92%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
    <content><![CDATA[<h2 id="Chapter12-类和动态内存分配"><a href="#Chapter12-类和动态内存分配" class="headerlink" title="Chapter12 类和动态内存分配"></a>Chapter12 类和动态内存分配</h2><p>静态类成员有一个特点：无论创建了多少对象，程序都只创建一个静态类变量副本。也就是说，类的所有对象共享同一个静态成员。<br><img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20201025121320.png" alt="image-20201025121313087"></p>
<p>不能在类声明中初始化静态成员变量，这是因为声明描述了如何分配内存，但不分配内存。对于静态类成员，须在类声明之外使用单独的语句来进行初始化，这是因为静态类成员是单独存储的，而不是对象的组成部分。（<em>初始化应在方法文件中进行，而非类声明文件中，这是因为类声明位于头文件中，程序可能将头文件包括在其他几个文件中。如果在头文件中进行初始化，将出现多个初始化语句副本，从而引发错误</em>）</p>
<p><u>静态数据成员在类声明中声明，在包含类方法的文件中初始化。类初始化时使用作用域运算符来指出静态成员所属的类。但如果静态成员是整型或枚举型const，则可以在类声明中进行初始化</u></p>
<p>删除对象可以释放对象本身占用的内存，但并不能自动释放属于对象成员的指针指向的内存。</p>
<p>当使用一个对象来初始化另一个对象时，编译器将自动生成复制构造函数（创建对象的一个副本）。</p>
<h3 id="12-1-特殊成员函数"><a href="#12-1-特殊成员函数" class="headerlink" title="12.1 特殊成员函数"></a>12.1 特殊成员函数</h3><p>C++自动提供了下面这些成员函数：<br>（1）默认构造函数，如果没有定义构造函数；<br>（2）默认析构函数，如果没有定义；<br>（3）复制构造函数，如果没有定义；<br>（4）赋值运算符，如果没有定义：<br>（5）地址运算符（返回调用对象的地址，this指针），如果没有定义。</p>
<h4 id="12-1-1-默认构造函数"><a href="#12-1-1-默认构造函数" class="headerlink" title="12.1.1 默认构造函数"></a>12.1.1 默认构造函数</h4><p>如果没有提供任何构造函数，C++将创建默认构造函数（不接受任何参数，也不执行任何操作），如果希望在创建对象时不显式地对它进行初始化，则必须显式地定义默认构造函数。带参数的构造函数也可以是默认构造函数，只要所有参数都有默认值。</p>
<h4 id="12-1-2-复制构造函数"><a href="#12-1-2-复制构造函数" class="headerlink" title="12.1.2 复制构造函数"></a>12.1.2 复制构造函数</h4><p>复制构造函数用于将一个对象复制到新创建的对象中。也就是说，它用于初始化过程中，而不是常规的赋值过程中。类的复制构造函数原型通常如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Class_name</span> (<span class="keyword">const</span> Class_name &amp; );</span><br></pre></td></tr></table></figure>

<p>它接受一个指向类对象的常量引用作为参数。</p>
<ul>
<li>何时调用复制构造函数<br>(1)新建一个对象并将其初始化为同类现有对象时，复制构造函数都将被调用。<br>(2)每当程序生成了对象副本时，编译器都将使用复制构造函数。具体地说，当函数按值传递对象或函数返回对象时，都将使用复制构造函数。（<em>由于按值传递对象将调用复制构造函数，因此应该按引用传递对象，这样可以节省调用构造函数的时间以及存储新对象的空间</em>）</li>
<li>默认复制构造函数的功能<br>默认的复制构造函数逐个复制<u>非静态成员</u>（成员复制也成为浅复制），复制的时成员的值。<img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20201025125243.png" alt="image-20201025125243335" style="zoom:80%;" /></li>
</ul>
<p>如果类中包含了使用new初始化的指针成员，应当定义一个复制构造函数，以复制指向的数据，而不是指针，这被称为<strong>深度复制</strong>。</p>
<h4 id="12-1-3-赋值运算符"><a href="#12-1-3-赋值运算符" class="headerlink" title="12.1.3 赋值运算符"></a>12.1.3 赋值运算符</h4><p>C++允许类对象赋值，这是通过自动为类重载赋值运算符实现的。运算符原型如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Class_name &amp; Class_name::<span class="keyword">operator</span>=(<span class="keyword">const</span> Class_name &amp; );</span><br></pre></td></tr></table></figure>

<p>它返回一个指向类对象的引用。</p>
<p>将已有的对象赋给另一个对象时，将使用重载的赋值运算符。（初始化总是会调用复制构造函数，而使用=运算符时也可能调用赋值运算符）</p>
<p>与赋值构造函数相似，赋值运算符的隐式实现也对成员进行逐个复制。如果成员本身就是类对象，则程序将使用为这个类定义的赋值运算符来复制该成员，但静态数据成员不受影响（存储空间不同）。</p>
<p>对于由于默认赋值运算符不合适而导致的问题，解决办法是提供赋值运算符定义：<br>（1）由于目标对象可能引用了以前分配的数据，所以函数应使用delete[]来释放这些数据；<br>（2）函数应当避免将对象赋给自身；否则，给对象重新赋值之前，释放内存操作可能删除对象的内容；<br>（3）函数返回一个指向调用对象的引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Class_name &amp; Class_name::<span class="keyword">operator</span>=(<span class="keyword">const</span> Class_name &amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;obj)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span> [] obj;</span><br><span class="line">    ...<span class="comment">//deep copy</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Strcmp()函数，如果依照字母排序，第一个参数位于第二个参数之前，则该函数返回一个负值；如果两个字符串相同，则返回0；如果第一个参数位于第二个参数之后，则返回一个正值。</p>
<p>对于中括号运算符([])，一个操作数位于第一个中括号的前面，另一个操作数位于两个中括号之间。</p>
<p><strong>不能通过对象调用静态成员函数</strong>，如果静态成员函数实在公有部分声明的，则可以使用类名和作用域解析运算符来调用它。</p>
<p>由于静态成员函数不与特定的对象相关联，因此只能使用静态数据成员。</p>
<h3 id="12-2-在构造函数中使用new时应注意的事项"><a href="#12-2-在构造函数中使用new时应注意的事项" class="headerlink" title="12.2 在构造函数中使用new时应注意的事项"></a>12.2 在构造函数中使用new时应注意的事项</h3><ul>
<li>如果在构造函数中使用new来初始化指针成员，则应该在析构函数中使用delete。</li>
<li>new和delete必须相互兼容。new对应于delete，new[]对应于delete[]。</li>
<li>如果有多个构造函数，则必须以相同的方式使用new，因为只有一个析构函数，所有的构造函数都必须与它兼容。</li>
<li>应定义一个复制构造函数，通过深度复制将一个对象初始化为另一个对象。（复制构造函数应分配足够的空间来存储复制的数据，并复制数据，而不仅仅是数据的地址。还应该更新所有受影响的静态类成员）</li>
<li>应当定义一个赋值运算符，通过深度复制将一个对象复制给另一个对象。（检查自我赋值的情况，释放成员指针以前指向的内存，复制数据而不仅仅是数据的地址，并返回一个指向调用对象的引用）。</li>
</ul>
<h3 id="12-3-有关返回对象的说明"><a href="#12-3-有关返回对象的说明" class="headerlink" title="12.3 有关返回对象的说明"></a>12.3 有关返回对象的说明</h3><ul>
<li><p>返回指向const对象的引用<br>使用const引用的常见原因是旨在提高效率。返回对象将调用复制构造函数，而返回引用则不会。</p>
</li>
<li><p>返回指向非const对象的引用<br>两种常见的返回非const对象情形是，重载赋值运算符以及重载插入（&lt;&lt;）运算符。</p>
</li>
<li><p>返回对象<br>如果被返回的对象是在被调用函数中的局部变量，则不应按引用方式返回它，因为在被调用函数执行完毕时，局部对象将调用其析构函数，因此，当控制权回到调用函数时，引用指向的对象将不再存在。</p>
<p>如果方法或函数要返回局部对象，则应该返回对象，而不是指向对象的引用。</p>
</li>
</ul>
<h3 id="12-4-使用指向对象的指针"><a href="#12-4-使用指向对象的指针" class="headerlink" title="12.4 使用指向对象的指针"></a>12.4 使用指向对象的指针</h3><p>通常，如果Class_name是类，value的类型为Type_name,则下面的语句：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Class_name * pclass = <span class="keyword">new</span> <span class="built_in">Class_name</span>(value);</span><br></pre></td></tr></table></figure>

<p>将调用如下构造函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Class_name</span> (<span class="keyword">const</span> Type_name &amp;);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20201025132924.png" alt="image-20201025132924314"></p>
<p>在下述情况下析构函数将被调用：<br>(1) 如果对象是动态变量，则当执行完定义该对象的程序块时，将调用该对象的析构函数。<br>(2) 如果对象是静态变量（外部、静态、静态外部或来自名称空间），则在程序结束时将调用对象的析构函数。<br>(3) 如果对象是用new创建的，仅当显式使用delete删除对象时，其析构函数才会被调用。</p>
<h4 id="12-4-1-指针和对象小结"><a href="#12-4-1-指针和对象小结" class="headerlink" title="12.4.1 指针和对象小结"></a>12.4.1 指针和对象小结</h4><ul>
<li>使用常规表示法声明指向对象的指针：<code>String * glamour;</code></li>
<li>可以将指针初始化为指向已有的对象：<code>String * first = &amp; sayings[0]</code></li>
<li>可以使用new来初始化指针，这将创建一个新的对象：<code>String * favorite=new String(sayings[choices]);</code></li>
<li>对类使用new将调用相应的类构造函数来初始化新建的对象。<img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20201025134033.png" alt="image-20201025134033444"><br><img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20201025134054.png" alt="image-20201025134054599"></li>
<li>可以使用-&gt;运算符通过指针访问类方法</li>
<li>可以对对象指针应用接触引用运算符(*)来获得对象。</li>
</ul>
<p>对于使用定位new运算符创建的对象，应以与创建顺序相反的顺序进行删除。原因在于，晚创建的对象可能依赖于早创建的对象。另外，仅当所有对象都被销毁后，才能释放用于存储这些对象的缓冲区。</p>
<h3 id="12-5-复习各种技术"><a href="#12-5-复习各种技术" class="headerlink" title="12.5 复习各种技术"></a>12.5 复习各种技术</h3><h4 id="12-5-1-重载-lt-lt-运算符"><a href="#12-5-1-重载-lt-lt-运算符" class="headerlink" title="12.5.1 重载&lt;&lt;运算符"></a>12.5.1 重载&lt;&lt;运算符</h4><p>要重新定义&lt;&lt;运算符，以便将它和cout一起用来显式对象的内容，需定义如下友元运算符函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="keyword">const</span> c_name &amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; ...;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="12-5-2-转换函数"><a href="#12-5-2-转换函数" class="headerlink" title="12.5.2 转换函数"></a>12.5.2 转换函数</h4><p>要将单个值转换为类类型，需要创建原如下的类构造函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">c_name</span> (type_name value);</span><br></pre></td></tr></table></figure>

<p>其中c_name为类名，type_name是要转换的类型的名称。</p>
<p>要将类转换为其他类型，需要创建原型如下所示的类成员函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">typename</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>虽然该函数没有声明返回类型，但应返回所需类型的值。</p>
<p>可以在声明构造函数时使用关键字explicit，以防它被用于隐式转换。</p>
<h4 id="12-5-3-构造函数使用new的类"><a href="#12-5-3-构造函数使用new的类" class="headerlink" title="12.5.3 构造函数使用new的类"></a>12.5.3 构造函数使用new的类</h4><p>如果类使用new运算符来分配类成员指向的内存，在设计时应采取一些预防措施：</p>
<ul>
<li><p>对于指向的内存是由new分配的所有类成员，都应在类的析构函数中对其使用delete，该运算符将释放分配的内存。</p>
</li>
<li><p>如果析构函数通过对指针类成员使用delete来释放内存，则每个构造函数都应当使用new来初始化指针，或将它设置为空指针。</p>
</li>
<li><p>构造函数中要么使用new[]，要么使用new，不能混用。</p>
</li>
<li><p>应定义一个分配内存（而不是建该指针指向已有内存）的复制构造函数。这样程序将能够将类对象初始化为另一个类对象，这种构造函数的原型通常如下：<code>className(const className &amp;)</code>。</p>
</li>
<li><p>应定义一个重载赋值运算符的类成员函数，其函数定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c_name &amp; cname::<span class="keyword">operator</span>=(<span class="keyword">const</span> c_name &amp; cn)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp; cn)</span><br><span class="line">        <span class="keyword">return</span> * <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span> [] c_pointer;</span><br><span class="line">    c_pointer = <span class="keyword">new</span> type_name[size];</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> * <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>成员初始化列表由都好分隔的初始化列表组成（前面带冒号），它位于参数列表的右括号之后、函数体左括号之前。（<strong>对于const类成员和被声明为引用的类成员必须使用这种语法</strong>,这是因为引用与const数据类似，只能在被创建时进行初始化）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果Classy是一个类，而mem1、mem2、mem3都是这个类的数据成员，则构造函数可使用列表初始化语法来初始化成员</span></span><br><span class="line">Classy::<span class="built_in">Classy</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> m):<span class="built_in">mem1</span>(n),<span class="built_in">mem2</span>(<span class="number">0</span>),<span class="built_in">mem3</span>(n * m + <span class="number">2</span>)&#123;&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 这种格式只能用于构造函数</span></span><br><span class="line"><span class="comment">* 必须使用这种格式来初始化非静态const数据成员</span></span><br><span class="line"><span class="comment">* 必须用这种格式来初始化引用数据成员</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>C++ premier plus学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Chapter13 类继承</title>
    <url>/2021/03/26/Chapter13_%E7%B1%BB%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h2 id="Chapter13-类继承"><a href="#Chapter13-类继承" class="headerlink" title="Chapter13 类继承"></a>Chapter13 类继承</h2><p>从一个类派生出另一个类时，原始类称为基类，继承类称为派生类。派生类继承了基类的实现（<u>数据成员</u>）和接口（<u>方法</u>）。</p>
<p>使用公有派生，基类的公有成员将成为派生类的公有成员；基类的私有部分也将成为派生类的一部分，但只能通过基类的公有和保护方法访问；基类保护部分成为派生类的一部分，且在派生类中可以直接访问。</p>
<p>派生类构造函数必须给新成员（如果有的话）和继承的成员提供数据，由于派生类不能直接访问基类的私有成员，因此派生类构造函数必须使用基类构造函数。创<strong>建派生对象时，程序首先创建基类对象，从概念上说，这意味着基类对象应当在程序进入派生类之前被创建</strong>，C++使用成员初始化语法来完成这种工作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">derived::<span class="built_in">derived</span>(type1 x, type2 y) : <span class="built_in">base</span>(x, y)&#123;...&#125;<span class="comment">//derived是派生类，base是基类</span></span><br></pre></td></tr></table></figure>

<p>派生类构造函数要点如下：</p>
<ul>
<li>首先创建基类对象；</li>
<li>派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数；</li>
<li>派生类构造函数应初始化派生列新增的数据成员</li>
</ul>
<p>释放对象的顺序与创建对象的顺序相反，即首先执行派生类的析构函数，然后自动调用基类的析构函数。</p>
<p>派生类对象可以使用基类的非私有方法；基类指针可以在不进行显式类型转换的情况下指向派生类对象，基类引用可以在不进行显式类型转换的情况下引用派生类对象，然而基类指针或引用只能用调用基类方法。</p>
<h3 id="13-1-继承：-is-a-关系"><a href="#13-1-继承：-is-a-关系" class="headerlink" title="13.1 继承： is-a 关系"></a>13.1 继承： is-a 关系</h3><p>C++有3种继承方式：公有继承、保护继承和私有继承。公有继承是最常用的方式，它建立一种is-a关系，即派生对象也是一个基类对象，可以对基类对象执行的任何操作也可以对派生类对象执行。</p>
<p>公有继承不能建立is-like-a的关系，也就是说，它不采用明喻。继承可以在积累的基础上添加属性，但不能删除基类的属性。</p>
<h3 id="13-2-多态公有继承"><a href="#13-2-多态公有继承" class="headerlink" title="13.2 多态公有继承"></a>13.2 多态公有继承</h3><p>实现多态公有继承的方法：</p>
<ul>
<li>在派生类中重新定义基类的方法</li>
<li>使用虚方法</li>
</ul>
<p>如果方法是通过引用或指针而不是对象调用的，在没有使用关键字virtual时，程序将根据引用类型或指针类型选择方法，如果使用了virtual，程序将根据引用或指针指向的对象的类型来选择方法。故如果要在派生类中重新定义基类的方法，通常应将基类方法声明为虚的。</p>
<p>方法在基类中被声明为虚的后，它在派生类中将自动成为虚方法。</p>
<p>如果析构函数不是虚的，则将只能调用对应于指针类型的析构函数，如果析构函数是虚的，将调用相应对象类型的析构函数。</p>
<h3 id="13-3-静态联编和动态联编"><a href="#13-3-静态联编和动态联编" class="headerlink" title="13.3 静态联编和动态联编"></a>13.3 静态联编和动态联编</h3><p>将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编（binding)。在编译过程中进行联编被称为静态联编（static binding），又称为早期联编（early binding）。在程序运行时进行联编称为动态联编，或晚期联编。</p>
<p><strong>编译器对非虚方法使用静态联编，对虚方法使用动态联编</strong>。</p>
<p>指向基类的引用或指针可以引用派生类对象，而不必进行显式类型转换。将派生类引用或指针类型转换为基类引用或指针被称为向上强制转换（upcasting），这使公有继承不需要进行显式类型转换。</p>
<blockquote>
<p>如果要在派生类中重新定义基类的方法，则将它设置为虚方法；否则，设置为非虚方法。</p>
</blockquote>
<p>通常，编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。这种数组称为虚函数表（virtual function table，vtbl）。虚函数表中存储了为类对象进行声明的虚函数的地址。</p>
<p><img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20201030173232.png" alt="image-20201030173225440"></p>
<p>使用虚函数时，在内存和执行速度方面有一定的成本，包括：</p>
<ul>
<li>每个对象都将增大，增大量为存储地址的空间；</li>
<li>对于每个类，编译器都创建一个虚函数地址表；</li>
<li>对于每个函数调用，都需要执行一项额外的操作，即到表中查找地址。</li>
</ul>
<p>有关虚函数的注意事项：</p>
<ul>
<li><p>在基类方法的声明中使用关键字virtual可使该方法在基类以及所有的派生类中是虚的。</p>
</li>
<li><p>如果使用指向对象的引用或指针来调用虚方法，程序将使用为对象类型定义的方法，而不使用为引用或指针类型定义的方法，这被称为动态联编或晚期联编。</p>
</li>
<li><p>如果定义的类将被用作基类，则应该将那些要在派生类中重新定义的类方法声明为虚的。</p>
</li>
<li><p>构造函数不能是虚函数。<em>创建对象时，将调用派生类的构造函数，而不是基类的构造函数</em>。</p>
</li>
<li><p>析构函数应当是虚函数，除非类不用做基类。（<em>通常应给基类提供一个虚析构函数，即使它不需要析构函数</em>。</p>
</li>
<li><p>友元不能是虚函数，因为友元不是类成员，只有成员才能是虚函数。（<em>可让友元函数使用虚成员函数</em>）</p>
</li>
<li><p>如果派生类没有重新定义函数，将使用该函数的基类版本，如果派生类位于派生链中，则将使用最新的虚函数版本。</p>
</li>
<li><p>如果在派生类中重新定义函数，将不是使用相同的函数特征标覆盖基类声明，而是隐藏同名的基类方法，不管参数特征标如何。</p>
<p>如果重新定义继承的方法，应确保与原来的原型完全相同，但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针（返回类型协变）。</p>
<p>如果基类声明被重载了，则应在派生类中重新定义所有的基类版本。（如果只重新定义了一个版本，则另外两个版本将被隐藏，派生类对象将无法使用它们）</p>
</li>
</ul>
<h3 id="13-4-访问控制：-protected"><a href="#13-4-访问控制：-protected" class="headerlink" title="13.4 访问控制： protected"></a>13.4 访问控制： protected</h3><p>在类外只能用公有类成员来访问 protected部分中的类成员。 派生类的成员可以直接访问基类的保护成员，但不能直接访问基类的私有成员。因此，对于外部世界来说保护成员的行为与私有成员相似；但对于派生类来说，保护成员的行为与公有成员相似。</p>
<h3 id="13-5-抽象基类"><a href="#13-5-抽象基类" class="headerlink" title="13.5 抽象基类"></a>13.5 抽象基类</h3><p>C++通过使用纯虚函数（pure virtual function）提供未实现的函数。纯虚函数声明的结尾处未=0。当类声明中包含纯虚函数时，不能创建该类的对下个。包含纯虚函数的类只能用作基类，要成为真正的ABC（abstract base class），必须至少包含一个纯虚函数。</p>
<p>ABC描述的是至少使用一个纯虚函数的接口，从ABC派生出来的类将根据派生类的具体特征，使用常规虚函数来实现这种接口。</p>
<p>可以将ABC看作是一种必须实施的接口。ABC要求具体派生类覆盖其纯虚函数——迫使派生类遵循ABC设置的接口规则。</p>
<p>友元不是成员函数，所以不能使用作用域解析运算符来指出要使用哪个函数，解决办法是使用强制类型转换，以便匹配原型时能够选择正确的函数。</p>
<h3 id="13-6-类设计回顾"><a href="#13-6-类设计回顾" class="headerlink" title="13.6 类设计回顾"></a>13.6 类设计回顾</h3><h4 id="13-6-1-编译器生成的成员函数"><a href="#13-6-1-编译器生成的成员函数" class="headerlink" title="13.6.1 编译器生成的成员函数"></a>13.6.1 编译器生成的成员函数</h4><ul>
<li><p><strong>默认构造函数</strong></p>
<p>默认构造函数要么没有参数，要么所有的参数都有默认值。</p>
<p>自动生成的默认构造函数的另一项功能是，调用基类的默认构造函数以及调用本身是对象的成员所属类的默认构造函数。</p>
<p>如果派生类构造函数的成员初始化列表中没有显式地调用基类构造函数，则编译器将使用基类的默认构造函数来构造派生类对象的基类部分。</p>
<p>如果定义了某种构造函数，编译器将不会定义默认构造函数。在这种情况下，如果需要默认构造函数，则必须自己提供。</p>
<p>如果类包含指针成员，则必须初始化这些成员。</p>
</li>
<li><p><strong>复制构造函数</strong></p>
<p>复制构造函数接受其所属类的对象作为参数。</p>
<p>在下述情况下，将使用复制构造函数：</p>
<ol>
<li>将新对象初始化为一个同类对象；</li>
<li>按值将对象传递给函数；</li>
<li>函数按值返回对象；</li>
<li>编译器生成临时对象。</li>
</ol>
<p>如果程序没有使用（显式或隐式）复制构造函数，编译器将提供原型，但不提供函数定义；否则，程序将定义一个执行成员初始化的复制构造函数。</p>
</li>
<li><p><strong>赋值运算符</strong></p>
<p>默认的赋值运算符用于处理同类对象之间的赋值。如果语包创建新的对象，则使用初始化；如果语句修改已有对象的值，则是赋值。</p>
<p>默认赋值为成员赋值。如果成员为类对象，则默认成员赋值将使用相应类的赋值运算符。如果需要显式定义复制构造函数，则基于相同的原因，也需要显式定义赋值运算符。</p>
</li>
</ul>
<h4 id="13-6-2-其它的类方法"><a href="#13-6-2-其它的类方法" class="headerlink" title="13.6.2 其它的类方法"></a>13.6.2 其它的类方法</h4><ul>
<li><p><strong>构造函数</strong></p>
<p>构造函数不同于其他类方法，因为它创建新对象，而其它类方法只是被现有的对象调用。</p>
</li>
<li><p><strong>析构函数</strong></p>
<p>一定要定义显式析构函数来释放类构造函数使用new分配的所有内存，并完成类对象所需的任何特殊的清理工作。对于基类，即使它不需要析构函数，也应提供一个虚析构函数。</p>
</li>
<li><p><strong>转换</strong></p>
<p>使用一个参数就可以调用的构造函数定义了从参数类型到类类型的转换。</p>
<p>将可转换的类型传递给以类未参数的函数时，将调用转换构造函数。</p>
<p>要将类对象转换为其他类型，应定义转换函数。转换函数可以是没有参数的类成员函数，也可以是返回类型被声明为目标类型的类成员函数。即使没有声明返回类型，函数也应返回所需的转换值。</p>
<p>C++11支持将关键字explicit用于转换函数。与构造函数一样，explicit允许使用强制类型转换进行显式转换，但不允许隐式转换。</p>
</li>
<li><p><strong>按值传递与按引用传递</strong><br>通常，编写使用对象作为参数的函数时，应按引用而不是按值来传递对象。（提高效率）</p>
<p>按引用传递对象的另外一个原因是，在继承使用虚函数时，被定义为接受基类引用参数的函数可以接受派生类。</p>
</li>
<li><p><strong>返回对象和返回引用</strong></p>
<p>应返回引用而不是返回对象的的原因在于，返回对象涉及生成返回对象的临时副本，这是调用函数的程序可以使用的副本。因此，返回对象的时间成本包括调用复制构造函数来生成副本所需的时间和调用析构函数删除副本所需的时间。返回引用可节省时间内存</p>
<p>函数不能返回在函数中创建的临时对象的引用，因为当函数结束时，临时象将消失，因此这种引用将是非法的。在这种情况下，应返回对象，以生成一个调用程序可以使用的副本。如果函数返回的是通过引用或指针传递给它的对象，则应按引用返回对象</p>
</li>
<li><p><strong>使用const</strong></p>
<p>可以用它来确保方法不修改参数，如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Star::<span class="built_in">Star</span>(<span class="keyword">const</span> <span class="keyword">char</span> * s)&#123;...&#125;;</span><br></pre></td></tr></table></figure>

<p>可以使用它来确保方法不修改调用它的对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Star::show</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>如果函数将参数声明未指向const的引用或指针，则不能将该参数传递给另一个函数，除非后者也确保了参数不会被修改。</p>
</li>
</ul>
<h4 id="13-6-3-公有继承的考虑因素"><a href="#13-6-3-公有继承的考虑因素" class="headerlink" title="13.6.3 公有继承的考虑因素"></a>13.6.3 公有继承的考虑因素</h4><ul>
<li><p><strong>is-a关系</strong></p>
<p>要遵循is-a关系，如果派生类不是一种特殊的基类，则不要使用公有派生。</p>
</li>
<li><p><strong>什么不能被继承</strong></p>
<p>构造函数不能被继承。派生类的构造函数通常使用成员初始化列表语法来调用基类构造函数，以创建派生对象的基类部分。如果派生类构造函数没有使用成员初始化列表显式调用基类构造函数，将使用基类的默认构造函数。</p>
<p>析构函数不能被继承。在释放对象时，程序将首先调用派生类的析构函数，然后调用基类的析构函数。</p>
<p>赋值运算符是不能继承。派生类继承的方法的特征标与基类完全相同，但赋值运算符的特征标随类而异，这是因为它包含一个类型为其所属类的形参。</p>
</li>
<li><p><strong>赋值运算符</strong></p>
<p>如果编译器发现程序将一个对象赋给同一个类的另一个对象，它将自动为这个类提供一个赋值运算符。这个运算符的默认或隐式版本将采用成员赋值，即将原对象的相应成员赋给目标对象的每个成员。</p>
<p>如果类构造函数使用new来初始化指针，则需要提供一个显式赋值运算符。</p>
</li>
<li><p><strong>私有成员与保护成员</strong></p>
<p>对派生类而言，保护成员类似于共有类；但对于外部而言，保护成员与私有成员类似。</p>
</li>
<li><p><strong>虚方法</strong></p>
<p>如果希望派生类能够重新定义方法，则应在基类中将方法定义为虚的，这样可以启用动态联编。</p>
</li>
<li><p><strong>析构函数</strong></p>
<p>基类的析构函数应当是虚的。这样，当通过指向对象的基类指针或引用来删除派生象时，程序将首先调用派生类的析构函数，然后调用基类的析构函数，而不仅仅是调用基类的析构函数。</p>
</li>
<li><p><strong>友元函数</strong></p>
<p>由于友元函数并非类成员，因此不能继承。若希望派生类的友元函数使用基类的友元函数，可以通过强制类型转换，将派生类引用或指针转换为基类引用或指针，然后使用转换后的指针或引用来调用基类的友元函数。</p>
</li>
<li><p><strong>有关使用基类方法的说明</strong></p>
<ul>
<li>派生类对象自动使用继承而来的基类方法，如果派生类没有重新定义该方法。</li>
<li>派生类的构造函数自动调用基类的构造函数。</li>
<li>派生类的构造函数自动调用基类的默认构造函数，如果没有在成员初始化列表中指定其他构造函数。</li>
<li>派生类构造函数显式地调用成员初始化列表中指定的基类构造函数。</li>
<li>派生类方法可以使用作用域解析运算符来调用公有的和受保护的基类方法。</li>
<li>派生类的友元函数可以通过强制类型转换，将派生类引用或指针转换为基类引用或指针，然后使用该引用或指针来调用基类的友元函数。</li>
</ul>
</li>
</ul>
<h4 id="13-6-4-类函数小结"><a href="#13-6-4-类函数小结" class="headerlink" title="13.6.4 类函数小结"></a>13.6.4 类函数小结</h4><p><img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20201030190138.png" alt="image-20201030190138671"></p>
]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>C++ premier plus学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Chapter14 C++中的代码重用</title>
    <url>/2021/03/26/Chapter14_C++%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Chapter14-C-中的代码重用"><a href="#Chapter14-C-中的代码重用" class="headerlink" title="Chapter14 C++中的代码重用"></a>Chapter14 C++中的代码重用</h2><p>类的成员本身是另一个类的对象，称为包含（containment）、组合（composition）或层次化（layering）。</p>
<p>通常，包含、私有继承和保护继承用于实现has-a的关系，即新的类将包含另一个类的对象。多重继承使得能够使用两个或更多的基类派生出新的类，将基类的功能组合在一起。</p>
<h3 id="14-1-包含对象成员的类"><a href="#14-1-包含对象成员的类" class="headerlink" title="14.1 包含对象成员的类"></a>14.1 包含对象成员的类</h3><h4 id="14-1-1-valarray类简介"><a href="#14-1-1-valarray类简介" class="headerlink" title="14.1.1 valarray类简介"></a>14.1.1 valarray类简介</h4><p>valarray类是由头文件valarray支持的，它被定义为一个模板类，以便处理不同的数据类型。模板特性意味着声明对象时，必须指定具体的数据类型。因此，使用valarray类来声明一个对象时，需要在标识符valarray后面加上一对尖括号，并在其中包含所需的数据类型，如：<code>valarray&lt;int&gt; test</code>。</p>
<p>使用公有继承时，类可以继承接口，可能还有实现（基类的纯虚函数提供接口，但不提供实现），获得接口时is-a关系的组成部分。而使用组合，类可以获得实现，但不能获得接口。不继承接口是has-a关系的组成部分。</p>
<p>使用explicit防止单参数构造函数的隐式转换，使用const限制方法修改数据，原因在于：在编译阶段出现错误优于在运行阶段出现错误。</p>
<p>对于继承的对象，构造函数在成员初始化列表中使用类名来调用特定的基类构造函数，对于成员对象，构造函数则使用成员名。</p>
<p>C++要求在构建对象的其他部分之前，先构建对象的所有成员对象，如果省略了初始化列表，C++将使用成员对象所属类的默认构造函数。<strong>当初始化列表中包含多个项目时，这些项目被初始化的顺序为它们被声明的顺序，而不是它们在初始化列表中的顺序</strong>。</p>
<h3 id="14-2-私有继承"><a href="#14-2-私有继承" class="headerlink" title="14.2 私有继承"></a>14.2 私有继承</h3><p>使用私有继承，基类的公有成员和保护乘员都将称为派生类的私有成员。这意味着基类方法将不会成为派生类对象公有接口的一部分，但可以在派生类的成员函数中使用它们。</p>
<p>使用公有继承，基类的公有方法将称为派生类的公有方法，派生类继承基类的接口，这是is-a关系的一部分；使用私有继承，基类的公有方法将称为派生类的私有方法，派生类不继承基类的接口，这种不完全继承是has-a关系的一部分。</p>
<p>包含将对象作为一个命名的成员对象添加到类中，而私有继承将对象作为一个未被命名的继承对象添加到类中。我们使用术语<strong>子对象</strong>（subobject）来表示通过继承或包含添加的对象。（私有继承提供的特性和包含相同：获得实现，但捕获的接口）。</p>
<p>使用多个基类的继承被称为多重继承（multiple inheritance， MI）。</p>
<p>使用私有继承时，只能在派生类的方法中使用基类的方法，然而私有继承使得能够使用类名和作用域解析运算符来调用基类的方法。（<em>使用包含时将使用对象名来调用方法，而是用私有继承时建更实用类名和作用域解析运算符来调用方法</em>）</p>
<p>在私有继承中，在不进行显式类型转换的情况下，不能将指向派生类的引用或指针赋给基类引用或指针。</p>
<p>类声明中包含表示被包含类的显式命名对象，代码可以通过名称引用这些对象，而使用继承将使关系更抽象。然而，私有继承提供的特性比包含多。<em>例如，假设类包含保护成员，则这样的成员在派生类中是可用的，但在继承层次结构外是不可用的，如果使用组合将这样的类包含在另一个类中，后者位于继承层次结构之外，不能访问保护成员</em>。(<strong>通常，应使用包含来建立has-a关系；如果新类需要访问原有类的保护成员，或需要重新定义虚函数，则应使用私有继承</strong>)</p>
<h4 id="14-2-1-保护继承"><a href="#14-2-1-保护继承" class="headerlink" title="14.2.1 保护继承"></a>14.2.1 保护继承</h4><p>保护继承是私有继承的变体。<strong>使用保护继承时，基类的公有成员和保护成员都将称为派生类的保护成员</strong>。和私有继承一样，保护继承中基类的接口在派生类中也是可用的，但在继承层次结构之外是不可用的。使用私有继承时，第三代类将不能使用基类的接口，这是因为基类的公有方法在派生类中编程私有方法；使用保护继承时，基类的公有方法在第二代中将变成受保护的，因此第三代派生类可以使用它们。<br><img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20201031140137.png" alt="image-20201031140051194"></p>
<h4 id="14-2-2-使用using重新定义访问权限"><a href="#14-2-2-使用using重新定义访问权限" class="headerlink" title="14.2.2 使用using重新定义访问权限"></a>14.2.2 使用using重新定义访问权限</h4><p>使用保护派生或私有派生时，基类的公有成员建更成为保护成员或私有成员。若要让基类的方法在派生类外可用，方法之一是<strong>定义一个使用该基类方法的派生类方法</strong>。例如，假设希望Student类能够使用valarray类的sum()方法，可以在Student类的声明中声明一个sum()方法，然后像下面这样定义该方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Student::sum</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::valarray&lt;<span class="keyword">double</span>&gt;::<span class="built_in">sum</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样Student对象便能够调用Student::sum()，后者进而将valarray&lt;double&gt;::sum()方法应用于被包含的valarray对象。</p>
<p>另一种方法是，<strong>将函数调用包装在另一个函数调用中</strong>，即<strong>使用一个using声明来指出派生类可以使用特定的基类成员</strong>，即使采用的是私有派生。例如，假设希望Student类能够使用valarray类的sum()方法，可以在Student类的声明的公有部分中加入如下using声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">private</span> std::string, <span class="keyword">private</span> std::valarray&lt;<span class="keyword">double</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="keyword">using</span> std::valarray&lt;<span class="keyword">double</span>&gt;::<span class="built_in">sum</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>using声明只是用成员名</strong>——没有圆括号、函数特征标和返回类型。</p>
<h3 id="14-3-多重继承"><a href="#14-3-多重继承" class="headerlink" title="14.3 多重继承"></a>14.3 多重继承</h3><p>MI描述的是有多个直接基类的类。与单继承一样，公有MI表示的也是is-a关系，私有MI和保护MI可以表示has-a关系。</p>
<p>虚基类使得从多个类派生出的对象只继承一个基类对象。</p>
<p>对于非虚基类，唯一可以出现在初始化列表中的构造函数是即时基类构造函数。</p>
<p>C++在基类是虚的时，禁止信息通过中间类自动传递给基类。</p>
<p>如果类有间接虚基类，则除非只需使用该虚基类的默认构造函数，否则必须显式地调用该虚基类的某个构造函数。</p>
<ul>
<li>当类通过多条虚途径和非虚途径继承某个特定的基类时，该类将包含一个表示所有的虚途径的基类子对象和分别表示各条非虚途径的多个基类子对象</li>
<li>派生类中的名称优先于直接或简介祖先类中的相同名称（<em>虚二义性规则与访问规则无关</em>）</li>
</ul>
<p>如果一个类从两个不同的类那里继承了两个同名的成员，则需要在派生类中使用类限定符来区分它们。</p>
<p>当派生类使用关键字virtual来指示派生时，基类就成为了虚基类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">marketing</span>:</span> <span class="keyword">public</span> <span class="keyword">virtual</span> reality&#123;...&#125;;</span><br></pre></td></tr></table></figure>

<p>从虚基类的一个或多个示例派生而来的类将只继承一个基类对象。为实现这种特征，必须满足其他要求：</p>
<ul>
<li>有间接虚基类的派生类包含直接调用间接基类构造函数的构造函数，这对于间接非虚基类来说时非法的</li>
<li>通过优先规则解决名称二义性。</li>
</ul>
<h3 id="14-4-类模板"><a href="#14-4-类模板" class="headerlink" title="14.4 类模板"></a>14.4 类模板</h3><p>由于模板不是函数，它们不能单独编译。模板必须与特定的模板实例化请求一起使用。</p>
<p>模板代码不能修改参数的值，也不能使用参数的地址。</p>
<p>实例化模板时，用作表达式参数的值必须是常量表达式。</p>
<p>虽然可以为类模板参数提供默认值，但不能为函数模板参数提供默认值。然而，可以为两种模板中的非类型参数提供默认值。</p>
<h4 id="14-4-1-模板的具体化"><a href="#14-4-1-模板的具体化" class="headerlink" title="14.4.1 模板的具体化"></a>14.4.1 模板的具体化</h4><p>隐式实例化、显式实例化和显式具体化统称为具体化。</p>
<ul>
<li><p>隐式实例化</p>
<p>声明一个或多个对象，指出所需的类型，而编译器使用通用模板生成具体的类定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ArrayTP&lt;<span class="keyword">int</span>, <span class="number">100</span>&gt; staff;<span class="comment">// 隐式实例化</span></span><br></pre></td></tr></table></figure>

<p>编译器在需要对象之前，不会生成类的隐式实例化。</p>
</li>
<li><p>显式实例化</p>
<p>当使用关键字template并指出所需类型来声明类时，编译器将生成类声明的显式实例化。声明必须位于模板所在的名称空间中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTP</span>&lt;</span>string, <span class="number">100</span>&gt;; <span class="comment">//生成ArrayTP&lt;string, 100&gt; 类</span></span><br></pre></td></tr></table></figure></li>
<li><p>显式具体化</p>
<p>显式具体化是特定类型（用于替换模板中的泛型）定义。格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">tempalte &lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">Classname</span>&lt;</span>specialized-type-name&gt;&#123;...&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>部分具体化</p>
<p>即部分限制模板的通用性。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">tempalte &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&#123;</span>...&#125;;<span class="comment">//通用模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;</span>T1, <span class="keyword">int</span>&gt;&#123;...&#125;;<span class="comment">//部分具体化</span></span><br></pre></td></tr></table></figure>

<p>如果指定所有的类型，则&lt;&gt;内将为空，这将导致显式具体化。</p>
</li>
</ul>
<p>如果有多个模板可供选择，编译器将使用具体化程度最高的模板。</p>
<h4 id="14-4-2-模板类和友元"><a href="#14-4-2-模板类和友元" class="headerlink" title="14.4.2 模板类和友元"></a>14.4.2 模板类和友元</h4><ul>
<li><p>模板类的非模板友元函数</p>
<p>在模板类中将一个常规函数声明为友元：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasFriend</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">counts</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>模板类的约束模板友元函数</p>
<p>友元函数本身成为模板。</p>
<p>（1）在类定义前声明每个模板函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  <span class="function"><span class="keyword">void</span> <span class="title">counts</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">report</span><span class="params">(T &amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>（2）在函数中再次将模板声明为友元。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasFriendT</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> counts&lt;TT&gt;();</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> reprot&lt;&gt;(HasFriendT&lt;TT&gt; &amp;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>模板类的非约束模板友元函数</p>
<p>通过在类内部声明模板，可以创建非约束友元函数，即每个函数具体化都是每个类具体化。对于非约束友元，友元模板类型参数与模板类类型参数是不同的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ManyFriend</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    template&lt;typename C, typename D&gt; friend void show2(C &amp;, D &amp;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>C++11允许将语法using =用于非模板，用于非模板时，何种语法与常规的typedef等价。如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keyword">char</span> * pc1;</span><br><span class="line"><span class="keyword">using</span> pc2 = <span class="keyword">const</span> <span class="keyword">char</span> *;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>C++ premier plus学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Chapter15 友元、异常和其他</title>
    <url>/2021/03/26/Chapter15_%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/</url>
    <content><![CDATA[<h2 id="Chapter15-友元、异常和其他"><a href="#Chapter15-友元、异常和其他" class="headerlink" title="Chapter15 友元、异常和其他"></a>Chapter15 友元、异常和其他</h2><h3 id="15-1-友元"><a href="#15-1-友元" class="headerlink" title="15.1 友元"></a>15.1 友元</h3><p>类并非只能拥有友元函数，也可以将类作为友元。在这种情况下友元类的所有方法都可以访问原始类的私有成员和保护成员。</p>
<p>下述语句可以使类成为友元类：<code>friend class className</code>，友元声明可以位于公有、私有或保护部分，其所在的位置无关紧要。</p>
<p>内联函数的链接性时内部的，这意味着函数定义必须在使用函数的文件中。</p>
<h3 id="15-2-嵌套类"><a href="#15-2-嵌套类" class="headerlink" title="15.2 嵌套类"></a>15.2 嵌套类</h3><p>在另一个类中声明的类被称为嵌套类（nexted class），它通过提供新的类型类作用域来避免名称混乱，包含类的成员函数可以创建和使用被嵌套类的对象。</p>
<p>对类进行嵌套与包含并不同。包含意味着将类对象作为另一个类的成员，而对类进行嵌套不创建类成员，而是定义了一种类型，该类型仅在包含嵌套类声明的类中有效。</p>
<p>如果嵌套类是在另一个类的私有部分声明的，则只有后者知道它；如果嵌套类实在另一个类的保护部分声明的，则它对于后者来说是可见的，但对于外部世界则是不可见的；如果嵌套类是在另一个类的共有部分声明的，则允许后者、后者的派生类以及外部世界使用它。<br><img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20201101154217.png" alt="image-20201101154210427"></p>
<p>对嵌套类访问权的控制规则与常规类相同。</p>
<h3 id="15-3-异常"><a href="#15-3-异常" class="headerlink" title="15.3 异常"></a>15.3 异常</h3><p>abort()函数的原型位于头文件cstdlib中，其典型实现是向标准错误流发送消息abnormal program termination，然后终止进程。abort()是否刷新问及那缓冲区取决于实现，而exit()函数刷新文件缓冲区，但不显示消息。</p>
<p>对异常的处理通常包括3个组成部分：</p>
<ul>
    <li>引发异常</li>
    <li>使用处理程序捕获异常</li>
    <li>使用try块</li>
</ul>

<p>throw语句实际上是跳转，即命令程序跳到另一条语句。throw关键字表示引发一场，紧随其后的值指出了异常的特征。</p>
<p>执行throw语句类似于执行返回语句，因为它也将终止函数的执行；但throw不是将控制权返回给调用程序，而是导致程序沿函数调用序列后退，直到找到包含try块的函数。</p>
<p>catch块类似于函数定义，但并不是函数定义，关键字catch表明这是一个处理程序，当异常与该处理程序匹配时，程序将执行其括号中的代码。</p>
<p>如果程序引发了异常，而没有try块或灭有匹配的处理程序时，在默认情况下，程序最终将调用abort()函数。</p>
<p>通常引发异常的函数将传递一个对象。这样做的重要优点之一是，可以使用不同的异常类型来区分不同的函数在不同情况下引发的异常。</p>
<p>如果有一个异常类继承层次结构，应该这样排列catch块：将捕获位于层次结构最下面的异常类的catch放在最前面，将捕获基类异常的catch语句放在最后面。</p>
<p>一般而言，logit_error系列异常表明存在可通过编程修复的问题，而runtime_error系列异常表明存在无法避免的问题。</p>
<h3 id="15-4-RTTI"><a href="#15-4-RTTI" class="headerlink" title="15.4 RTTI"></a>15.4 RTTI</h3><p>C++有3个支持RTTI（运行阶段类型识别，Runtime  Type Identification）的元素：</p>
<ul>
<li>如果可能的话，dynamic_cast运算符将使用一个指向基类的指针来生成一个指向派生类的指针；否则该运算符返回0——空指针；</li>
<li>typeid运算符返回一个指出对象的类型的值；</li>
<li>type_info结构存储了有关特定类型的信息。</li>
</ul>
<p>只能将RTTI用于包含虚函数的类层次结构中，原因在于只有对于这种类层次结构，才应该将派生对象的地址赋给基类指针。</p>
<p>通常，如果指向的对象（*pt）的类型为Type或是从Type直接或间接派生而来的类型，则下面的表达式将指针pt转换为Type类型的指针：<code>dynamic_cast&lt;Type *&gt;(pt)</code>，否则，结果为0，即空指针。</p>
<p>typeid运算符使得能够确定两个对象是否为同种类型，它接受两种参数：类名、结果为对象的表达式。typeid运算符返回一个对type_info对象的引用。其中type_info是在头文件typeinfo中定义的一个类，它重载了==和！=运算符，以便可以使用这些运算符来对类型进行比较。</p>
<h3 id="15-5-类型转换运算符"><a href="#15-5-类型转换运算符" class="headerlink" title="15.5 类型转换运算符"></a>15.5 类型转换运算符</h3><p>static_cast用于数据类型的强制转换，强制将一种数据类型转换为另一种数据类型。</p>
<p>reinterpret_cast主要有三种强制转换用途：<em><strong>改变指针或引用的类型、将指针或引用转换为一个足够长度的整形、将整型转换为指针或引用类型</strong></em></p>
<p>const限定符通常被用来限定变量，用于表示该变量的值不能被修改。而const_cast则正是用于强制去掉这种不能被修改的常数特性，但需要特别注意的是const_cast不是用于去除变量的常量性，而是去除指向常数对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用</p>
<p><strong>在类的转换时，在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的。在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全</strong></p>
]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>C++ premier plus学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Chapter16 string类和标准模板库</title>
    <url>/2021/03/26/Chapter16_string%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/</url>
    <content><![CDATA[<h2 id="Chapter16-string类和标准模板库"><a href="#Chapter16-string类和标准模板库" class="headerlink" title="Chapter16 string类和标准模板库"></a>Chapter16 string类和标准模板库</h2><h2 id="16-1-string类"><a href="#16-1-string类" class="headerlink" title="16.1 string类"></a>16.1 string类</h2><h3 id="16-1-1-构造字符串"><a href="#16-1-1-构造字符串" class="headerlink" title="16.1.1 构造字符串"></a>16.1.1 构造字符串</h3><p>string类将string::npos定义为字符串的最大长度，通常为unsigned int的最大值，下表中NBTS(null-terminated string)表示以空字符结束的字符串，即传统的c字符串。<br><img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20201108133940.png" alt="image-20201108133932793"></p>
<h3 id="16-1-2-string类输入"><a href="#16-1-2-string类输入" class="headerlink" title="16.1.2 string类输入"></a>16.1.2 string类输入</h3><p>对于C-风格字符串，有三种输入方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> info[<span class="number">100</span>];</span><br><span class="line">cin &gt;&gt; info; <span class="comment">//read a word</span></span><br><span class="line">cin.<span class="built_in">getline</span>(info, <span class="number">100</span>); <span class="comment">//read a line, discard \n</span></span><br><span class="line">cin.<span class="built_in">get</span>(info, <span class="number">100</span>); <span class="comment">//read a line, leave \n in queue</span></span><br></pre></td></tr></table></figure>

<p>对于string对象，有两种方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string stuff;</span><br><span class="line">cin &gt;&gt; stuff; <span class="comment">//read a word</span></span><br><span class="line"><span class="built_in">getline</span>(cin, stuff); <span class="comment">//read a line, discard \n</span></span><br></pre></td></tr></table></figure>

<p>两个版本的getline()都有一个可选参数，用于指定使用哪个字符来确定输入的边界：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cin.<span class="built_in">getline</span>(info, <span class="number">100</span>, <span class="string">&#x27;:&#x27;</span>); <span class="comment">//read up to :, discard :</span></span><br><span class="line"><span class="built_in">getline</span>(stuff, <span class="string">&#x27;:&#x27;</span>); <span class="comment">//read up to :, discard :</span></span><br></pre></td></tr></table></figure>

<p>在功能上，两者的主要区别在于，string版本的getline()将自动调整目标string对象的大小，使之刚好能够存储输入的字符。在设计方面的区别是，读取C-风格字符串的函数是istream类的方法，而string版本是独立的函数。对于C-风格字符串输入，cin是调用对象；而对于string对象输入，cin是一个函数参数。</p>
<p>string版本的getline()函数从输入中读取字符，并将其存储到目标string中，直到发生下列三种情况之一：<br>（1）到达文件尾，在这种情况下，输入流的eofbit将被设置，这意味着方法fail()和eof()都将返回true；<br>（2）遇到分界字符（默认为\n），在这种情况下，将把分界字符从输入流中删除，但不存储它；<br>（3）读取的字符数达到最大允许值（string::npos和可供分配的内存字节数中较小的一个），在这种情况下，将设置输入流的failbit，这意味着fail()将返回true。</p>
<h3 id="16-1-3-使用字符串"><a href="#16-1-3-使用字符串" class="headerlink" title="16.1.3 使用字符串"></a>16.1.3 使用字符串</h3><p>size()和length()成员函数都返回字符串中的字符数，length()成员来自较早版本的string类，而size()则是为提供STL兼容性而添加的。</p>
<p><img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20201108142109.png" alt="image-20201108142109286"></p>
<p>string库还提供了相关的方法：rfind()、find_first_of()、find_last_of()、find_first_not_of()和find_last_not_of()，它们的重载函数特征标都与find()方法相同。<br>rfind()方法查找子字符串或字符最后一次出现的位置；<br>find_first_of()方法在字符串中查找参数中任何一个字符首次出现的位置；<br>find_last_of()方法在字符串中查找参数中任何一个字符最后一次出现的位置；<br>find_first_not_of()方法在字符串中查找第一个不包含在参数中的字符。</p>
<p>string库实际上是基于一个模板类的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">charT</span>, <span class="keyword">class</span> <span class="title">traits</span> =</span> <span class="keyword">char</span> _traits&lt;charT&gt;, <span class="class"><span class="keyword">class</span> <span class="title">Allocator</span>=</span>allocator&lt;charT&gt;&gt;</span><br><span class="line">basic_string&#123;&#125;;<span class="comment">//有四个具体化，每个具体化都有一个typedef名称</span></span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="keyword">char</span>&gt; string;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="keyword">wchar_t</span>&gt; wstring;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="keyword">char16_t</span>&gt; u16string;<span class="comment">//c++11</span></span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="keyword">char32_t</span>&gt; u32string;<span class="comment">//c++11</span></span><br></pre></td></tr></table></figure>

<h2 id="16-2-智能指针模板"><a href="#16-2-智能指针模板" class="headerlink" title="16.2 智能指针模板"></a>16.2 智能指针模板</h2><p>auto_ptr、unique_ptr和shared_ptr这三个智能指针模板都定义了类似指针的对象，可以将new获得的地址赋给这种对象。当智能指针过期时，其析构函数将使用delete来释放内存。</p>
<p>要创建智能指针对象，必须包含头文件memory，然后使用通常的模板语法来实例化所需类型的指针。</p>
<p>所有智能指针类都有一个explicit构造函数，该构造函数将指针作为参数。</p>
<p>解决删除同一对象两次的方法：<br>（1）定义赋值运算符，使之进行深复制，这样两个指针将指向不同的对象。<br>（2）建立所有权（ownership）概念，对于特定的对象，只能有一个智能指针可拥有它，这样只有拥有对象的智能指针的构造函数会删除该对象。（unique_ptr)<br>（3）创建智能更高的指针，跟踪引用特定对象的智能指针书（引用计数，shared_ptr采用的策略）</p>
<p>若程序试图将一个unique_ptr赋给另一个，如果源unique_ptr是个临时右值，编译器允许这样做；如果源unique_ptr将存在一段时间，编译器将禁止这样做。</p>
<p>如果程序要使用多个指向同一对象的指针，应选择shared_ptr。</p>
<p>模板shared_ptr包含一个显式构造函数，可用于将右值unique_ptr转换为shared_ptr，shared_ptr将接管原来贵unique_ptr的所有对象。</p>
<h2 id="16-3-标准模板库"><a href="#16-3-标准模板库" class="headerlink" title="16.3 标准模板库"></a>16.3 标准模板库</h2><p>STL提供了一组表示容器、迭代器、函数对象和算法的模板。容器是一个与数组类似的单元，可以存储若干个值。STL容器是同质的，即存储的值的类型相同；算法完成特定任务的处方；迭代器能够用来遍历容器的对象，与能够遍历数组的指针类似，是广义指针；函数兑现格式类似于函数的对象，可以是类对象或函数指针。</p>
<p>所有的STL容器都提供了一些基本方法，其中包括size()——返回容器中的元素数目、swap()——交换两个容器的内容、begin()——返回一个指向容器中第一个元素的迭代器、end()——返回一个表示<u>超过容器尾</u>（指向容器最后一个元素后面的哪个元素）的迭代器。</p>
<p>每个容器类都定义了一个合适的迭代器，该迭代器的类型是一个名为iterator的typedef，其作用域为整个类。</p>
<p>vector类方法：<br>push_back()将元素添加到矢量末尾。<br>erase()方法删除矢量中给定区间的元素。它接受两个迭代器参数，这些参数定义了要删除的区间。<br>insert()方法接受3个迭代器参数，第一个参数制定了新元素的插入位置，第二个和第三个迭代器参数定义了被插入区间，该区间通常是另一个容器对象的一部分。</p>
<p>对有些操作来说，类特定算法的效率比通用算法高。</p>
<p>for_each()函数接受3个参数，前两个是定义容器中区间的迭代器，最后一个是指向函数的指针（更普遍的说最后一个参数是一个函数对象）。for_each()函数将被指向的函数应用于容器区间中的各个元素。被指向的函数不能修改容器元素的值。</p>
<p>Random_shuffle()函数接受两个指定区间的迭代器参数，并随机排列该区间中的元素（要求容器类允许随机访问）。</p>
<h2 id="16-4-泛型编程"><a href="#16-4-泛型编程" class="headerlink" title="16.4 泛型编程"></a>16.4 泛型编程</h2><p>面向对象编程关注的是编程的数据方面，而泛型编程关注的是算法。</p>
<p>模板使得算法独立于存储的数据类型，而迭代器使得算法独立于使用的容器类型。</p>
<ul>
<li><p>输入迭代器</p>
<p>输入迭代器可被程序用来读取容器中的信息。基于输入迭代器的任何算法都应当是单通行（single-pass）的，不依赖于前一次遍历时的迭代器值，也不依赖于本次遍历中前面的迭代器值。</p>
</li>
<li><p>输出迭代器</p>
<p>程序输出就是容器的输入。</p>
<p>输出迭代器于输入迭代器相似，只是解除引用让程序能够修改容器值，而不能读取</p>
<p>对于单通行、只读算法，可以使用输入迭代器；而对于单通行、只写算法，则可以使用输出迭代器</p>
</li>
<li><p>正向迭代器</p>
<p>正向迭代器只是用++运算符莱遍历容器，所以它每次沿容器向前移动一个元素，与输入和输出迭代器不同的是，它总是按相同的顺序遍历一系列值。将正向迭代器递增后，仍然可以对前面的迭代器值接触引用，并可以得到相同的值</p>
</li>
<li><p>双向迭代器</p>
<p>双向迭代器具有正向迭代器的所有特性，同时支持两种（前缀和后缀）递减运算符</p>
</li>
<li><p>随机访问迭代器</p>
<p>随机访问迭代器具有双向迭代器的所有特性，同时添加了支持随机访问的操作和用于对元素进行排序的关系运算符。</p>
</li>
</ul>
<p><img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20201108153205.png" alt="image-20201108153205759"></p>
<h2 id="16-5-函数对象"><a href="#16-5-函数对象" class="headerlink" title="16.5 函数对象"></a>16.5 函数对象</h2><p>函数对象也叫函数符（functor），是可以以函数方式与()结合使用的任意对象。</p>
<p>函数符概念：</p>
<ul>
<li>生成器（generator）是不用参数就可以调用的函数符。</li>
<li>一元函数（unary function）是用一个参数可以调用的函数符。</li>
<li>二元函数（binary function）是用两个参数可以调用的函数符。</li>
<li>返回bool值的一元函数是谓词（predicdate).</li>
<li>返回bool值的二元函数是二元谓词（binary predicate）。</li>
</ul>
<p><img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20201108153857.png" alt="image-20201108153857841"></p>
]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>C++ premier plus学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Chapter2 开始学习C++</title>
    <url>/2021/03/26/Chapter2_%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0C++/</url>
    <content><![CDATA[<h2 id="Chapter2-开始学习C"><a href="#Chapter2-开始学习C" class="headerlink" title="Chapter2 开始学习C++"></a>Chapter2 开始学习C++</h2><h3 id="2-1类简介"><a href="#2-1类简介" class="headerlink" title="2.1类简介"></a>2.1类简介</h3><p>类是用户定义的一种数据类型。要定义类，需要描述它能够表示什么信息和可对数据执行哪些操作，类之于对象就像类型之于变量。也就是说，类定义描述的是数据格式及其用法，而对象则是根据数据格式规范创建的实体。（<strong>类描述了一种数据类型的全部属性（包括可使用它执行的操作），对象是根据这些描述创建的实体</strong>）</p>
<h3 id="2-2函数"><a href="#2-2函数" class="headerlink" title="2.2函数"></a>2.2函数</h3><p>不要混淆函数原型和函数定义，<strong>原型只描述函数接口</strong>，而定义中包含了函数的代码。应在首次使用函数之前提供其原型，通常的做法是将原型放在main()函数定义的前面。</p>
<p>函数格式：函数包含一个函数头，然后是花括号中的函数体。可以把函数的格式统一如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">type <span class="title">functionname</span><span class="params">(argumentlist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c++不允许将函数定义嵌套在另一个函数定义中，每个函数定义都是独立的，所有函数的创建都是平等的。</p>
<ul>
<li>main()函数返回的值到哪去了？答案是：可以将计算机操作系统看作调用程序，main()的返回值并不是返回给程序的其他部分，而是返回给操作系统。很多操作系统都可以使用程序的返回值（退出值），通常的约定是，退出值位0则表示程序运行成功，为非零则意味着存在问题。</li>
<li>通常，在可以使用一个简单常量的地方，都可以使用一个返回值类型与该常量相同的函数。</li>
<li>函数原型描述了函数接口，参数列表指出了何种信息被传递给函数，函数类型指出了返回值的类型。</li>
</ul>
<h3 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h3><p>C++程序有一个或多个被称为函数的模块组成。程序从main()函数开始执行，函数由函数头和函数体组成，函数头指出函数的返回值的类型和函数期望通过参数传递给他的信息的类型，函数体由一系列位于花括号中的c++语句组成。</p>
<p>类是用户定义的数据类型规范，它详细描述了如何表示信息以及可对数据执行的操作。对象是根据类规范创建的实体，就像简单变量是根据数据类型描述创建的实体一样。</p>
]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>C++ premier plus学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Chapter17 输入、输出、和文件</title>
    <url>/2021/03/26/Chapter17_%E8%BE%93%E5%85%A5%E3%80%81%E8%BE%93%E5%87%BA%E5%92%8C%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="Chapter17-输入、输出和文件"><a href="#Chapter17-输入、输出和文件" class="headerlink" title="Chapter17 输入、输出和文件"></a>Chapter17 输入、输出和文件</h2><p>C++程序把输入和输出看作字节流。输入时，程序从输入流中抽取字节；输出时，程序将字节插入到输出流中。流充当了程序和流源或流文件之间的桥梁，这使得C++程序可以以相同的方式对待来自键盘的输入和来自文件的输入。因此管理输入包含两步：</p>
<ul>
<li>将流与输入去向的程序关联起来</li>
<li>将流与文件连接起来</li>
</ul>
<p><img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20201109152900.png" alt="image-20201109152852856"></p>
<p>通过使用缓冲区可以更高效地处理输入和输出。缓冲区是用作中介的内存块，它是将信息从设备传输到程序或从程序传输给设备的临时存储工具。输出时，程序首先填满缓冲区，然后把整块数据传输给硬盘，并清空缓冲区，以备下一批输出使用，这被称为刷新缓冲区（flushing the buffer）。</p>
<p>streambuf类为缓冲区提供了内存，并提供了用于填充缓冲区、访问缓冲区内容、刷新缓冲区和管理缓冲区内存的类方法；<br>iso_base类表示流的一般特征，如是否可读取、是二进制流还是文本流等；<br>iso类基于ios_base，其中包括了一个指向streabuf对象的指针成员；<br>ostream类是从ios类派生来的，提供了输出方法；<br>istream也是从ios类派生而来的，提供了输入方法；<br>iostream类是基于istream和ostream类的，因此继承了输入方法和输出方法。<br><img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20201109153626.png" align="center" style="zoom:75%;" /></p>
<p>在程序中包含iostream头文件将自动创建8个流对象（4个用于窄字符流，4个用于宽字符流）</p>
<ul>
<li>cin对象对应于标准输入流。wcin对象与此类似，但处理的是wchar_t类型；</li>
<li>cout对象与标准输出流相对应。wcout对象与此类似，单处理的是wchar_t类型；</li>
<li>cerr对象与标准错误流相对应，可用于显示错误信息。这个流没有被缓冲，这意味着信息将被直接发送给屏幕，而不会等到缓冲区填满或新的换行符。wcerr对象与此类似，但处理的是wchar_t类型；</li>
<li>clog对象也对应着标准错误流，与cerr不同的是这个流被缓冲。wclog对象与此类似，单处理的是wchar_t类型。</li>
</ul>
<h3 id="17-1-使用cout进行输出"><a href="#17-1-使用cout进行输出" class="headerlink" title="17.1 使用cout进行输出"></a>17.1 使用cout进行输出</h3><p>ostream类将数据内部表示（二进制位模式）转换为由字符字节组成的输出流。</p>
<p>&lt;&lt;运算符的默认含义是左移运算符，ostream类重新定义了&lt;&lt;运算符，方法是将其重载为输出，在这种情况下，&lt;&lt;叫作插入运算符。</p>
<p>C++用指向字符串位置的指针来表示字符串。指针的形式可以是char数组名、显式的char指针或用引号扩起的字符串。</p>
<p>插入运算符的所有化身的返回类型都是ostream &amp;，也就是说，原型格式如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(type);</span><br></pre></td></tr></table></figure>

<p>除了各种operator&lt;&lt;()函数外，ostream类还提供了put()方法和write()方法，前者用于显示字符，后者用于显示字符串。</p>
<p>最初put()方法的原型如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ostream &amp; <span class="title">put</span><span class="params">(<span class="keyword">char</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>当前标准与此相同，但被模板化，以适用于wchar_t。可以用类方法表示法来调用它：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout.<span class="built_in">put</span>(<span class="string">&#x27;w&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>其中cout是调用方法的对象，put()是类成员函数，和&lt;&lt;运算符函数一样，该函数也返回一个指向调用对象的引用，因此可以用它将输出拼接。</p>
<p>write()方法显示整个字符串，其模板原型如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">basic_ostream &lt;charT, traits&gt; &amp; <span class="built_in">write</span>(<span class="keyword">const</span> char_type * s, streamsize n);</span><br></pre></td></tr></table></figure>

<p>write()的第一个参数提供了要显示的字符串的地址，第二个参数指出了要显示多少个字符。</p>
<p>write()方法并不会在遇到空字符时自动停止打印字符，而只是打印指定数目的字符，即使超出了字符串的边界！、</p>
<p>控制符flush刷新缓冲区，而控制符endl刷新缓冲区并插入一个换行符。</p>
<p>ostream插入运算符将值转换为文本格式，在默认情况下，格式化值的方式如下：</p>
<ul>
<li>对于char值，如果它代表的是可打印字符，则将被作为一个字符显示在宽度位一个字符的字段中。</li>
<li>对于数值整型，将以十进制方式显示在一个刚好容纳该数字及负号（如果有的话）的字段中。</li>
<li>浮点类型被显示为6位，末尾的0不显示</li>
</ul>
<p><strong>1、修改显示时使用的计数系统</strong></p>
<p>ios_base  类存储了描述格式状态的信息，如要控制整数以十进制、十六进制还是八进制显示，可以使用dec、hex和oct控制符。如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">hex</span>(cout);<span class="comment">//将cout对象的计数系统格式状态设置为十六进制</span></span><br></pre></td></tr></table></figure>

<p>虽然控制符不是成员函数，因此不必通过对象来调用，但它们通常的使用方式为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; hex;</span><br></pre></td></tr></table></figure>

<p>可以单独使用控制符，也可以将其作为一系列插入的组成部分。</p>
<p><strong>2、调整字段宽度</strong></p>
<p>可以使用width()成员函数将长度不同的数字放到宽度相同的字段中，该方法的原型为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">width</span><span class="params">()</span></span>;<span class="comment">//返回字段宽度的当前设置；</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">width</span><span class="params">(<span class="keyword">int</span> i)</span></span>; <span class="comment">//将字段宽度设置为i个空格，并返回以前的字段宽度值。</span></span><br></pre></td></tr></table></figure>

<p>width()方法只影响将显示的下一个项目，然后字段宽度将恢复为默认值。</p>
<p>C++永远不会截断数据，因此如果在宽度为2的字段中打印一个7位值，C++将增宽字段，以容纳该数据。</p>
<p><strong>3、填充字符</strong></p>
<p>在默认情况下，cout用空格填充字段中未被使用的部分，可以用fill()成员函数来改变填充字符。与字段宽度不同的是，新的填充字符将一直有效，直到更改它为止。</p>
<p><strong>4、设置浮点数的显示精度</strong></p>
<p>浮点数精度的含义取决于输出模式。在默认模式下，它指的是显示的总位数。在定点模式和科学模式下，精度指的是小数点后面的位数(<em>默认的C++模式对应于%g说明符，定点表示法对应于%f说明符，而科学表示法对应于%e说明符</em>)。precision()成员函数能够更改精度，新的精度设置将一直有效，直到被重新设置。</p>
<p><strong>6、setf()</strong></p>
<p>ios_base类有一个受保护的数据成员，其中的各位（标记）分别控制这格式化的各个方面，例如计数系统、是否显示末尾的0等。</p>
<p>setf()函数由两个原型，第一个为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">fmtflags <span class="title">setf</span><span class="params">(fmtflags)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中fmtflags是bitmask<a id="tag1" href="#test1"><sup>[1]</sup></a>类型的typedef名，用于存储格式标记 。</p>
<p><img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20201109174146.png" alt="image-20201109174146091"></p>
<p>第二个setf()原型接受两个参数，并返回以前的设置：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">fmtflags <span class="title">setf</span><span class="params">(fmtflags, fmtflags)</span></span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20201109174730.png" alt="image-20201109174730908"></p>
<p>调用setf()的效果可以通过unsetf()消除，后者原型如下：<code>void unsetf(fmtflags mask);</code>.</p>
<p><strong>6、标准控制符</strong></p>
<p>使用setf()不是进行格式化、对用户最为有好的方法，C++提供了多个控制符，能够调用setf()，并自动提供正确的参数。<br><img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20201109175554.png" alt="image-20201109175554821"></p>
<p><strong>8、头文件iomanip</strong></p>
<p>使用iostream工具来设置一些个是指不太方便，为了简化工作，C++在头文件iomanip中提供了其他一些控制符，3个最常用的控制符分别是setprecision()、setfill()和setw(),分别用来设置精度、填充字符和字段宽度。</p>
<h3 id="17-2-使用cin进行输入"><a href="#17-2-使用cin进行输入" class="headerlink" title="17.2 使用cin进行输入"></a>17.2 使用cin进行输入</h3><p>不同版本的抽取运算符查看输入流的方法是相同的，它们跳过空白（空格、换行符和制表符），直到遇到非空白字符。</p>
<p>cin或cout对像包含一个描述流状态的数据成员。流状态（被定义为iostate类型，而iostate是一种bitmask类型）由3个ios_base元素组成：eobit、badbit和failbit，其中每一个元素都是一位。当全部3个状态位都设置为0时，说明一切顺利。</p>
<p><img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20201109180459.png" alt="image-20201109180459398"></p>
<p>设置流状态位有一个非常重要的后果：流将对后面的输入或输出关闭，直到位被清楚。如果希望程序在流状态为被设置后能够读取后面的输入，就必须将流状态重置为良好。这可以通过调用clear()方法来实现。</p>
<p><img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20201109180720.png" alt="image-20201109180720414"></p>
<p>read()函数读取指定数目的字节，并将它们存储在指定的位置中。<br>peek()函数返回输入中的下一个字符，但不愁去输入流中的下一个字符。<br>gount()函数返回最后一个非格式化抽取方法读取的字符数。<br>putback()函数将一个字符插入到输入字符串中，被插入的字符将是下一条输入语句读取的第一个字符。</p>
<h3 id="17-3-文件输入和输出"><a href="#17-3-文件输入和输出" class="headerlink" title="17.3 文件输入和输出"></a>17.3 文件输入和输出</h3><p>由于ofstream是ostream的派生类，因此可以使用所有的ostream方法，包括各种插入运算符定义、格式化方法和控制符。</p>
<p>以默认模式打开文件进行输出将自动把文件的长度截断位零，这相当于删除已有的内容。</p>
<p>ios_base类定义了一个openmode类型，用于表示模式；与fmtflags和iostate类型一样，它也是一种bitmask类型。</p>
<p><img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20201109181714.png" alt="image-20201109181713995"></p>
<p>ios_base::ate和ios_base::app都将文件指针指向打开的文件尾。二者的区别在于，后者只允许将数据添加到文件尾，而前者将指针放到文件尾。</p>
<p><img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20201109181942.png" alt="image-20201109181942871"></p>
<p><a id="test1" href="#tag1">[1]</a>:bitmask类型是一种用来存储各个位值的类型。它可以是整型、枚举，也可以是STL bitset容器，这里的主要思想是每一位都是可以单独访问的。</p>
]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>C++ premier plus学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Chapter3 处理数据</title>
    <url>/2021/03/26/Chapter3_%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h2 id="Chapter3-处理数据"><a href="#Chapter3-处理数据" class="headerlink" title="Chapter3 处理数据"></a>Chapter3 处理数据</h2><p>面向对象编程（object oriented programming, OOP)的本质是设计并扩展自己的数据类型，设计自己的数据类型就是让类型与数据匹配。</p>
<h3 id="3-1-简单变量"><a href="#3-1-简单变量" class="headerlink" title="3.1 简单变量"></a>3.1 简单变量</h3><p>为把信息存储在计算机中，程序必须记录三个基本属性：</p>
<ul>
<li>信息将存储在哪里；</li>
<li>要存储什么值；</li>
<li>存储何种类型的信息；</li>
</ul>
<h4 id="3-1-1-变量名"><a href="#3-1-1-变量名" class="headerlink" title="3.1.1 变量名"></a>3.1.1 变量名</h4><p>C++命名规则：</p>
<ul>
<li>在名称中只能使用字母字符、数字和下划线。</li>
<li>名称的第一个字符不能是数字。</li>
<li>区分大写字符和小写字符。</li>
<li>不能将C++关键字用作名称。</li>
<li><strong>以两个下划线或下划线和大写字母打头的名称都被保留给实现（编译器及其使用的资源）使用。以一个下划线开头的名称被保留给实现，用作全局标识符。</strong></li>
<li>C++对名称的长度没有限制，名称中所有的字符都有意义（某些平台可能会有长度限制）</li>
</ul>
<h4 id="3-1-2-整型"><a href="#3-1-2-整型" class="headerlink" title="3.1.2 整型"></a>3.1.2 整型</h4><p>如果将无限大的整数看作很大，则不可能用有限的计算机内存来表示所有的整数，因此，语言只能表示所有整数的一个子集。不同C++整型使用不同的内存量来存储整数，使用的内存量越大，可以表示的整数值范围也越大。术语<strong>宽度</strong>（width）用于描述存储整数时使用的内存量，使用的内存越多，则越宽。</p>
<h4 id="3-1-3-整型short、int、long和long-long"><a href="#3-1-3-整型short、int、long和long-long" class="headerlink" title="3.1.3 整型short、int、long和long long"></a>3.1.3 整型short、int、long和long long</h4><p>C++的short、int、long和long long类型通过使用不同数目的位来存储值，最多能表示4种不同的整数宽度。C++提供了一种灵活的标准，它确保了最小长度：</p>
<ul>
<li>short至少16位；</li>
<li>int至少与short一样长；</li>
<li>long至少32位，且至少与int一样长；</li>
<li>long long 至少64位，且至少与long一样长</li>
</ul>
<p>对类型名使用sizeof运算符时，应该将名称放在括号中，但对变量名使用该运算符时，括号时可选的。</p>
<p>头文件climits（老式实现中位limits.h）中包含了关于整型限制的信息。具体来说，它定义了表示各种限制的符号名称。</p>
<h3 id="3-2-const限定符"><a href="#3-2-const限定符" class="headerlink" title="3.2 const限定符"></a>3.2 const限定符</h3><p>创建常量的通用格式如下：<code>const type name  = value;</code>应在声明中对常量进行初始化，如果在声明常量时没有提供值，则该常量的值将是不确定的，且无法修改。</p>
<h3 id="3-3-浮点数"><a href="#3-3-浮点数" class="headerlink" title="3.3 浮点数"></a>3.3 浮点数</h3><p>使用浮点类型可以表示带小数部分的数字。计算机将这样的值分成两部分存储，一部分表示值（基准值），另一部分用于对值进行放大或缩小（缩放因子）。（d.dddE+n指的是将小数点向右移动n位，而d.dddE-n指的是将小数点向左移动n位，之所以称为“浮点数”，就是因为小数点可移动）</p>
<p><img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20201011101447.png" alt="image-20201011101439767" style="zoom: 67%;" /></p>
<p>与整数相比，浮点数有两大优点。首先，它们可以表示整数之间的值，其次，由于有缩放因子，它们可以表示的范围大得多。另一方面，浮点运算的速度通常比整数运算慢，且精度将降低。</p>
<h3 id="3-4-C-算数运算符"><a href="#3-4-C-算数运算符" class="headerlink" title="3.4 C++算数运算符"></a>3.4 C++算数运算符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">对操作数执行加法运算</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">从第一个数中减去第二个数</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">将操作数相乘</td>
</tr>
<tr>
<td style="text-align:center">/</td>
<td style="text-align:center">用第一个数除以第二个数，如果两个操作数都是整数，则结果位商的整数部分，小数部分被舍弃</td>
</tr>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:center">生成第一个数除以第二个数后的余数（<strong>两个操作数必须都是整型，该运算符用于浮点数将导致编译错误，如果其中一个是负数，则结果的符号满足如下规则：</strong>$(a/b)*b+a%b=a$）</td>
</tr>
</tbody>
</table>
</div>
<p>算数运算符遵循通常的代数优先级，先乘除，后加减。当两个运算符的优先级相同时，C++将看操作数的结合性（associativity）是从做到右，还是从右到左。</p>
<p>除法运算符的行为取决于操作数的类型。如果两个操作数都是整数，则C++将执行整数除法，这意味着结果的小数部分将被丢弃，使得最后的结果是一个整数。如果其中有一个（或两个）操作数是浮点值，则保留结果的小数部分。</p>
<p><img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20201011103356.png" alt="image-20201011103356575" style="zoom: 80%;" /></p>
<p>C++允许将一种类型的值赋给另一种类型的变量，这样做时，值将被转换为接收变量的类型。将一个值赋给取值范围更大的类型通常不会导致什么问题，然而进行窄转换可能会出现一些问题。</p>
<p><table>
    <caption><strong>潜在的数值转换问题</strong></caption>
    <tr>
    <th align="center">转换</th>
    <th align="center">潜在问题</th>
    </tr>
    <tr>
    <td>将较大的浮点类型转换为较小的浮点类型</td>
    <td><b>精度（有效数位）降低</b>，原来的值可能超出目标类型的取值范围，在这种情况下，结果将是不确定的</td>
    </tr>
     <tr>
    <td>将浮点类型转换位整型</td>
    <td><b>小数部分丢失</b>，原来的值可能超出目标类型的取值范围，在这种情况下，结果将是不确定的</td>
    </tr>
    <tr>
    <td>将较大的整数转换为较小的整数</td>
    <td>原来的值可能超出目标类型的取值范围，通常只复制右边的字节</td>
    </tr>
</table><br><strong>列表初始化</strong>：C++将使用大括号的初始化称为列表初始化（List-initialization)，因为这种初始化常用于给复杂的数据类型提供值列表。列表初始化不允许缩窄（narrowing），及变量的类型可能无法表示赋给它的值。</p>
<p>C++允许通过强制类型转换显式地进行类型转换，强制类型转换不会修改变量本身，而是创建一个新的、指定类型的值，可以在表达式中使用这个值。</p>
<p>C++11新增了一个工具，让编译器能够根据初始值的类型推断变量的类型，为此重新定义了auto的含义，在初始化声明中，如果使用关键字auto，而不指定变量的类型，编译器将把变量的类型设置成与初始值相同。</p>
]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>C++ premier plus学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Chapter4 复合类型</title>
    <url>/2021/03/26/Chapter4_%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="Chapter4-复合类型"><a href="#Chapter4-复合类型" class="headerlink" title="Chapter4 复合类型"></a>Chapter4 复合类型</h2><h3 id="4-1-数组"><a href="#4-1-数组" class="headerlink" title="4.1 数组"></a>4.1 数组</h3><p>数组（array）是一种数据结构，能够存储多个同类型的值。数组声明应指出以下三点：</p>
<ul>
<li>存储在每个元素中值的类型。</li>
<li>数组名。</li>
<li>数组中的元素数。</li>
</ul>
<p>声明数组的通用格式如下：<code>typename arrayName[arraySize]</code>表达式<code>arraySize</code>指定元素数目，它必须是整型常数或<code>const</code>值，也可以是常量表达式，即<strong>其中所有的值在编译时是已知的</strong>。</p>
<p>数组初始化规则：</p>
<ul>
<li>只有在定义数组时才能使用初始化，此后就不能使用了，也不能将一个数组赋给另一个数组；</li>
<li>可以使用下标分别给数组中的元素赋值；</li>
<li>如果支队数组的一部分进行初始化，则编译器将把其他元素设置为0；</li>
<li><p>c++11数组初始化：</p>
<ol>
<li><p>初始化数组时，可省略等号（=）；</p>
</li>
<li><p>可不在大括号内包含任何东西，这将把所有元素都设置为0。</p>
<p>如<code>float blances[4]{}</code>,将float数组balances的所有元素设置为0；</p>
</li>
<li><p>列表初始化禁止缩窄转换。</p>
</li>
</ol>
</li>
</ul>
<h3 id="4-2-字符串"><a href="#4-2-字符串" class="headerlink" title="4.2 字符串"></a>4.2 字符串</h3><p>C-风格字符串具有一种特殊的性质：以空字符（null character）结尾，空字符写作<code>&#39;\0&#39;</code>,其ASCII码为0，用来标记字符串的结尾。使用一对引号括起来的字符串被称为<strong>字符串常量</strong>（string constant）或字符串字面值（string literal），它隐式地包括了结尾的空字符。</p>
<p>字符串常量（使用双引号）不能与字符常量（使用单引号）互换。字符常量是字符串编码的简写表示，字符串常量实际上表示的是字符串所在的内存地址。</p>
<p>istream中的类（如 <code>cin</code> ）提供了一些面向行的类成员函数：<code>getline()</code>和<code>get()</code>，这两个函数都读取一行输入，直到到换行符，随后<code>getline()</code>将丢弃换行符，而get()将换行符保留在输入序列中。</p>
<ul>
<li><p>getline()</p>
<p>getline()函数每次读取一行，它通过换行符确定行尾，但不保存换行符，在存储字符串时，它使用空字符来替换换行符。<code>cin.getline()</code>函数有两个参数，第一个参数是用来存储输入行的数组的名称。第二个参数是要读取的字符数，如果这个参数为n，则函数最多读取n-1个字符，余下的空间用于存储自动在结尾处添加的空字符。</p>
</li>
<li><p>get()</p>
<p>istream类还有另一个get()成员函数，该函数有几个重载版本，其中一种版本的工作方式与<code>getline()</code>类似，它们接受的参数相同，解释参数的方式也相同，并且都读取到行尾。但<strong>get()并不再读取并丢弃换行符，而是将其留在输入队列中</strong>。不带参数的<code>cin.get()</code>调用可读取下一个字符（包括换行符），因此可以用它来处理换行符，为读取下一行输入做准备。<code>cin.get(n, ArSize).get()</code>。</p>
<p>假设使用<code>get()</code>将一行输入读入数组，如何直到停止读取的原因是由于已经读取了整行，而不是由于数组已填满呢？查看下一个字符，如果是换行符，说明已经读取了整行；否则说明该行中还有其他输入。</p>
</li>
<li><p>空行和其他问题</p>
<p>当<code>getline()</code>或<code>get()</code>读取空行时，将发生什么情况？最初的做法是，下一条输入语句将在前一条<code>getline()</code>或get()结束读取的位置开始读取；当前的做法是，当get()读取空行后将设置失效位（ <code>failbit</code> ），这意味着接下来的输入将被阻断，但可以使用<code>cin.clear()</code>来恢复输入。</p>
</li>
</ul>
<h3 id="4-3-string类简介"><a href="#4-3-string类简介" class="headerlink" title="4.3 string类简介"></a>4.3 string类简介</h3><p>string类提供了将字符串作为一种数据类型的表示方法，它的定义隐藏了字符串的数组性质，可以想处理普通变量那样处理字符串，要使用string类，必须在程序中包含头文件string。</p>
<p>在很多方面使用string对象与使用字符数组相同：</p>
<ul>
<li>可以使用C-风格字符串来初始化string对象；</li>
<li>可以使用<code>cin</code>来将键盘输入存储到string对象中；</li>
<li>可以使用<code>cout</code>来显式string对象；</li>
<li>可以使用数组表示法来访问存储在string对象中的字符；</li>
<li>可以使用列表初始化语法初始化string对象。</li>
</ul>
<p>在原始字符串中，字符表示的就是自己，原始字符串将”(和)”用作定界符，并使用前缀R来标识原始字符串。</p>
<h3 id="4-4-共用体"><a href="#4-4-共用体" class="headerlink" title="4.4 共用体"></a>4.4 共用体</h3><p>共用体是一种数据格式，它能够存储不同的数据类型，但只能同时存储其中的一种类型。共用体的长度位其最大成员的长度。</p>
<h3 id="4-5-枚举"><a href="#4-5-枚举" class="headerlink" title="4.5 枚举"></a>4.5 枚举</h3><p>默认情况下，将整数值赋给枚举量，第一个枚举量的值位0，第二个枚举量的值为1，依次类推。</p>
<p>每个枚举都有取值范围，通过强制类型转换，可以将取值范围中的任何整数值赋给枚举变量，即使这个变量不是枚举值。</p>
<h3 id="4-6-指针和自由存储空间"><a href="#4-6-指针和自由存储空间" class="headerlink" title="4.6 指针和自由存储空间"></a>4.6 指针和自由存储空间</h3><p>指针是一个变量，其存储的是值的地址，而不是值本身。对于常规变量，只需使用地址运算符&amp;就可以获得其地址。*运算符被称为间接值（indirect value）或接触引用（dereferencing）运算符，将其应用于指针，可以得到该地址处存储的值。</p>
<p>在C++中创建指针时，计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向数据的内存。</p>
<p>为一个数据对象获得并指定分配内存的通用格式如下：<code>typeName * pointer_name = new typeName;</code></p>
<p>当需要内存是，可以使用new来请求，delete运算符是的在使用完内存后，能够将其归还给内存池。一定要配对地使用new和delete，否则将发生内存泄漏。不能使用delete来释放声明变量所获得的内存。</p>
<p>只能使用delete来释放使用new分配的内存，然而，对空指针使用delete时安全的。</p>
<p>为数组分配内存的通用格式：<code>type_name * pointer_name = new type_name [num_element]</code>,可以以使用数组名的方法来使用<code>pointer_name</code>.</p>
<p>使用new和delete时，应遵守如下规则：</p>
<ol>
<li>不要使用delete来释放不是new分配的内存。</li>
<li>不要使用delete释放同一个内存块两次。</li>
<li>如果使用new [] 为数组分配内存，则应使用delete []来释放。</li>
<li>如果使用new[] 为一个实体分配内存，则应使用delete来释放。</li>
<li>对空指针使用delete是合法的。</li>
</ol>
<p>将指针变量加1后，其增加的值等于指向的类型占用的字节数。</p>
<p>在很多情况下，可以以相同的方式使用指针名和数组名，在多数表达式中，它们都表示地址。区别之一时，可以修改指针的值，而数组名是 常量。另一个区别是，对数组应用sizeof运算符得到的是数组的长度，而对指针运用sizeof运算符得到的是指针的长度，即使指针指向的是一个数组。这种情况下，C++不会数组名解释为地址。</p>
<p>使用数组声明来创建数组时，将采用静态联编，即数组的长度在编译时设置；使用new[]运算符创建数组时，将采用动态联编，即将在运行时为数组分配空间，其长度也将在运行时设置。</p>
<h4 id="自动存储、静态存储和动态存储"><a href="#自动存储、静态存储和动态存储" class="headerlink" title="自动存储、静态存储和动态存储"></a>自动存储、静态存储和动态存储</h4><ul>
<li><p>自动存储</p>
<p>在函数内部定义的常规变量使用自动存储空间，被称为自动变量。它们在所属的函数被调用时自动产生，在该函数结束时自动消亡。（自动变脸是一个局部变量，其作用域为包含它的代码块）</p>
<p>自动变量通常存储在栈中。这意味着执行代码块时，其中的变量将依次加入到栈中，而在离开代码块时，将按相反的顺序释放这些变量（后进显先出，LIFO）。</p>
</li>
<li><p>静态存储</p>
<p>静态存储是整个程序执行期间都存在的存储方式，使变量称为静态的方式有两种：一种是在函数外面定义它；另一种是在声明变量时使用关键字static。</p>
</li>
<li><p>动态存储</p>
<p>new和delete运算符提供了一种比自动变量和静态变量更加灵活的方法。它们管理了一个内存池，这在C++中被称为<strong>自由存储空间</strong>（free store）或<strong>堆</strong>（heap），该内存池同用于静态变量和自动变量的内存是分开的。</p>
</li>
</ul>
<h3 id="4-7-数组的替代品"><a href="#4-7-数组的替代品" class="headerlink" title="4.7 数组的替代品"></a>4.7 数组的替代品</h3><h4 id="4-7-1-模板类vector"><a href="#4-7-1-模板类vector" class="headerlink" title="4.7.1 模板类vector"></a>4.7.1 模板类vector</h4><p>模板类vector类似于string类，也是一种动态数组，它使用new和delete管理内存，但这种工作是自动完成的。要使用vector对象，必须包含头文件vector，其次，vector包含在名称空间std中，因此需使用using编译指令、using声明或<code>std::vector</code>。<code>vector&lt;typeName&gt; vt(n_element)</code>创建一个名为vt的vector对象，它可存储n_element个类型为typeName的元素，其中参数n_element可以是整型常量，也可以是整型变量。</p>
<h4 id="4-7-2-模板类array"><a href="#4-7-2-模板类array" class="headerlink" title="4.7.2 模板类array"></a>4.7.2 模板类array</h4><p>array位于名称空间std,要创建array对象，需要包含头文件array，创建语法如下：<code>array&lt;typeName, n_elem&gt; arr;</code>该声明创建一个名为arr的array对象，它包含n_elem个类型为typeName的元素。</p>
<p><strong>array对象和数组存储在相同的内存区域（栈）中，而vector对象存储在另一个区域（自由存储区域或堆）中。</strong></p>
]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>C++ premier plus学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Chapter5 循环和关系表达式</title>
    <url>/2021/03/26/Chapter5_%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%85%B3%E7%B3%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="Chapter5-循环和关系表达式"><a href="#Chapter5-循环和关系表达式" class="headerlink" title="Chapter5 循环和关系表达式"></a>Chapter5 循环和关系表达式</h2><h3 id="5-1-for循环"><a href="#5-1-for循环" class="headerlink" title="5.1 for循环"></a>5.1 for循环</h3><p>C++在for和括号之间加上一个空格，而省略函数名和括号之间的空格，这样从视觉上强化了控制语句和函数调用之间的区别。</p>
<p>递增运算符（++）和递减运算符（–）对操作数的影响是一样的，但是影响的时间不同。粗略的讲，a++意味着使用a的当前值计算表达式，然后将a的值加1；而++a的意思是先将a的值加1，然后使用新的值来计算表达式。（<em>对于用户定义的类型而言，前缀版本比后缀版本效率高。</em>因为后缀版本会首先复制一个副本，将其进行自增运算后再将复制的副本返回，而前缀版本直接返回加1后的结果）</p>
<p>副作用（side effect）指的是在计算表达式时对某些东西（如存储在变量中的值）进行了修改；顺序点（sequence point）是程序执行过程中的一个点，在这里，进入下一步之前将确保对所有的副作用都进行了评估。（<em>C++中的分号就是一个顺序点，任何完整的表达式末尾都是一个顺序点</em>）</p>
<p>前缀递增、前缀递减和接触运算符的优先级相同，以从右到左的方式进行结合。后缀递增和后缀递减的优先级相同，但比前缀运算符的优先级高，这两个运算符以从左到右的方式进行结合。</p>
<p>逗号运算符去额宝先计算第一个表达式，然后计算第二个表达式（逗号运算符是一个顺序点），它的值是第二部分的值，再所有表达式中都好运算符的优先级是最低的。</p>
<p>数组名是数组的地址，用引号括起来的字符串常量也是其地址。</p>
<p>C-风格字符串应使用strcmp()函数来比较。该函数接受两个字符串地址作为参数。如果两个字符串相同，该函数返回零；如果第一个字符串按字母顺序排在第二个字符串之前，则strcmp()将返回一个负数值；如果第一个字符串按字母顺序排在第二个字符串之后，则strcmp()将返回一个正数值。</p>
<h3 id="5-2-while循环"><a href="#5-2-while循环" class="headerlink" title="5.2 while循环"></a>5.2 while循环</h3><p>while循环时没有初始化和更新部分的for循环，它只有测试条件和循环体：<code>while(test-condition)&#123;body&#125;</code>.</p>
<p>在C++中，for和while循环本质上是相同的。例如，下面的for循环：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (init-expression; test-expression; update-expression)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">statement</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以改写成这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">init-expression;</span><br><span class="line"><span class="keyword">while</span> (test-expression)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">statements</span>(s);</span><br><span class="line">    update-expression;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，下面的while循环：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (test-expression)</span><br><span class="line">	body</span><br></pre></td></tr></table></figure>

<p>可以改成这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;test-expression;)</span><br><span class="line">    body</span><br></pre></td></tr></table></figure>

<p>C++为类型建立别名有两种方式。一种是使用预处理器，如<code>#define BYTE char</code>,另一种是使用typedef来创建别名<code>typedef char byte;</code>,通用格式为<code>typedef typeName aliasName;</code>.</p>
<h3 id="5-3-do-while-循环"><a href="#5-3-do-while-循环" class="headerlink" title="5.3 do while 循环"></a>5.3 do while 循环</h3><p>do while循环是出口条件（exit condition）循环。这种循环将首先执行循环体，然后再判定测试表达式，决定是否应该继续执行循环，<strong>如果条件为false，则循环终止</strong>；否则进入新一轮循环。</p>
<img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20201012160028.png" alt="image-20201012160021241" style="zoom:80%;" />

<h3 id="5-4-基于范围的for循环"><a href="#5-4-基于范围的for循环" class="headerlink" title="5.4 基于范围的for循环"></a>5.4 基于范围的for循环</h3><p>C++新增了一种循环：基于范围（range-based）的for循环（与Java中的for-each循环类似），这简化了一种常见的循环任务：对数组（或容器类）的每个元素执行相同的操作。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> prices[<span class="number">5</span>] = &#123;<span class="number">4.99</span>, <span class="number">10.99</span>, <span class="number">6.87</span>, <span class="number">7.99</span>, <span class="number">8.49</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">double</span> x: prices)</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//如需修改数组的元素，使用引用即可</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">double</span> &amp;x: prices)</span><br><span class="line">    x *= <span class="number">0.80</span>;</span><br></pre></td></tr></table></figure>

<h3 id="5-5-循环和文本输入"><a href="#5-5-循环和文本输入" class="headerlink" title="5.5 循环和文本输入"></a>5.5 循环和文本输入</h3><p>函数重载允许创建多个同名函数，条件是它们的参数列表不同。</p>
<p>很多PC编程环境都将Ctrl+Z视为模拟的EOF。如果检测到EOF，cin将两位（eobit和failbit）都设置为1，则cin.eof()将返回bool值true，否则返回false。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>for循环和while循环时入口条件循环，这意味着程序将在执行循环体中的语句之前检查测试条件。do while循环是出口条件循环，这意味着其将在执行循环体中的语句之后检查条件。</p>
<p>如果ch是一个char变量，<code>cin &gt;&gt; ch;</code>将输入的下一个字符读入到ch中，然而，它将忽略空格、换行符和制表符。</p>
<p><code>cin.get(ch)</code>读取输入中的下一个字符（而不管字符是什么）并将其存储到ch中。</p>
<p>成员函数调用<code>cin.get()</code>返回下一个输入的字符（包括空格、换行符和制表符），因此可以这样使用它<code>ch  = cin.get()</code>.</p>
<p><code>cin.get(char )</code>成员函数调用通过返回转换为false的bool值来指出已到达EOF，而<code>cin.get()</code>成员函数调用则通过返回EOF值来指出已到达EOF。</p>
]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>C++ premier plus学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Chapter6 分支语句和逻辑运算符</title>
    <url>/2021/03/26/Chapter6_%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E5%92%8C%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="Chapter6-分支语句和逻辑运算符"><a href="#Chapter6-分支语句和逻辑运算符" class="headerlink" title="Chapter6 分支语句和逻辑运算符"></a>Chapter6 分支语句和逻辑运算符</h2><p>C++规定，||是一个顺序点（sequence point),也就是说，先修改左侧的值再对右侧的值进行判定（运算符左边的子表达式先于右边的子表达式）。</p>
<p>逻辑AND运算符的优先级高于逻辑OR运算符。</p>
<p>标识符and、or和not都是C++的保留字，这意味着不能将它们用作变量名。它们不是关键子，因为它们都是已有语言特性的另一种表示方法。（在c语言中包含头文件iso646.h,可以使用，c++无需包含该头文件）<br><img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20201014152716.png" alt="image-20201014152709322"></p>
<p>C++从C语言继承了一个与字符相关的、非常方便的函数软件包，它可以简化诸如确定字符是否为大写字母、数字、标点符号等工作，这些函数的原型是在头文件cctype（ctype.h)中定义的。<br><img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20201014152944.png" alt="image-20201014152944233"></p>
<p>条件运算符（?:）通用格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">expression1 ? expression2 : expression3;</span><br><span class="line"><span class="comment">//expression1为true，则表达式的值为expression2的值；否则为expression3的值。</span></span><br></pre></td></tr></table></figure>

<p>switch语句通用格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (integer-expression) <span class="comment">//integer-expression必须是一个结果为整数值的表达式</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">case</span> label1: <span class="built_in">statement</span>(s) <span class="comment">//每个标签都必须是整数常量表达式</span></span><br><span class="line">	<span class="keyword">case</span> label2: <span class="built_in">statements</span>(s)</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">default</span>: <span class="built_in">statements</span>(s)</span><br><span class="line">    <span class="comment">//case标签只是行标签，而不是选项之间的界限，也就是说，程序跳到switch中特定代码行后，将依次执行之后的所有语句，除非有明确的其他指示。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch语句将int值与枚举量标签进行比较时，将枚举量提升为int；在while循环测试条件中，也会将枚举量提升为int类型。</p>
<p>用cin读取用户输入数字时，如果类型不匹配，将发生4种情况：<br>(1) 存储输入的变量保持不变；<br>(2) 不匹配的输入将被留在输入队列中；<br>(3) cin对象中的一个错误标记被设置；<br>(4) 对cin方法的调用将返回false（如果被转换为bool类型）。<br>方法返回false意味着可以用非数字输入来结束读取数字的循环。非数字输入设置错误标记意味着必须重置该标记，程序才能继续读取输入。clear()方法重置错误输入标记，同时也重置文件尾（EOF）。</p>
<p>使用cin进行输入的时候，程序将输入视为一系列的字节，其中每个字节都被解释为字符编码。</p>
<p>打开已有文件接受输入时，默认将它的长度截断为零，因此原来的的内容将会丢失。</p>
<p>函数exit()的原型是在cstdlib中定义的，在该头文件中，还定义了一个用于同操作系统通信的参数值EXIT_FAILURE.函数exit()终止程序。</p>
]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>C++ premier plus学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Chapter7 函数--C++的编程模块</title>
    <url>/2021/03/26/Chapter7_%E5%87%BD%E6%95%B0--C++%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="Chapter7-函数–C-的编程模块"><a href="#Chapter7-函数–C-的编程模块" class="headerlink" title="Chapter7 函数–C++的编程模块"></a>Chapter7 函数–C++的编程模块</h2><h3 id="7-1-复习函数基本知识"><a href="#7-1-复习函数基本知识" class="headerlink" title="7.1 复习函数基本知识"></a>7.1 复习函数基本知识</h3><h4 id="7-1-1-定义函数"><a href="#7-1-1-定义函数" class="headerlink" title="7.1.1 定义函数"></a>7.1.1 定义函数</h4><p>可以将函数分为两类：没有返回值的函数和有返回值的函数。没有返回值的函数称为void函数，其通用格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionName</span><span class="params">(parameterList)</span></span>&#123;</span><br><span class="line">    <span class="built_in">statement</span>(s);</span><br><span class="line">    <span class="keyword">return</span> ;<span class="comment">//optional</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可选的返回语句标记了函数的结尾；否则，函数将在右花括号处结束。void函数相当与Pascal中的过程、FORTRAN中的子程序和现代BASIC中的子程序过程。</p>
<p>对于有返回值的函数，必须使用返回语句，C++对与有返回值的类型有一定的限制：不能是数组，但可以是其他任何类型（<em>虽然C++函数不能直接返回数组，但可以将数组作为结构或对象组成部分来返回</em>）。</p>
<p>通常，函数通过将返回值复制到指定的CPU寄存器或内存单元中来将其返回。随后，调用程序将查看该内存单元。返回函数和调用函数必须就该内存单元中存储的数据的类型达成一致。</p>
<h4 id="7-1-2-函数原型和函数调用"><a href="#7-1-2-函数原型和函数调用" class="headerlink" title="7.1.2 函数原型和函数调用"></a>7.1.2 函数原型和函数调用</h4><p>1.为什么需要原型<br>    原型描述了函数到编译器的接口，也就是说，它将函数返回值的类型（如果有）以及参数的类型和数量告诉编译器。<br>2.原型的语法<br>    函数原型是一条语句，因此必须以分号结束。获得原型最简单的方法是，复制函数定义中的函数头，并添加分号。（函数原型不要求提供变量名，有类型列表就足够了）。<br>3.原型的功能<br>    原型可以极大地降低程序出错的机率，它们确保以下几点：<br>        （1）编译器正确处理函数返回值；<br>        （2）编译器检查使用的参数数目是否正确；<br>        （3）编译器检查使用的参数类型是否正确；</p>
<p>ANSI C中原型是可选的，而在C++中，原型是必不可少的。在C++中，括号为空与在括号中使用关键字void是等效的–意味着函数没有参数。在ANSI C中，括号为空意味着不指出参数–这意味着将在后面定义参数列表。而在C++中，不指定参数列表时应使用省略号。</p>
<h3 id="7-2-函数参数和按值传递"><a href="#7-2-函数参数和按值传递" class="headerlink" title="7.2 函数参数和按值传递"></a>7.2 函数参数和按值传递</h3><p>C++标准使用参数（argument）来表示实参，使用参量（parameter）来表示形参，因此参数传递将参量赋给参数。</p>
<p>形参与其他局部变量的主要区别是，形参从调用函数哪里获得自己的值，而其他变量是从函数中获得自己的值。</p>
<h3 id="7-3-函数和数组"><a href="#7-3-函数和数组" class="headerlink" title="7.3  函数和数组"></a>7.3  函数和数组</h3><p>在C++中，当（且仅当）用于函数头或函数原型中，int * arr和int arr[]的含义才是相同的。它们都意味着arr是一个int指针。然而数组表示法（int arr[]）提醒用户，arr不仅指向int，还指向int数组的第一个int。</p>
<p>传递常规变量时，函数将使用该变量的拷贝；但传递数组时，函数将使用原来的数组。</p>
<p><strong>必须显式传递数组的长度，因为指针并未指出数组的长度</strong></p>
<p>可以用两种不同的方式将const关键字用于指针。<strong>第一种是让指针指向一个常量对象，这样可以防止使用该指针来修改所指向的值，第二种方法是将指针本身声明为常量，这样可以防止改变指针指向的位置</strong>。</p>
<p>如果数据类型本身不是指针，则可以将const数据或非const数据的地址赋给指向const的指针，但只能将非const数据的地址赋给非const指针。</p>
<h3 id="7-4-函数指针"><a href="#7-4-函数指针" class="headerlink" title="7.4 函数指针"></a>7.4 函数指针</h3><p>函数的地址是存储器机器语言代码的内存的开始地址。</p>
<ul>
<li><p>获取函数的地址</p>
<p>获取函数的地址很简单：只要使用函数名（后面不跟参数）即可。也就是说，如果think()是一个函数，那么think就是该函数的地址。要将函数作为参数进行传递，必须传递函数名。</p>
</li>
<li><p>声明函数指针</p>
<p>声明指向某种数据类型的指针时，必须指定指针指向的类型。同样，声明指向函数的指针时，也必须指定指针指向的函数类型，这意味着声明应指定函数的返回类型以及函数的<strong>特征标</strong>（参数列表）<u>通常，要声明指向特定类型的函数的指针，可以首先编写这种函数的原型，然后用(*pf)替换函数名，这样pf就是这类函数的指针。</u></p>
</li>
</ul>
<p>函数定义是实现函数功能的代码；函数原型提供了函数的接口：传递给函数的值的数目和种类以及函数的返回类型。函数调用使得程序将参数传递给函数，并执行函数的代码。</p>
]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>C++ premier plus学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Chapter8 函数探幽</title>
    <url>/2021/03/26/Chapter8_%E5%87%BD%E6%95%B0%E6%8E%A2%E5%B9%BD/</url>
    <content><![CDATA[<h2 id="Chapter8-函数探幽"><a href="#Chapter8-函数探幽" class="headerlink" title="Chapter8 函数探幽"></a>Chapter8 函数探幽</h2><h3 id="8-1-内联函数"><a href="#8-1-内联函数" class="headerlink" title="8.1 内联函数"></a>8.1 内联函数</h3><p>内联函数是C++为了提高程序运行速度所做的一项改进。<strong>常规函数和内联函数的主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中</strong>。</p>
<p>执行常规函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈，跳到标记函数起点的内存单元，执行函数代码，然后跳回到地址被保存的指令处（<em>这与阅读文章时停下来看脚注，并在阅读完教主后返回到以前阅读的地方类似</em>）。来回跳跃并记录跳跃位置意味着使用函数时需要一定的开销。而内联函数的编译代码与其他程序代码“内联“起来了。这也就是说，编译器将使用相应的函数代码替换函数调用。<strong>对于内联代码，程序无需跳到另一个位置处执行代码，再跳回来。因此，内联函数的运行速度比常规函数稍快，但代价是需要占用更多的内存</strong>。<br><img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20201018162900.png" alt="内联函数和常规函数"></p>
<p>要使用内联函数，必须采取下述措施之一：<br>（1）在函数声明前加上关键字inline；<br>（2）在函数顶以前加上关键字inline。<br>通常的做法是省略原型，将整个定义放在本应该提供原型的地方。（<em><strong>内联函数不能递归</strong></em>，与常规函数一样，也是按值来传递参数的）</p>
<p><strong>宏是通过文本替换来实现的，并非传递参数</strong>。</p>
<h3 id="8-2-引用变量"><a href="#8-2-引用变量" class="headerlink" title="8.2 引用变量"></a>8.2 引用变量</h3><p>引用是已定义的变量的别名。通过将引用变量用作参数，函数将使用原始数据，而不是其副本。这样除指针之外，引用也为函数处理大型结构提供了一种非常方便的途径。</p>
<h4 id="8-2-1-创建引用变量"><a href="#8-2-1-创建引用变量" class="headerlink" title="8.2.1 创建引用变量"></a>8.2.1 创建引用变量</h4><p>C和C++使用&amp;符号来指示变量的地址，而C++给&amp;符号赋予了另一个含义，将其用来声明引用。例如，要将rodents作为rats 变量的别名，可以这样做：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> rats;</span><br><span class="line"><span class="keyword">int</span> &amp; rodents = rats; <span class="comment">//makes rodents an alias for rats</span></span><br></pre></td></tr></table></figure>

<p>其中，&amp;不是地址运算符，而是类型标识符的一部分。就像生命中的char * 指的是指向char的指针一样，int &amp;指的是指向int的引用。上述声明允许将rats和rodents互换——它们指向相同的值和内存单元。</p>
<p><strong>必须在声明引用的时候进行初始化</strong>，引用更接近const 指针，必须在创建时进行初始化，一旦与某个变量关联起来，就将一直效忠于他。也就是说：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp; rodents = rats;</span><br></pre></td></tr></table></figure>

<p>实际上是下述代码的伪装表示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> pr = &amp;rats;</span><br></pre></td></tr></table></figure>

<p>其中引用rodents扮演的角色与表达式*pr相同。</p>
<h4 id="8-2-2-将引用作为函数参数"><a href="#8-2-2-将引用作为函数参数" class="headerlink" title="8.2.2 将引用作为函数参数"></a>8.2.2 将引用作为函数参数</h4><p>引用经常被用作函数参数，使得函数中的变量名称为调用程序中的变量的别名。这种传递参数的方法称为按引用传递。</p>
<p>如果函数调用的参数不是左值或与相应的const引用参数的类型不匹配，则C++将创建类型正确的匿名变量，将函数调用的参数的值传递给该匿名变量，并让参数来引用该变量。</p>
<p>假设实参的类型与引用参数类型不匹配，但可被转换为引用类型，程序将创建一个正确类型的临时变量，使用转换后的实参值来初始化它，然后传递一个指向该临时变量的引用。</p>
<p>引用参数应尽可能使用const引用：</p>
<ul>
<li>使用const可以避免无意中修改数据的编程错误；</li>
<li>使用const使函数能够处理const和非const实参，否则将只能接受非const数据；</li>
<li>使用const引用使函数能够正确生成并使用临时变量。</li>
</ul>
<p>返回引用的函数返回的实际上是被引用的变量的别名。返回引用时应避免返回函数终止时不再存在的内存单元引用。</p>
<p><strong>基类引用可以指向派生类对象，而无需进行强制类型转换</strong>。</p>
<h4 id="8-2-3-何时使用引用参数"><a href="#8-2-3-何时使用引用参数" class="headerlink" title="8.2.3 何时使用引用参数"></a>8.2.3 何时使用引用参数</h4><p>使用引用参数的主要原因有两个：</p>
<ul>
<li>程序员能够修改调用函数中的数据对象。</li>
<li>通过传递引用而不是整个数据对象，可以提高程序的运行速度。</li>
</ul>
<p>引用、指针、值传递使用场景：</p>
<ul>
<li>对于使用传递的值而不做修改的函数<ul>
<li>如果数据对象很小，则按值传递</li>
<li>如果数据对象是数组，则使用指针</li>
<li>如果数据对象是较大的结构，则使用const指针或const引用给，以提高程序的效率</li>
<li>如果数据对象是类对象，则使用const引用</li>
</ul>
</li>
<li>对于修改调用函数中数据的函数：<ul>
<li>如果数据对象是内置数据类型，则使用指针</li>
<li>如果数据对象是数组，则只能使用指针</li>
<li>如果数据对象是结构，则使用引用或指针</li>
<li>如果数据对象是类对象，则使用引用。</li>
</ul>
</li>
</ul>
<h3 id="8-3-默认参数"><a href="#8-3-默认参数" class="headerlink" title="8.3 默认参数"></a>8.3 默认参数</h3><p>默认参数是指当函数调用中省略了实参时自动使用的一个值。由于编译器通过查看原型来了解函数所使用的参数数目，因此函数原型也必须将可能的默认参数告知程序。方法是将值赋给原型中的参数（<u>只有原型需指定默认值，函数定义与没有默认参数时完全相同</u>）。</p>
<p><strong>对于带参数列表的函数，必须从右向左添加默认值。也就是说，要为某个参数设置默认值，则必须为它右边的所有参数提供默认值</strong>。实参按从左到右的顺序依次被赋给相应的形参，而不能跳过任何参数。</p>
<h3 id="8-4-函数重载"><a href="#8-4-函数重载" class="headerlink" title="8.4 函数重载"></a>8.4 函数重载</h3><p>函数多态（函数重载）使得能能够使用多个同名的函数。术语”多态”指的是有多种形式，因此函数多态可以有多种形式。类似地，<strong>术语“函数重载”指的是可以有多个同名的函数</strong>，因此对名称进行了重载。这两个术语指的是同一回事，但我们通常使用函数重载。可以通过函数重载来设计一系列函数——<strong>它们完成相同的工作，但使用不同的参数列表</strong>。</p>
<p><strong>C++使用上下文来确定要使用的重载函数版本</strong>。</p>
<p>函数重载的关键是函数的参数列表——也称为函数特征标识（function signature)。<strong>如果两个函数的参数数目和类型相同，同时参数的排列顺序也相同，则它们的特征标相同</strong>，而变量名是无关紧要的。***<u>编译器在检查函数特征标时，将把类型引用和类型本身视为同一个特征标</u>***</p>
<p>将非const值赋给const变量时合法的，但反之则是非法的。</p>
<p>仅当函数基本上执行相同的任务，但是用不同形式的数据时，才应采用函数重载。</p>
<p>使用C++开发工具中的编译器编写和编译程序时，C++编译器将执行<strong>名称修饰</strong>（name decoration）或<strong>名称矫正</strong>（name mangling），它<strong>根据函数原型中指定的形参类型对每个函数名进行加密</strong>。</p>
<h3 id="8-5-函数模板"><a href="#8-5-函数模板" class="headerlink" title="8.5 函数模板"></a>8.5 函数模板</h3><p>函数模板时通用的函数描述，也就是说，它们使用泛型来定义函数，其中的泛型可用具体的类型替换。通过将类型作为参数传递给模板，可使编译器生成该类型的函数。由于模板允许以泛型的方式编写程序，因此有时也被称为通用编程。由于类型是用参数表示的，因此模板特性有时也被称为参数化类型（parameterized types）。</p>
<p>函数模板允许以任意类型的方式来定义函数，例如，如下示建立一个交换模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AnyType&gt;	<span class="comment">//建立一个模板，并把类型命名为AnyType，关键字template和typename是必须的，可用class代替typename</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(AnyType &amp;a, AnyType &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AnyType temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b; </span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>模板不创建任何函数，而只是告诉编译器如何定义函数</strong>。</p>
<p>可以提供一个具体化函数定义——称为<strong>显式具体化</strong>（explicit specialization），其中包含所需的代码。当编译器找到与函数调用相匹配的具体化定义时，将使用该定义，而不再寻找模板。如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">40</span>];</span><br><span class="line">    <span class="keyword">double</span> salary;</span><br><span class="line">    <span class="keyword">int</span> floor</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">void</span> Swap&lt;job&gt;(job &amp;, job &amp;) <span class="comment">//显式具体化</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对于给定的函数名，可以有非模板函数、模板函数和显式具体化模板函数以及它们的重载版本</li>
<li>显式具体化函数的原型和定义应以template&lt;&gt;打头，并通过名称来指出类型</li>
<li><strong>具体化优先于常规模板，而非模板函数优先于具体化和常规模板</strong></li>
</ul>
<p>在代码中包含函数模块本身并不会生成函数定义，它指示一个用于生成函数定义的方案。编译器使用模板为特定类型生成函数定义时，得到的时模板实例（instantiation）。模板并非函数定义，但某一类型的模板实例时函数定义，这种实例化方式被称为<strong>隐式实例化</strong>。</p>
<p>最初，编译器只能通过隐式实例化，来使用模板生成函数定义，但现在C++还允许<strong>显式实例化</strong>（explicit instantiation），这意味着可以直接命令编译器创建特定的实例。其语法是，声明所需的种类——用&lt;&gt;符号指示类型，并在声明前加上关键字template：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="keyword">void</span> Swap&lt;<span class="keyword">int</span>&gt; (<span class="keyword">int</span>, <span class="keyword">int</span>); <span class="comment">//explicit instantiation</span></span><br></pre></td></tr></table></figure>

<p>试图在同一个文件（或转换单元）中使用同一种类型的显式实例和显式具体化将出错。</p>
<p>隐式实例化、显式实例化和显式具体化统称为具体化（specialization），它们的相通之处在于，<strong>它们表示的都是使用具体类型的函数定义，而不是通用描述</strong>。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T &amp;, T &amp;)</span></span>; <span class="comment">// 模板原型</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">void</span> Swap&lt;job&gt;(job &amp;, job&amp;); <span class="comment">//显式具体化, job声明同上</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">template</span> <span class="keyword">void</span> Swap&lt;<span class="keyword">char</span>&gt; (<span class="keyword">char</span> &amp;, <span class="keyword">char</span> &amp;); <span class="comment">//显式实例化</span></span><br><span class="line">    <span class="keyword">short</span> a,b;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">Swap</span>(a,b); <span class="comment">//short隐式实例化</span></span><br><span class="line">    job n,m;</span><br><span class="line">    ...</span><br><span class="line">	<span class="built_in">Swap</span>(n,m); <span class="comment">//job结构显式具体化</span></span><br><span class="line">	<span class="keyword">char</span> g, h;</span><br><span class="line">    ...</span><br><span class="line">	<span class="built_in">Swap</span>(g, h); <span class="comment">//char型显式实例化</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于函数重载、函数模板和函数模板重载，C++需要（且有）一个定义良好的策略，来决定为函数调用使用哪一个函数定义，尤其是有多个参数时，这个过程称为重载解析（overloading resolution），大致过程如下：</p>
<ol>
<li><strong>创建候选函数列表</strong>。其中包含与被调用函数的名称相同的函数和模板函数。</li>
<li><strong>使用候选函数列表创建可行函数列表</strong>。这些都是参数数目正确的函数，为此有一个隐式转换序列，其中包括实参类型与相应的形参类型完全匹配的情况。</li>
<li><strong>确定是否有最佳的可行函数</strong>。如果有，则使用它，否则该函数调用出错。<ol>
<li>通常从最佳到最差的顺序如下所述：<ol>
<li>完全匹配<a href="#bib1" id="bib1ref"><sup>[1]</sup></a>，但常规函数优先于模板<a href="#bib2" id="bib2ref"><sup>[2]</sup></a><br><img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20201018192526.png" alt="image-20201018192526290"></li>
<li>提升转换（如，char和short自动转换为int，float自动转换为double）</li>
<li>标准转换（如int转换为char，long转换为double）</li>
<li>用户定义的转换，如类声明中定义的转换。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>如果有多个匹配的原型，则百年一起将无法完成重载解析过程；如果没有最佳的可行函数，编译器将生成一条错误信息。</p>
<p>重载解析将寻找最匹配的函数。如果只存在一个这样的函数，则选择它；如果存在多个这样的函数，但其中只有一个时非模板函数，则选择该函数；如果存在多个适合的函数，且它们都为模板函数，但其中有一个函数比其他函数更具体<a href="#bib3" id="bib3ref"><sup>[3]</sup></a>，则选择该函数。如果有多个同样合适的非模板函数或模板函数，但没有一个函数比其他函数更具体，则函数调用将是不确定的，因此是错误的；当然如果不存在匹配的函数，也是错误的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(x) y; <span class="comment">// make y the same type as x</span></span><br></pre></td></tr></table></figure>

<p>对于无法预先得知模板返回值，可通过使用关键字decltype和后置返回类型(trailing return type)来创建模板:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line">auto func(T1 x, T2 y) -&gt;decltype(x + y)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a id="bib1" href="#bib1ref"><sup>[1]</sup></a>进行完全匹配时，C++允许某些“无关紧要”的转换</p>
<p><a id="bib2" href="#bib2ref"><sup>[2]</sup></a>如果两个完全匹配的函数都是模板函数，则较具体<a href="#bib3" id="bib3ref"><sup>[3]</sup></a>的模板函数优先</p>
<p><a id="bib3" href="#bib3ref"><sup>[3]</sup></a>指编译器推断使用哪种类型时执行的转换最少</p>
]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>C++ premier plus学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Chapter9 内存模型和名称空间</title>
    <url>/2021/03/26/Chapter9_%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<h2 id="Chapter9-内存模型和名称空间"><a href="#Chapter9-内存模型和名称空间" class="headerlink" title="Chapter9 内存模型和名称空间"></a>Chapter9 内存模型和名称空间</h2><h3 id="9-1-单独编译"><a href="#9-1-单独编译" class="headerlink" title="9.1 单独编译"></a>9.1 单独编译</h3><p>不应将函数定义或变量声明放到头文件中，这样做可能会引发麻烦。例如，如果在头文件中包含一个函数定义，然后再其他两个文件（属于同一个程序）中包含该头文件，则同一个程序中将包含同一个函数的两个定义，除非函数是内联的，否则这将出错。</p>
<p>使用#include包含头文件时，如果文件名包含在尖括号中，则C++编译器将在存储标准头文件的主机系统的文件系统中查找；但如果文件名包含在双引号中，则编译器将首先查找当前的工作目录或源代码目录。</p>
<p>在同一个文件中只能将同一个头文件包含一次。可以利用基于预处理器编译指令#ifndef的技术避免多次包含同一个头文件。下面的代码片段意味着仅当以前没有使用预处理器编译指令#define定义名称COORDIN_H_时，才处理#ifndef和#endif之间的语句：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> COORDIN_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COORDIN_H_</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="9-2-存储持续性、作用域和链接性"><a href="#9-2-存储持续性、作用域和链接性" class="headerlink" title="9.2 存储持续性、作用域和链接性"></a>9.2 存储持续性、作用域和链接性</h3><p>C++使用三种（C++11中是四种）不同的方案来存储数据，这些方案的区别在于数据保留在内存中的时间：</p>
<ul>
<li><strong>自动存储持续性</strong>：在函数定义中声明的变量（包括函数参数）的存储持续性为自动的。它们<u>在程序开始执行其所属的函数或代码块时被创建，在执行完函数或代码块时，它们使用的内存被释放</u>。</li>
<li><strong>静态存储持续性</strong>：在函数定义外定义的变量和使用关键字static定义的变量的存储持续性都为静态。它们<u>在程序整个运行过程中都存在</u>。</li>
<li><strong>线程存储持续性</strong>（C++11）：如果变量是使用关键字thread_local声明的，则其<u>生命周期与所属的线程一样长</u>。</li>
<li><strong>动态存储持续性</strong>：用new运算符分配的内存将一直存在，直到使用delete运算符将其释放或程序结束为止，这种内存的存储持续性为动态，又是被称为自由存储（free store）或堆（heap）。</li>
</ul>
<h4 id="9-2-1-作用域和链接"><a href="#9-2-1-作用域和链接" class="headerlink" title="9.2.1 作用域和链接"></a>9.2.1 作用域和链接</h4><p><strong>作用域</strong>（scope）描述了名称在文件（翻译单元）的多大范围内可见。<strong>链接性</strong>（linkage）描述了名称如何在不同单元间共享。<u>链接性为外部的名称可在文件间共享，链接性为内部的名称只能有一个文件中的函数共享。自动变量的名称没有链接性，因为它们不能共享。</u></p>
<p>作用域为局部的变量只在定义它的代码块中可用。作用域为全局（也叫文件作用域）的变量在定义位置到文件结尾之间都可用。在函数原型作用域（function prototype scope）中使用的名称旨在包含参数列表的括号内可用。在类中声明的成员的作用域为整个类。在名称空间中声明的变量的作用域为整个名称空间。（<em>全局作用域是名称空间作用域的特例</em>）</p>
<h4 id="9-2-2-自动存储持续性"><a href="#9-2-2-自动存储持续性" class="headerlink" title="9.2.2 自动存储持续性"></a>9.2.2 自动存储持续性</h4><p>在默认情况下，在函数中声明的函数参数和变量的存储持续性为自动，作用域为局部，没有链接性。</p>
<p>在C++11中，关键字auto用于自动类型推断，而在C语言和以前的C++版本中，auto用于显式地指出变量为自动存储。</p>
<ul>
<li><p>自动变量的初始化</p>
<p>可以使用任何在声明时其值为已知的表达式来初始化自动变量。</p>
</li>
<li><p>自动变量和栈</p>
<p>由于自动变量的数目随函数的开始和结束而增减，因此程序必须在运行时对自动变量进行管理。常用的方法是路i出一段内存，并将其视为栈，以管理变量的增减。（新数据被象征性地放在原有数据的上面，即数据位于相邻的内存单元中，当程序使用完后，将其从栈中删除）。</p>
<img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20201019180025.png" alt="image-20201019180018372" style="zoom:80%;" /></li>
<li><p>寄存器变量<br>关键字register最初是由C语言引入的，它建议编译器使用CPU寄存器来存储自动变量以提高访问变量的速度。</p>
</li>
</ul>
<h4 id="9-2-3-静态持续变量"><a href="#9-2-3-静态持续变量" class="headerlink" title="9.2.3 静态持续变量"></a>9.2.3 静态持续变量</h4><p>C++为静态存储持续性变量提供了3种链接性：外部链接性（可在其他文件中访问）、内部链接性（只能在当前文件中访问）和无链接性（只能在当前函数或代码块中访问）。这三种链接性都在整个程序执行期间存在，即静态变量在整个程序执行期间一直存在。</p>
<p>要想创建链接性为外部的静态持续变量，必须在代码块的外面声明它；要创建链接性为内部的静态持续变量，必须在代码块的外面声明它，并使用static限定符；要创建没有链接性的静态持续变量，必须在代码块内声明它，并使用static限定符。</p>
<table>
<thead>
<tr>
<th>链接性</th>
<th>static限定符</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>外部</td>
<td>无</td>
<td>代码块外</td>
</tr>
<tr>
<td>内部</td>
<td>有</td>
<td>代码块外</td>
</tr>
<tr>
<td>无</td>
<td>有</td>
<td>代码块内</td>
</tr>
</tbody></table>
<p>所有静态持续变量都有下述初始化特征：未被初始化的静态变量的所有位都被设置为0.这种变量被称为零初始化的（zero-initializated）。</p>
<p>零初始化和常量表达式初始化统称为静态初始化，这意味着在编译器处理文件时初始化变量。</p>
<p><img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20201019181408.png" alt="image-20201019181408033"></p>
<h4 id="9-2-4-静态持续性、外部链接性"><a href="#9-2-4-静态持续性、外部链接性" class="headerlink" title="9.2.4 静态持续性、外部链接性"></a>9.2.4 静态持续性、外部链接性</h4><p>链接性位外部的变量通常简称为外部变量，它们的存储持续性为静态，作用域为整个文件。</p>
<ul>
<li><p>单定义规则</p>
<p>在每个使用外部变量的文件中，都必须声明它；另一方面，C++有“单定义规则”（One Definition Rule， ODR），该规则指出，变量只能有一次定义。为满足这种需求，C++提供了两种变量声明。一种是<strong>定义声明</strong>（defining declaration）或简称为<strong>定义</strong>（definition），<strong>它给变量分配存储空间</strong>；另一种是<strong>引用声明</strong>（referencing declaration）或简称为<strong>声明</strong>（declaration），<strong>它不给变量分配存储空间，因为它引用已有的变量</strong>。</p>
<p><strong>引用声明使用关键字extern，且不进行初始化</strong>。如果要在<strong>多个文件中使用外部变量</strong>，只需<strong>在一个文件中包含该变量的定义</strong>（单变量规则），但<strong>在使用该变量的其他所有文件种，都必须使用关键字extern声明它</strong>。如：</p>
<img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20201019183133.png" alt="image-20201019183133490" style="zoom:90%" />

<p>虽然程序中可能包含多个同名的变量，但每个变量都只有一个定义。</p>
<p><strong>C++提供了作用域解析运算符（::），将它放在变量名前面时，该运算符表示使用变量的全局版本</strong>。</p>
</li>
</ul>
<h4 id="9-2-5-静态持续性、内部链接性"><a href="#9-2-5-静态持续性、内部链接性" class="headerlink" title="9.2.5 静态持续性、内部链接性"></a>9.2.5 静态持续性、内部链接性</h4><p>将static限定符用于作用域为整个文件的变量时，该变量的链接性将为内部的。</p>
<p>如果文件定义了一个静态外部变量，其名称与另一个文件中的生命的常规外部变量先沟通，则在该文件中，静态变量将隐藏常规外部变量。<em>可使用外部变量在多文件程序的不同部分之间共享数据；可使用链接性为内部的静态变量在同一个文件中的多个函数之间共享数据</em>。</p>
<h4 id="9-2-6-静态存储持续性、无链接性"><a href="#9-2-6-静态存储持续性、无链接性" class="headerlink" title="9.2.6 静态存储持续性、无链接性"></a>9.2.6 静态存储持续性、无链接性</h4><p>在两次函数调用之间，静态局部变量的值将保持不变。如果初始化了静态局部变量，则程序只在启动时进行依次初始化，以后再调用函数时，将不会像自动变量那样再次被初始化。</p>
<h4 id="9-2-7-说明符和限定符"><a href="#9-2-7-说明符和限定符" class="headerlink" title="9.2.7 说明符和限定符"></a>9.2.7 说明符和限定符</h4><p>在同一个声明种不能使用多个说明符，但thread_local除外，它可与static或extern结合使用。</p>
<ul>
<li><p>cv-限定符</p>
<ol>
<li><strong>const</strong><br><strong>它表明内存被初始化后，程序便不能再对它进行修改</strong>。</li>
<li><strong>volatile</strong><br><strong>它表明，即使程序代码没有对内存单元进行修改，其值也可能发生变化</strong>。例如，假设编译器发现，程序再几条语句种两次使用了某个变量的值，则编译器可能不是让程序查找这个值两次，而是将这个值缓存到寄存器中。这种优化假设变量的值在这两次使用之间不会变化。如果不将变量声明为volatile，则编译器将执行这种优化；将变量声明为volatile，相当于告诉编译器，不要进行这种优化。</li>
</ol>
</li>
<li><p>mutable</p>
<p>可以用该关键字指出，即使结构（或类）变量为const，其某个成员也可以被修改。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> accesses;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> data veep = &#123;<span class="string">&quot;Claybourne Clodde&quot;</span>, <span class="number">0</span>, ...&#125;;</span><br><span class="line"><span class="built_in">strcpy</span>(veep.name, <span class="string">&quot;Joye Joux&quot;</span>); <span class="comment">//not allowed</span></span><br><span class="line">veep.accesses++; <span class="comment">// allowed</span></span><br></pre></td></tr></table></figure></li>
<li><p>const</p>
<p>在C++种，const限定符对默认存储类型稍有影响，在默认情况下全局变量的链接性为外部的，但const全局变量的链接性为内部的。</p>
</li>
</ul>
<h4 id="9-2-8-函数和链接性"><a href="#9-2-8-函数和链接性" class="headerlink" title="9.2.8 函数和链接性"></a>9.2.8 函数和链接性</h4><p>所有函数的存储持续性都自动为静态的，即在整个程序执行期间都一直存在。</p>
<p>在默认情况下，函数的链接性为外部的，即可以在文件间共享。（可以在函数原型中使用extern来指出函数是在另一个文件中定义的）。</p>
<p>可以使用关键字static将函数的链接性设置为内部的，使之只能在一个文件中使用（必须同时在原型和函数定义中使用该关键字）</p>
<h4 id="9-2-9-存储方案和动态分配"><a href="#9-2-9-存储方案和动态分配" class="headerlink" title="9.2.9 存储方案和动态分配"></a>9.2.9 存储方案和动态分配</h4><p>动态内存由运算符new和delete控制，而不是由作用域和链接性规则控制。通常，编译器使用三块独立的内存：一块用于静态变量，一块用于自动变量，一块用于动态存储。</p>
<p>new如果找不到请求的内存量，将会引发异常std::bad_alloc.</p>
<p>通常new运算符负责在堆中找到一个能够满足要求的内存块，定位运算符使用传递给它的地址，它不跟踪哪些内存单元已被使用，也不查找未使用的内存块。</p>
<p>delete只能用于指向常规new运算符分配的对内存的指针。</p>
<h3 id="9-3-名称空间"><a href="#9-3-名称空间" class="headerlink" title="9.3 名称空间"></a>9.3 名称空间</h3><p>生命区域（declaration region）：可以在其中进行声明的区域。<br>潜在作用域（potential scope）：变量的潜在作用域从声明点开始，到其声明区域的结尾。</p>
<p>名称空间可以是全局的，也可以位于另一个名称空间中，但不能位于代码块中。因此，在默认情况下，在名称空间中声明的名称的链接性为外部的。</p>
<p>全局名称空间对应于文件及声明区域，之前所说的全局变量现在被描述为位于全局名称空间中。</p>
<p>名称空间是开放的，即可以把名称加入到已有的名称空间中。可以通过作用域解析运算符(::)来访问给定名称空间中的名臣给。</p>
<p>using声明使特定的标识符可用（将特定的名称添加到它所属的声明区域中），using编译指令使整个名称空间可用。</p>
<p>假设名称空间和声明区域定义了相同的名称，如果试图使用using声明将名称空间的名称导入该生命区域，则这两个名称会发生冲突，从而出错。如果使用using编译指令将该名称空间的名称给导入该生命区域中，则局部版本将隐藏名称空间版本。</p>
<p>可以使用namespace给名称空间创建别名，如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> my_very_favorite_things&#123;...&#125;;</span><br><span class="line"><span class="keyword">namespace</span> mvft = my_very_favorite_things;<span class="comment">//使mvft称为my_very_favorite_things的别名</span></span><br></pre></td></tr></table></figure>

<p>可以通过省略名称空间的名称来创建未命名的名称空间，但不能在未命名的名称空间所属的文件之外的其他文件中使用该名称空间中的名称。这提供了链接性为内部的静态变量的替代品。</p>
<p>在开发时使用多个文件的一种有效的组织策略是，使用头文件来定义用户类型，为操纵用户类型的函数提供函数原型；并将函数定义放在一个独立的源代文件中。头文件和源代码文件一起定义和实现了用户定义的类型及其使用方式。最后，将main()和其他使用这些函数的函数放在第三个文件中。</p>
]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>C++ premier plus学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/03/26/R_%20Markdown/</url>
    <content><![CDATA[<h1 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h1><p>[toc]</p>
<h2 id="Markdown的格式"><a href="#Markdown的格式" class="headerlink" title="Markdown的格式"></a>Markdown的格式</h2><ol>
<li>简单的文本文件格式，通常保存为.md扩展名，中文内容使用UTF-8编码，有一些简单的格式标注方法：两个星号之间转换为斜体，缩进四个空格或者一个制表符的内容会堪称代码。</li>
<li>适用于简单的文章，源程序说明，不适合用于过多公式等复杂文档。可以转换为docx, pdf等格式。通过使用R 的扩展包knitr, rmarkdown, bookdown与pandoc软件一起大大扩展了markdown的适用范围。</li>
<li>如果需要作为一本书发布在网站上进行出版可以使用bookdown包，如果需要对出版格式进行精确控制，可以考虑使用LaTeX格式</li>
</ol>
<h2 id="Markdown格式文件的应用"><a href="#Markdown格式文件的应用" class="headerlink" title="Markdown格式文件的应用"></a>Markdown格式文件的应用</h2><ol>
<li>在Rstudio中可以编辑Markdown文件和含有R代码的Markdown文件，可以一键将其转换为MS WORD DOCX文件，再单独安装的LaTeX编译软件的支持下还可以直接编译成PDF，Rstudio支持下的增强的Markdown格式被称为RMarkdown格式，以Rmd为扩展名，支持大多数的LaTeX公式，在bookdown扩展包下还支持公式，定理，图标等自动标号和引用，链接</li>
</ol>
<h2 id="Markdown格式的说明"><a href="#Markdown格式的说明" class="headerlink" title="Markdown格式的说明"></a>Markdown格式的说明</h2><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>一个段落由一行或连续的多行组成，段落之间以空行分隔。同一段落内的不同行在转换成HTML或者DOCX格式时会重新进行排列，原来的段内行被当成了空格，这样的规定与LaTeX类似。普通段落不该用空格或者制表符来进行缩进，不应再行尾留有空格</p>
<ol>
<li><p>为了在段内换行并且在转换后仍然保持段内换行，输入时在前面的行尾输入两个或者两个以上的空格，但这样的缺点是末尾的空格是不可见的，可以使用HTML的&lt;br&gt;标签在段内进行换行</p>
</li>
<li><p>123456      </p>
<p>456</p>
</li>
<li><p>123456<br>456</p>
</li>
</ol>
<h3 id="段内文字格式"><a href="#段内文字格式" class="headerlink" title="段内文字格式"></a>段内文字格式</h3><ol>
<li><p>在一段内，用星号或下划线包围的内容如<em>强调</em>是强调格式。用双星号或双下划线包围的内容如<strong>加重</strong>是加重格式。<em>san</em>,<strong>san</strong>. 星号，下划线与要强调或加重的内容之间不要空开，否则会当作普通星号或下划线解释，在行首还会当作列表。为了插入普通的星号或下划线，可以使用反斜杠保护，或者携程段内代码格式</p>
</li>
<li><p><u>金融</u> <del>金融</del></p>
</li>
<li><p>可以用一对”~“作为界定符给出下标，如HO<del>2</del>。可以用一对“^”作为界定符给出上标，如Cu^2+^。但是，数学公式一般还是应该使用LaTeX数学公式形式</p>
</li>
<li><p>在普通段落内一部分内容希望显示成代码，对其中的特殊字符不做解释，只要包在两个反向单撇号内。如<code>if(_x_&gt;0),y=1;</code>,如果内容本身含有`，则要使用更多个数的单撇号，如<code>`x`</code>,注意留空格</p>
</li>
</ol>
<h3 id="标题和分割线"><a href="#标题和分割线" class="headerlink" title="标题和分割线"></a>标题和分割线</h3><ol>
<li>#开始的是一级标题，两个就是二级标题……直到六个。标题行前面应该空一行，否则可能会把某些偶然出现在行首的#认为是标题行的标志</li>
<li>用三个或者三个以上的星号可以组成分割线</li>
</ol>
<h3 id="引用段落"><a href="#引用段落" class="headerlink" title="引用段落"></a>引用段落</h3><ol>
<li><p>可以使用类似Email的回复包含原始邮件内容的办法输入引用段落，即在段落的每行前面加一个大于号。</p>
</li>
<li><blockquote>
<p>白日依山尽，黄河入海流</p>
<p>欲穷千里目，更上一层楼</p>
</blockquote>
</li>
<li><p>注意引用的也是段落模式，内容中的换行不起作用，空行导致分段</p>
</li>
<li><blockquote>
<p>张山说：里斯这样说过</p>
<blockquote>
<p>不想当将军的木匠不是好厨子</p>
</blockquote>
</blockquote>
</li>
</ol>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ol>
<li><p>星号表示一个不编号的列表项，也可以替换成加号或者减号，后面必须有一个或者多个空格。每个列表项可以输入多行，隔行的内容最好左对齐，左对齐在使用文本格式时较易阅读，但不是必须的。两个列表项之间尽量不要空行</p>
</li>
<li><p>如果列表项目中有多个段落，两个列表项之间应该以空行分隔，每个项目除了第一行外，输入的每行内容应该缩进四个空格或者一个制表符。</p>
</li>
<li><p>列表项目内如果有引用段落，需要都缩进四个空格。如果有程序代码，需要缩进四个空格后用三个反单撇号表示开始与结束。</p>
</li>
</ol>
<h3 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h3><ol>
<li>```R<blockquote>
<p>x&lt;-rnorm(100)<br>hist(x)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. R的knitr包在Markdown格式的文件中插入R可执行代码时，就用了这样的方法。而且R Markdown格式的代码块不需要用空行与前后分隔开</span><br><span class="line"></span><br><span class="line">### 链接</span><br><span class="line"></span><br><span class="line">1. 最简单的链接是原样显示的可点击的链接，只要把链接地址用小于号和大于号包在中间，两边用空格和其他内容隔开。如果是网页，需要使用http:&#x2F;&#x2F;,如果是邮箱，需要加上http:&#x2F;&#x2F;its.pku.edu.cn    mailto:shixiuxinya@gmail.com。</span><br><span class="line"></span><br><span class="line">2. 除此之外Markdown还支持两种形式的连接语法：行内式和引用式两种形式。不管哪一种，链接的显示文字都是用方括号[……]来标记。要建立一个行内式的链接，只要在方括号内写链接的显示文字，右方括号后面紧接着圆括号，并在圆括号中间插入网址链接即可。方括号部分与圆括号部分之间不能断开。如：</span><br><span class="line"></span><br><span class="line">   请参考：[李东风的教学主页](http:&#x2F;&#x2F;www.math.pku.edu.cn&#x2F;teachers&#x2F;lidf&#x2F;course&#x2F;index.htm)，在圆括号中，连接后面还可以包含用双撇号包围的标题文字，与连接之间用空格分开</span><br><span class="line"></span><br><span class="line">   引用式的链接：需要在某处（比如文章结尾）定义一些链接的标识符，然后用方括号包围链接的显示文字，后面紧接着方括号包围着链接的标识符。</span><br><span class="line"></span><br><span class="line">   为了定义连接标识符，用方括号包围连接标识符，前面可以用至多三个空格缩进，右方括号后面紧接着冒号和一个空格，空格后写链接地址，然后空格，在两个双撇号中间写一个链接地址的标题。如：[北大][pku]。</span><br><span class="line"></span><br><span class="line">   还有一种链接是内部链接，用于文内跳转。在各级标题行的末尾，可以添加&#123;# 自定义标签&#125;这样的内容，其中自定义标签是一个自己写的标识符，仅使用英文字母、数字、下划线、减号，用来区分不同的位置。如[回到列表](# 列表)。</span><br><span class="line"></span><br><span class="line">### 插入图形</span><br><span class="line"></span><br><span class="line">1. 图形只能用连接形式，不可能保存到一个纯文本文件内。图形文件可以存在于远程服务器上，也可以是与生成的HTML文件在同一目录结构中的文件。语法仍使用行内式和参考式两种形式。转化成HTML、PDF、Word格式后可以把图形内嵌在输出文件内部</span><br><span class="line"></span><br><span class="line">2. 行内式图片链接：普通行内连接格式前面添加了一个叹号，方括号内写图片的标题，圆括号内写图片链接，标题可以缺。</span><br><span class="line"></span><br><span class="line">   ![两仪式](https:&#x2F;&#x2F;gitee.com&#x2F;shixiuxinya&#x2F;image&#x2F;raw&#x2F;master&#x2F;img&#x2F;622762d0f703918f97f2e0cb5e3d269759eec494.jpg)</span><br><span class="line"></span><br><span class="line">   与连接类似，也可以在文章某处定义图片的标识符，然后把行内图片引用中图片地址替换成图片标识符即可</span><br><span class="line"></span><br><span class="line">   ![两仪式][shiki]</span><br><span class="line"></span><br><span class="line">   [shiki]: https:&#x2F;&#x2F;gitee.com&#x2F;shixiuxinya&#x2F;image&#x2F;raw&#x2F;master&#x2F;img&#x2F;622762d0f703918f97f2e0cb5e3d269759eec494.jpg</span><br><span class="line"></span><br><span class="line">### 表格</span><br><span class="line"></span><br><span class="line">* 管道表</span><br><span class="line"></span><br><span class="line">  1、管道表在两列之间用竖线分开，在列标题下面用减号画横线，用如下方法指定各对齐方式：</span><br><span class="line"></span><br><span class="line">  1. 在列标题下的横线开始加冒号，表示左对齐；</span><br><span class="line">  2. 在列标题下的横线末尾加冒好，表示右对齐</span><br><span class="line">  3. 在列标题下的横线两端加冒号，表示居中对齐</span><br><span class="line"></span><br><span class="line">  4. 列标题下面仅有横线，没有冒号，表示缺省对齐方式，一般是左对齐</span><br><span class="line"></span><br><span class="line">     ![管道表](https:&#x2F;&#x2F;gitee.com&#x2F;shixiuxinya&#x2F;image&#x2F;raw&#x2F;master&#x2F;img&#x2F;Snipaste_2020-02-25_22-04-46.png)</span><br><span class="line"></span><br><span class="line">* 简单表</span><br><span class="line"></span><br><span class="line">  简单表的格式是，第一行是各列标题，第二行是各标题下面用减号组成的表格线，同一行的不同列要用空格分开，从第三行开始是内容。在表格前或表格后用空行隔开的以Table: 开头的行是表格说明或标题。为了确定表格每列单元格内容如何对齐，用列标题下的表格线给出提示：</span><br><span class="line"></span><br><span class="line">  1. 表格线与列标题右对齐，表示该列右对齐；</span><br><span class="line"></span><br><span class="line">  2. 表格线与列标题左对齐，表示该列左对齐；</span><br><span class="line"></span><br><span class="line">  3. 列标题在表格线中间，表示该列居中对齐；</span><br><span class="line"></span><br><span class="line">  4. 列标题左右都与表格线对齐，表示该列为缺省对齐方式，一般是左对齐</span><br><span class="line"></span><br><span class="line">     ![简单表](https:&#x2F;&#x2F;gitee.com&#x2F;shixiuxinya&#x2F;image&#x2F;raw&#x2F;master&#x2F;img&#x2F;Snipaste_2020-02-25_22-09-34.png)</span><br><span class="line"></span><br><span class="line">* 换行表</span><br><span class="line"></span><br><span class="line">  换行表在输入列标题和单元格内容时，允许输入内容拆分行，但是转化后并不拆分行。这样的表以一行减号开始，以一行减号结束，中间的表格用空行分开实际的不同行。</span><br><span class="line"></span><br><span class="line">* 有格表</span><br><span class="line"></span><br><span class="line">  完全用减号、竖线、等于号、加号画出表格线。这样的表在文本格式下呈现出很好的表格形状。转化后不能指定对齐方式。</span><br><span class="line"></span><br><span class="line"># RMarkdown</span><br><span class="line"></span><br><span class="line">## R Markdown文件</span><br><span class="line"></span><br><span class="line">1、借助于R的knitr和rmarkdown扩展包的帮助，可以在Markdown格式的源文件中插入R代码，使得R代码的结果能够自动插入到最后生成的研究报告中。这种格式成为R Markdown格式，简称为Rmd格式，相应的源文件扩展名为.rmd。R Markdown 的基础格式是markdown 格式，严格说来是Pandoc 软件支持的增强版的markdown格式，比如，支持LaTex 格式的数学公式，支持各种编程语言语法彩色加亮显示等等。</span><br><span class="line"></span><br><span class="line">2、一个Rmd 文件中包含元数据(metadata)、正文内容和R 代码三种成分。在文件开头用三个减号组成的行包围的内容称为元数据，可以用来规定文章标题、作者、日期、输出格式、输出设置等属性。</span><br><span class="line"></span><br><span class="line">## R Markdown文件的编译</span><br><span class="line"></span><br><span class="line">1、在RStudio 软件中，用菜单“File–New File–R Markdown” 新建一个R Markdown文件，扩展名为.Rmd。用快捷图标Knit 可以将文件转换成HTML 格式、PDF 格式（需要安装LaTeX 编译软件）、MS Word 格式。</span><br><span class="line"></span><br><span class="line">2、从HTML 格式可以转换成PDF 格式。为此，安装Google 的Chrome 浏览</span><br><span class="line">器，在Chrome 中打开HTML 文件后，从Chrome 浏览器的菜单中找到打印</span><br><span class="line">菜单，从中选择打印机为“保存到PDF” 选项，就可以将HTML 网页转换成</span><br><span class="line">PDF，其中的数学公式、表格、图形都可以比较好地转换。</span><br><span class="line"></span><br><span class="line">3、如果想将R Markdown 文件借助于LaTeX 格式转换为PDF，需要在系统中</span><br><span class="line">安装一个TeX 编译器，如MS Windows 下有MikTeX 软件包。如果仅在R</span><br><span class="line">Markdown 文件中使用LaTeX 功能，可以安装谢益辉的TinyTeX软件包。</span><br><span class="line"></span><br><span class="line">4、假设test.Rmd 是一个这样的R Markdown 格式的文件，注意一定要使用UTF-8 编码保存，可以在R 或RStudio 中运行如下命令以生成含有运行结果的html 文件:</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;R</span><br><span class="line">rmarkdown::render(&quot;myfile.Rmd&quot;, output_format &#x3D; &quot;html_document&quot;, encoding&#x3D;&quot;UTF-8&quot;)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>其中myfile.Rmd 是源文件，产生的HTML 文件带有图形、支持数学公式。</p>
<ul>
<li>用RStudio 的Knit 图标一键编译与用rmarkdown::render() 命令编译有一个重要差别：<ol>
<li>用Knit 图标编译，Rmd 文件中的程序会在一个崭新的会话中执行，当前会话中已经定义的函数、变量、导入的扩展包不会影响到编译结果；</li>
<li>用rmarkdown::render() 编译，Rmd 文件中的程序是在当前会话中执行的，会带来一定的兼容性问题，有可能在别人的环境下就不能正确执行或者会给出不同结果。但是，rmarkdown::render() 可以通过程序调用，比如，循环地从同一个Rmd 生成一系列不同的报告。为了不让当前会话<br>环境干扰结果，可以人为地打开一个新会话。</li>
<li>尽量用Rstudio</li>
</ol>
</li>
</ul>
<h2 id="在R-Markdown文件中插入R代码"><a href="#在R-Markdown文件中插入R代码" class="headerlink" title="在R Markdown文件中插入R代码"></a>在R Markdown文件中插入R代码</h2><ul>
<li><p>行内代码</p>
<p>行内代码的结果插入到一个段落中间，代码以`r 开头，以`结尾，如r<br>sin(pi/2) 在结果中会显示为1。为了原样显示一个反向单撇号，可以在两边用双反向单撇号界定并用空格隔开内部的内容。</p>
</li>
<li><p>代码块</p>
<p>代码块则把结果当作单独的段落，按照Markdown 格式的规定，代码块的前后需要有空行，但是R Markdown 实际上放松了这个要求，允许前后不空行。R代码段以单独的一行开头，此行以三个反单撇号开始，然后是{r}，如```{r}。代码段以占据单独一行的三个反单撇号```结尾。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">set.seed(<span class="number">1</span>)</span><br><span class="line">x&lt;-<span class="built_in">round</span>(rnorm(<span class="number">10</span>),<span class="number">2</span>)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>

<p>## [1] -0.63 0.18 -0.84 1.60 0.33 -0.82 0.49 0.74 0.58 -0.31</p>
<p>可以看出，代码段程序会被插入到最终结果中，代码段的文本型输出会插入到程序的后面。代码块也可以嵌入到引用、列表等环境中。代码块中作的图将自动插入到当前位置。</p>
<p><img src="https://gitee.com/shixiuxinya/image/raw/master/img/Snipaste_2020-02-25_23-10-01.png" alt="作图"></p>
<p>在RStudio 中，可以用Insert 快捷图标插入代码段，还可以用Ctrl+Alt+I 快捷键插入代码段。</p>
</li>
</ul>
<h2 id="输出表格"><a href="#输出表格" class="headerlink" title="输出表格"></a>输出表格</h2><ul>
<li><p>knitr包提供了一个kabble()函数可以用来把数据框或矩阵转化成有格式的表格，支持HTML，docx，LaTeX等格式。</p>
<p><img src="https://gitee.com/shixiuxinya/image/raw/master/img/Snipaste_2020-02-25_23-31-14.png" alt="kabble"></p>
</li>
<li><p>R 扩展包xtable 提供了一个xtable() 函数，也可以用来生成HTML 格式和LaTeX 格式的表格，但是需要指定要输出的格式。xtable 对比较多的R 数据类型和输出类型提供了表格式显示功能，包括矩阵、数据框、回归分析结果、方差分析结果、主成分分析结果、若干分析结果的summary 结果等。</p>
</li>
<li><p>R 扩展包pander 提供了更好的表格能力，也能与knitr 包很好的合作输出。其pander() 函数可以将多种R 输出格式转换成knitr 需要的表格形式。</p>
<p><img src="https://gitee.com/shixiuxinya/image/raw/master/img/Snipaste_2020-02-25_23-35-14.png" alt="pander"></p>
<p>但是，经过试验发现，表中中有中文时pander 包会出错。</p>
</li>
</ul>
<h2 id="利用R程序插图"><a href="#利用R程序插图" class="headerlink" title="利用R程序插图"></a>利用R程序插图</h2><p>1、Rmd 文件的插图有两种，一种是已经保存为图形文件的，主要是png 和pdf图片；另一种是文中的R 代码生成的图形。已经有图形文件的，可以用markdown 格式原来的插图方法，见markdown 格式介绍。但是，这样做不能给图形自动编号，另外因为制作图书是有网页和PDF书两种主要输出格式的，原有的插图方式在这两种输出格式上有细微的不一致。所以，最好是统一使用Rmd 的插图方法。</p>
<p>2、Rmd 的插图方法就是写一段R 代码段来插图，如果是用程序作图，则代码中写作图的代码；如果是已有的图形文件，可以在一个单独的R 代码段中用类似下面的命令插图：</p>
<figure class="highlight plain"><figcaption><span>echo</span></figcaption><table><tr><td class="code"><pre><span class="line">knitr::include_graphics(&quot;figs&#x2F;myfig01.png&quot;)</span><br></pre></td></tr></table></figure>

<p>3、其中figs 是存放图形文件的子目录名，myfig01.png 是要插入的图形文件<br>名。这样，如果同时还有myfig01.pdf 的话，则HTML 输出使用png 图片<br>而PDF 输出自动选用pdf 文件。另外，插图的选项在代码段的选项中规定：<br>用代码段的fig.with 和fig.height 选项指定作图的宽和高（英寸），用<br>out.width 和out.height 选项指定在输出中实际显示的宽和高，实际显示的<br>宽和高如果使用如”90%” 这样的百分数单位则可以自动适应输出的大小。</p>
<p>4、由于PDF 中的中文编码不能自动识别，所以在每个Rmd 源文件的开头应该加上如下的设置，使得生成PDF 图时中文能够正确显示：</p>
<figure class="highlight plain"><figcaption><span>setup-pdf, include</span></figcaption><table><tr><td class="code"><pre><span class="line">pdf.options(family&#x3D;&quot;GB1&quot;)</span><br></pre></td></tr></table></figure>
<p>其中include=FALSE 表示要不显示代码段的代码，有运行结果也不插入到输<br>出结果中，是否运行视缺省的eval= 的值而定。</p>
<h2 id="代码段选项"><a href="#代码段选项" class="headerlink" title="代码段选项"></a>代码段选项</h2>]]></content>
  </entry>
  <entry>
    <title>c++类知识点小结</title>
    <url>/2021/03/26/c++%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="C-类知识点小结"><a href="#C-类知识点小结" class="headerlink" title="C++类知识点小结"></a><strong>C++类知识点小结</strong></h2><h3 id="编译器生成的成员函数"><a href="#编译器生成的成员函数" class="headerlink" title="编译器生成的成员函数"></a>编译器生成的成员函数</h3><h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><ul>
<li><p>默认构造函数要么没有参数，要么所有的参数都有默认值。</p>
</li>
<li><p>如果没有定义任何构造函数，编译器将定义默认构造函数以创建对象；自动生成的默认构造函数的另一项功能是，调用基类的默认构造函数以及调用本身是对象的成员所属类的默认构造函数。</p>
</li>
<li><p>如果派生类构造函数的成员初始化列表中没有调用基类构造函数，则编译器将使用基类的默认构造函数来构造派生类的基类部分。</p>
</li>
<li><p>如果定义了某种构造函数，编译器将不会定义默认构造函数，在这种情况下如果需要默认构造函数，则必须自己提供。</p>
</li>
</ul>
<h4 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h4><ul>
<li><p>复制构造函数接收其所属类的对象作为参数。在下列情况下，将使用复制构造函数：</p>
<p>1、将新对象初始化为一个同类对象；</p>
<p>2、按值将对象传递给函数；</p>
<p>3、函数按值返回对象；</p>
<p>4、编译器生成临时对象；</p>
</li>
<li><p>如果程序没有使用（显式或隐式）复制构造函数，编译器将提供原型，但不提供函数定义；否则，程序将定义一个执行成员初始化的复制构造函数。</p>
</li>
<li><p>使用new初始化的成员指针通常要求执行深复制，类可能包含需要修改的静态变量，以上情况需要自己定义复制构造函数。</p>
</li>
</ul>
<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><ul>
<li>默认的赋值运算符用于处理同类对象之间的赋值。（<strong>如果语句创建新的对象，则使用初始化；如果语句修改已有对象的值，则是赋值</strong>）</li>
<li>默认赋值为成员赋值。如果成员为类对象，则默认成员赋值将使用相应类的赋值运算符。如果需要显式定义复制构造函数，则基于相同的原因，也需要显式定义赋值运算符。</li>
<li>编译器不会生成将一种类型赋给另一种类型的赋值运算符，如果希望这样做的话，可以显式定义运算符，例如将字符串付给Star对象，可以显式定义如下运算符：<code>Star &amp; Star::operator=(const char *)&#123;&#125;</code>;另一种方法是使用转换函数将字符串转换为Star对象，然后使用将Star赋给Star的赋值函数。</li>
</ul>
<h3 id="其它的类方法"><a href="#其它的类方法" class="headerlink" title="其它的类方法"></a>其它的类方法</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ul>
<li>构造函数不同于其它类方法，因为它创建新的对象，而其他类方法只是被现有的对象调用。这是构造函数不被继承的原因之一。继承意味着派生类对象可以使用基类的方法，然而，构造函数在完成其工作之前，对象并不存在。</li>
</ul>
<h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><ul>
<li>一定要定义显示析构函数来释放类构造函数使用new分配的所有内存， 并完成类对象所需的任何特殊的清理工作。对于基类，即使它不需要析构函数，也应该提供一个虚析构函数。</li>
</ul>
<h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><ul>
<li><p>使用一个参数就可以调用的构造函数定义了从参数类型到类类型的转换。例如前面提到的将字符串转换为Star对象可通过如下构造函数<code>Star(const char *);</code>。</p>
</li>
<li><p>将可转换的类型传递给以类为参数的函数时，将调用转换构造函数。</p>
</li>
<li><p>要将类对象转换为其他类型，应定义转换函数。转换函数可以是<strong>没有参数的类成员函数</strong>，也可以是<strong>返回类型被声明为目标类型的类成员函数</strong>，即使没有声明返回类型，函数也应返回所需的转换值。示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Star::Star <span class="title">double</span><span class="params">()</span></span>&#123;...&#125;  <span class="comment">//将Star对象类型转换为double</span></span><br><span class="line">Star::Star <span class="keyword">const</span> <span class="keyword">char</span> *()&#123;...&#125; <span class="comment">//将对象转换为const char</span></span><br></pre></td></tr></table></figure></li>
<li><p>C++11支持将关键字explicit用于转换函数。与构造函数一样，explicit允许使用强制类型转换进行显式转换，但不允许隐式转换。</p>
</li>
</ul>
<h4 id="按值传递对象与传递引用"><a href="#按值传递对象与传递引用" class="headerlink" title="按值传递对象与传递引用"></a>按值传递对象与传递引用</h4><ul>
<li>通常，编写使用对象作为参数的函数时，应按引用而不是按值来传递对象，这样做的原因之一是为了提高效率，另一个原因是，在继承使用虚函数时，被定义为接受基类引用参数的函数可以接受派生类。</li>
</ul>
<h4 id="返回对象和返回引用"><a href="#返回对象和返回引用" class="headerlink" title="返回对象和返回引用"></a>返回对象和返回引用</h4><ul>
<li>函数不能返回在函数中创建的临时对象的引用（当函数结束时，临时对象将消失，这种引用时非法的），在这种情况下应返回对象，以生成一个调用程序可以使用的副本。</li>
<li>如果函数返回的是通过引用或指针传递给他的对象，应按引用返回对象，以节省时间和内存。</li>
</ul>
]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>C++ premier plus学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/03/26/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>JsonPath</title>
    <url>/2021/03/26/jsonpath/</url>
    <content><![CDATA[<h3 id="jsonpath"><a href="#jsonpath" class="headerlink" title="jsonpath"></a>jsonpath</h3><p>jsonpaht是一种信息抽取类库，是从JSON文档中抽取指定信息的工具，jsonpath对于JSON来说，相当于Xpath对于xml。</p>
<blockquote>
<p><a href="http://goessner.net/articles/JsonPath">官方文档</a></p>
</blockquote>
<ul>
<li>jsonpath和xpath对比</li>
</ul>
<table>
<thead>
<tr>
<th align="center">Xpath</th>
<th align="center">JSONPath</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">/</td>
<td align="center">$</td>
<td align="center">根节点</td>
</tr>
<tr>
<td align="center">.</td>
<td align="center">@</td>
<td align="center">现行节点</td>
</tr>
<tr>
<td align="center">.</td>
<td align="center">. or [ ]</td>
<td align="center">取子节点</td>
</tr>
<tr>
<td align="center">..</td>
<td align="center">NA</td>
<td align="center">取父节点，Jsonpath不支持</td>
</tr>
<tr>
<td align="center">//</td>
<td align="center">..</td>
<td align="center">不管位置，选择所有符合条件节点</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">*</td>
<td align="center">匹配所有元素节点</td>
</tr>
<tr>
<td align="center">@</td>
<td align="center">NA</td>
<td align="center">根据属性访问，Json不支持，因为json是个key-value递归结构，不需要属性访问</td>
</tr>
<tr>
<td align="center">[ ]</td>
<td align="center">[ ]</td>
<td align="center">迭代器标示（可进行简单的迭代操作，如数组下标，根据内容选值等）</td>
</tr>
<tr>
<td align="center">|</td>
<td align="center">[, ]</td>
<td align="center">支持多选迭代操作</td>
</tr>
<tr>
<td align="center">[ ]</td>
<td align="center">?()</td>
<td align="center">支持过滤操作</td>
</tr>
<tr>
<td align="center">NA</td>
<td align="center">()</td>
<td align="center">支持表达式计算</td>
</tr>
<tr>
<td align="center">()</td>
<td align="center">NA</td>
<td align="center">分组，Jsonpath不支持</td>
</tr>
</tbody></table>
<ul>
<li>jsonpath example,选自<a href="http://goessner.net/articles/JsonPath">官方文档</a>。</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">&quot;store&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;book&quot;</span>: [</span><br><span class="line">      &#123; <span class="attr">&quot;category&quot;</span>: <span class="string">&quot;reference&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;Nigel Rees&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Sayings of the Century&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;price&quot;</span>: <span class="number">8.95</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123; <span class="attr">&quot;category&quot;</span>: <span class="string">&quot;fiction&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;Evelyn Waugh&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Sword of Honour&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;price&quot;</span>: <span class="number">12.99</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123; <span class="attr">&quot;category&quot;</span>: <span class="string">&quot;fiction&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;Herman Melville&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Moby Dick&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;isbn&quot;</span>: <span class="string">&quot;0-553-21311-3&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;price&quot;</span>: <span class="number">8.99</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123; <span class="attr">&quot;category&quot;</span>: <span class="string">&quot;fiction&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;J. R. R. Tolkien&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;The Lord of the Rings&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;isbn&quot;</span>: <span class="string">&quot;0-395-19395-8&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;price&quot;</span>: <span class="number">22.99</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;bicycle&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;color&quot;</span>: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;price&quot;</span>: <span class="number">19.95</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<table>
<thead>
<tr>
<th align="center">xpath</th>
<th align="center">Jsonpath</th>
<th align="center">result</th>
</tr>
</thead>
<tbody><tr>
<td align="center">/store/book/author</td>
<td align="center">$.store.book[*].author</td>
<td align="center">the author of all books in the store</td>
</tr>
<tr>
<td align="center">//author</td>
<td align="center">$..author</td>
<td align="center">all authors</td>
</tr>
<tr>
<td align="center">/store/*</td>
<td align="center">$.store.*</td>
<td align="center">all things in store,which are some books and a red bicycle.</td>
</tr>
<tr>
<td align="center">/store//price</td>
<td align="center">$.store..price</td>
<td align="center">the price of everything in the store</td>
</tr>
<tr>
<td align="center">//boook[3]</td>
<td align="center">$..book[2]</td>
<td align="center">the third book</td>
</tr>
<tr>
<td align="center">//book[last()]</td>
<td align="center">$..book[@.length-1] or $..book[-1:]</td>
<td align="center">the last book in order</td>
</tr>
<tr>
<td align="center">//book[position()&lt;3]</td>
<td align="center">$..book[0,1] or $..book[:2]</td>
<td align="center">the first two books</td>
</tr>
<tr>
<td align="center">//book[isbn]</td>
<td align="center">$..book[?(@.isbn)]</td>
<td align="center">filter all books with isbn number</td>
</tr>
<tr>
<td align="center">//book[price&lt;10]</td>
<td align="center">$..book[?(@price&lt;10)]</td>
<td align="center">filter all books cheapier than 10</td>
</tr>
<tr>
<td align="center">//*</td>
<td align="center">$..*</td>
<td align="center">all elements in XML document. All members of JSON structure.</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>regexp</title>
    <url>/2021/03/26/regexp/</url>
    <content><![CDATA[<h1 id="regexp学习笔记"><a href="#regexp学习笔记" class="headerlink" title="regexp学习笔记"></a>regexp学习笔记</h1><h2 id="regex常用匹配规则"><a href="#regex常用匹配规则" class="headerlink" title="regex常用匹配规则"></a>regex常用匹配规则</h2><table>
<thead>
<tr>
<th align="center">模式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\w</td>
<td align="left">匹配字母、数字及下划线</td>
</tr>
<tr>
<td align="center">\W</td>
<td align="left">匹配不是字母、数字及下划线</td>
</tr>
<tr>
<td align="center">\s</td>
<td align="left">匹配任意空白字符，等价于[\t\n\r\f]</td>
</tr>
<tr>
<td align="center">\S</td>
<td align="left">匹配任意非空白字符</td>
</tr>
<tr>
<td align="center">\d</td>
<td align="left">匹配任意数字，等价于[0-9]</td>
</tr>
<tr>
<td align="center">\D</td>
<td align="left">匹配任意非数字字符</td>
</tr>
<tr>
<td align="center">\A</td>
<td align="left">匹配字符串开头</td>
</tr>
<tr>
<td align="center">\Z</td>
<td align="left">匹配字符串结尾，如果存在换行，只匹配换行前的结束字符串</td>
</tr>
<tr>
<td align="center">\z</td>
<td align="left">匹配字符串结尾，如果存在换行，同时匹配换行符</td>
</tr>
<tr>
<td align="center">\G</td>
<td align="left">匹配最后匹配完成的位置</td>
</tr>
<tr>
<td align="center">\n</td>
<td align="left">匹配一个换行符</td>
</tr>
<tr>
<td align="center">\t</td>
<td align="left">匹配一个制表位</td>
</tr>
<tr>
<td align="center">^</td>
<td align="left">匹配一行字符的开头</td>
</tr>
<tr>
<td align="center">$</td>
<td align="left">匹配一行字符串的结尾</td>
</tr>
<tr>
<td align="center">.</td>
<td align="left">匹配任意字符，除了换行符，<em>当re.DOTALL被指定时可以匹配换行符</em></td>
</tr>
<tr>
<td align="center">[…]</td>
<td align="left">用来表示一组字符，单独列出，比如[amk]匹配a、m或k</td>
</tr>
<tr>
<td align="center">[^…]</td>
<td align="left">不在[]中的字符，如[^a]匹配除了a之外的字符</td>
</tr>
<tr>
<td align="center">*</td>
<td align="left">匹配0个或多个表达式</td>
</tr>
<tr>
<td align="center">+</td>
<td align="left">匹配1个或多个表达式</td>
</tr>
<tr>
<td align="center">?</td>
<td align="left">匹配0个或一个前面的正则表达式定义的片段（<em>非贪婪方式</em>）</td>
</tr>
<tr>
<td align="center">{n}</td>
<td align="left">匹配n个前面的表达式</td>
</tr>
<tr>
<td align="center">{n,m}</td>
<td align="left">匹配n到m次由前面正则表达式定义的片段（<em>贪婪方式</em>）</td>
</tr>
<tr>
<td align="center">a|b</td>
<td align="left">匹配a或者b</td>
</tr>
<tr>
<td align="center">( )</td>
<td align="left">匹配括号内的表达式，也表示一个组</td>
</tr>
</tbody></table>
<h2 id="re库的常用方法"><a href="#re库的常用方法" class="headerlink" title="re库的常用方法"></a>re库的常用方法</h2><ul>
<li><p>match()</p>
<p>从字符串起始位置匹配正则表达式，如果匹配，就返回匹配成功的结果，如果不匹配，就返回None</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re </span><br><span class="line">content = <span class="string">&#x27;Hello 123 4567 World_This is a Regex Demo&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(content))</span><br><span class="line">result = re.match(<span class="string">r&#x27;^Hello\s\d\d\d\s\d&#123;4&#125;\s\w&#123;10&#125;&#x27;</span>,content)</span><br><span class="line"><span class="comment">#使用正则表达式时记得在字符串前面加r，以免出错</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(result.group())<span class="comment">#输出匹配内容</span></span><br><span class="line"><span class="built_in">print</span>(result.span())<span class="comment">#输出匹配的范围</span></span><br></pre></td></tr></table></figure>

<p>常用修饰符：</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>re.I</td>
<td>使匹配对大小写不敏感</td>
</tr>
<tr>
<td>re.L</td>
<td>做本地化识别(local-aware)匹配</td>
</tr>
<tr>
<td>re.M</td>
<td>多行匹配，影响^和$</td>
</tr>
<tr>
<td>re.S</td>
<td>使.匹配包括换行在内的所有字符</td>
</tr>
<tr>
<td>re.U</td>
<td>根据Unicode字符集解析字符。(<em>影响\w、\W,\b和\B</em>)</td>
</tr>
<tr>
<td>re.X</td>
<td>该标志通过给予你更灵活的格式以便你将regex写得更易于理解</td>
</tr>
</tbody></table>
</li>
<li><p>search()</p>
<p>匹配时扫描整个字符串，然后返回第一个成功匹配的结果，即正则表达式可以是字符串的一部分，不必从头开始匹配。</p>
<blockquote>
<p>由于绝大多数html文本都包含换行符，匹配时尽量都加上re.S修饰符</p>
</blockquote>
</li>
<li><p>findall()</p>
<p>该方法会搜索整个字符串，然后返回匹配正则表达式的所有内容</p>
</li>
<li><p>sub()</p>
<p>可由于修改文本</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">content = <span class="string">&#x27;sjdowo23-958utuo0eut&#x27;</span></span><br><span class="line">content = re.sub(<span class="string">&#x27;\d+&#x27;</span>,content)<span class="comment">#除去文本中的数字</span></span><br><span class="line"><span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure></li>
<li><p>compile()</p>
<p>该方法可以将正则字符串编译成正则表达式对象，以便在后面的匹配中复用。</p>
<p>示例：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">content1 = <span class="string">&#x27;2016-12-15 12:00&#x27;</span></span><br><span class="line">content2 = <span class="string">&#x27;2016-12-17 12:55&#x27;</span></span><br><span class="line">content3 = <span class="string">&#x27;2016-12-22 13:21&#x27;</span></span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;\d&#123;2&#125;:\d&#123;2&#125;&#x27;</span>)<span class="comment">#匹配时间</span></span><br><span class="line"><span class="comment">#使用compile方法将正则表达式编译成一个正则表达对象</span></span><br><span class="line">result1 = re.sub(pattern,<span class="string">&#x27;&#x27;</span>,content1)</span><br><span class="line">result2 = re.sub(pattern,<span class="string">&#x27;&#x27;</span>,content2)</span><br><span class="line">result3 = re.sub(pattern,<span class="string">&#x27;&#x27;</span>,content3)</span><br><span class="line"><span class="built_in">print</span>(result1,result2,result3,sep=<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Selenium</title>
    <url>/2021/03/26/selenium%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h2 id="Selenium学习笔记"><a href="#Selenium学习笔记" class="headerlink" title="Selenium学习笔记"></a>Selenium学习笔记</h2><blockquote>
<p>selenium是一个自动化测试工具，利用它可以驱动浏览器执行特定的动作，如点击、下拉等操作，同时还可以获取浏览器当前呈现的也米娜的源代码，做到了可见即可爬。</p>
</blockquote>
<h3 id="声明浏览器对象"><a href="#声明浏览器对象" class="headerlink" title="声明浏览器对象"></a>声明浏览器对象</h3><p>selenium支持非常多的浏览器，如Chrome、Firefox、Edge等，还有Android、BlackBerry等手机端的浏览器，可利用如下方法初始化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser = webdriver.Firefox()</span><br><span class="line">browser = webdriver.Edge()</span><br><span class="line">browser = webdriver.PhantomJS()</span><br><span class="line">browser = webdriver.Safari()</span><br></pre></td></tr></table></figure>
<p>这样就对浏览器对象初始化成功并将其赋值为browser对象，接下来，我们要做的就是调用browser对象，让其执行各个动作以模拟浏览器操作</p>
<h3 id="访问页面"><a href="#访问页面" class="headerlink" title="访问页面"></a>访问页面</h3><p>可以使用get()方法来请求网页，参数传入URL,eg:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Firefox()</span><br><span class="line">browser.get(<span class="string">&quot;https://www.taobao.com&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(browser.page_source)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure>

<h3 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h3><ul>
<li>单个节点</li>
</ul>
<p>获取单个节点的方法：</p>
<p>find_element_by_id()</p>
<p>find_element_by_name()</p>
<p>find_element_by_xpath()</p>
<p>find_element_by_link_text()</p>
<p>find_element_by_partial_link_text()</p>
<p>find_element_by_tag_name()</p>
<p>find_element_by_class_name()</p>
<p>find_element_by_css_selector()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Firefox()</span><br><span class="line">browser.get(<span class="string">&quot;https://www.taobao.com&quot;</span>)</span><br><span class="line">input_first = browser.find_element_by_id(<span class="string">&quot;q&quot;</span>)   <span class="comment">#根据id获取</span></span><br><span class="line">input_second = browser.find_element_by_css_selector(<span class="string">&#x27;#q&#x27;</span>)   <span class="comment">#根据css选择器获取</span></span><br><span class="line">input_third = browser.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;q&quot;]&#x27;</span>) <span class="comment">#根据xpath获取</span></span><br><span class="line"><span class="built_in">print</span>(input_first,input_second,input_third)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure>
<p>selenium还提供了通用方法find_element(),它需要传入两个参数：查找方式By和值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line">browser = webdriver.Firefox()</span><br><span class="line">browser.get(<span class="string">&quot;https://www.taobao.com&quot;</span>)</span><br><span class="line">input_first = browser.find_element(By.ID,<span class="string">&#x27;q&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(input_first)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure>
<ul>
<li>多个节点<br>如果查找的目标在网页中只有一个，那么完全可以用find_element()方法，但如果要查找所有满足条件的节点需要使用find_elements()这样的方法。eg:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Firefox()</span><br><span class="line">browser.get(<span class="string">&quot;https://www.taobao.com&quot;</span>)</span><br><span class="line">lis = browser.find_elements_by_css_selector(<span class="string">&#x27;.service-bd li&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(lis)</span><br><span class="line">browser.close()<span class="comment">#输出结果为列表类型，每个节点都是WebElement类型</span></span><br></pre></td></tr></table></figure>
获取多个几点的方法：</li>
</ul>
<p>find_elements_by_id()</p>
<p>find_elements_by_name()</p>
<p>find_elements_by_xpath()</p>
<p>find_elements_by_link_text()</p>
<p>find_elements_by_partial_link_text()</p>
<p>find_elements_by_tag_name()</p>
<p>find_elements_by_class_name()</p>
<p>find_elements_by_css_selector()</p>
<p>当然，我们也可以通过find_elements()，方法来选择。</p>
<h3 id="节点交互"><a href="#节点交互" class="headerlink" title="节点交互"></a>节点交互</h3><p>selenium可以驱动浏览器来执行一些操作，也就是说可以让浏览器模拟执行一些动作，比较常见的用法有：输入文字时用send_keys()方法，清空文字时用clear()方法，点击按钮用click()方法。<br>更多操作见<a href="http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.remote.webelement">官方文档</a>。<br>示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">browser = webdriver.Firefox()</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.taobao.com&#x27;</span>)</span><br><span class="line"><span class="built_in">input</span> = browser.find_element_by_id(<span class="string">&#x27;q&#x27;</span>)</span><br><span class="line"><span class="built_in">input</span>.send_keys(<span class="string">&quot;蓝牙耳机&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">input</span>.clear()</span><br><span class="line"><span class="built_in">input</span>.send_keys(<span class="string">&quot;ipad&quot;</span>)</span><br><span class="line">button = browser.find_element_by_class_name(<span class="string">&#x27;btn-search tb-bg&#x27;</span>)</span><br><span class="line">button.click()</span><br></pre></td></tr></table></figure>

<h3 id="动作链"><a href="#动作链" class="headerlink" title="动作链"></a>动作链</h3><p>在上面的例子中，一些交互动作都是针对某个节点执行的，比如，对于输入框，我们就调用它的输入文字和清空文字方法；对于按键就调用它的点击方法<br>。其实还有另外一些操作，它们没有特定的执行对象，比如鼠标拖拽、键盘按键等，这些动作可以用动作链来执行。<br>比如，将某个节点从一处拖拽到另一处，可以这样实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</span><br><span class="line"><span class="comment"># 打开网页中的一个拖拽实例，然后一次选中要拖拽的节点和拖拽到的目标节点，接着声明ActionChains对象</span></span><br><span class="line"><span class="comment"># 并将其赋值为actions变量，然后调用drap_and_drop()方法，再调用perform()方法执行动作。</span></span><br><span class="line">browser = webdriver.Firefox()</span><br><span class="line">url = <span class="string">&quot;http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&quot;</span></span><br><span class="line">browser.get(url)</span><br><span class="line">browser.switch_to.frame(<span class="string">&quot;iframeResult&quot;</span>)</span><br><span class="line">source = browser.find_element_by_css_selector(<span class="string">&#x27;#draggable&#x27;</span>)</span><br><span class="line">target = browser.find_element_by_css_selector(<span class="string">&#x27;#droppable&#x27;</span>)</span><br><span class="line">actions = ActionChains(browser)</span><br><span class="line">actions.drag_and_drop(source,target)</span><br><span class="line">actions.perform()</span><br></pre></td></tr></table></figure>
<p>更多动作链可以参考<a href="http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.common.action_chains">官方文档</a></p>
<h3 id="执行JavaScrip"><a href="#执行JavaScrip" class="headerlink" title="执行JavaScrip"></a>执行JavaScrip</h3><p>对于某些操作，Selenium API并没有提供，这时可以使用JavaScript来进行操作，eg:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriber.Firefox()</span><br><span class="line">browser.get(<span class="string">&quot;https://www.zhihu.com/explore&quot;</span>)</span><br><span class="line">browser.excute_script(<span class="string">&#x27;window.scrollTo(0,document.body.scrollHeight)&#x27;</span>)</span><br><span class="line">browser.excute_script(<span class="string">&#x27;alert(&quot;to bootom&quot;)&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="获取节点信息"><a href="#获取节点信息" class="headerlink" title="获取节点信息"></a>获取节点信息</h3><ul>
<li><p>获取属性<br>可以使用get_attribute()方法来获取节点的属性，但是其前提是先选中这个节点，示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</span><br><span class="line">browser = webdriver.Firefox()</span><br><span class="line">url = <span class="string">&quot;https://www.zhihu.com/explore&quot;</span></span><br><span class="line">browser.get(url)</span><br><span class="line">logo = browser.find_element_by_xpath(<span class="string">&#x27;/html/body/div[1]/div/div[2]/header/div[2]/div/div/a&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(logo)</span><br><span class="line"><span class="built_in">print</span>(logo.get_attribute(<span class="string">&#x27;href&#x27;</span>))</span><br></pre></td></tr></table></figure></li>
<li><p>获取文本<br>每个WebElement节点都有text属性，直接调用这个属性就可以得到节点内部的文本信息，相当于BeautifulSoup的get_text()方法，pyquery的text()方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Firefox()</span><br><span class="line">url = <span class="string">&quot;https://www.zhihu.com/explore&quot;</span></span><br><span class="line">browser.get(url)</span><br><span class="line"><span class="built_in">input</span> = browser.find_element_by_css_selector(<span class="string">&#x27;.AppHeader-login&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>.text)</span><br></pre></td></tr></table></figure></li>
<li><p>获取id、位置、标签名和大小<br>id属性可以获取节点的id，location属性可以获取该节点在页面中的相对位置，tag_那么可以获取标签名称，size属性可以获取节点的大小，也就是宽高。eg:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Firefox()</span><br><span class="line">url = <span class="string">&quot;https://www.zhihu.com/explore&quot;</span></span><br><span class="line">browser.get(url)</span><br><span class="line"><span class="built_in">input</span> = browser.find_element_by_css_selector(<span class="string">&#x27;.AppHeader-login&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>.<span class="built_in">id</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>.location)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>.tag_name)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>.size)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="切换Frame"><a href="#切换Frame" class="headerlink" title="切换Frame"></a>切换Frame</h3><p>网页中有一种节点叫做iframe，也就是子Frame，相当于页面的子页面，它的结构和外面的结构<br>完全一致。Selenium打开页面后，它默认是在父级Frame里面操作，而此时如果页面中还有子Frame<br>它是不饿能获取到子Frame里面的节点的。这时就需要使用switch_to.frame()方法来切换Frame。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> NoSuchElementException</span><br><span class="line">browser = webdriver.Firefox()</span><br><span class="line">url = <span class="string">&quot;http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&quot;</span></span><br><span class="line">browser.get(url)</span><br><span class="line">browser.switch_to.frame(<span class="string">&#x27;iframeResult&#x27;</span>) <span class="comment"># 切换为子Frame</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    logo = browser.find_element_by_class_name(<span class="string">&#x27;logo&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> NoSuchElementException:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No LOGO&quot;</span>)</span><br><span class="line">browser.switch_to.parent_frame()    <span class="comment"># 切换为父级Frame</span></span><br><span class="line">logo = browser.find_element_by_class_name(<span class="string">&#x27;logo&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(logo)</span><br><span class="line"><span class="built_in">print</span>(logo.text)</span><br></pre></td></tr></table></figure>

<h3 id="延时等待"><a href="#延时等待" class="headerlink" title="延时等待"></a>延时等待</h3><p>在selenium中，get()方法会在网页加载结束后结束执行，此时如果获取page_source,可能并不是<br>浏览器完全加载完成的页面，如果某些页面有额外的Ajax请求，我们在网页源代码中也不一定能够成功<br>获取到。所以，这里需要延时等待一定时间，确保节点已经加载出来。</p>
<ul>
<li>隐式等待<br>当使用隐式等待执行测试的时候，如果Selenium没有在DOM中找到节点，将继续等待，超出设定时间后，则抛出<br>找不到节点的异常，即当查找节点而节点没有立即出现的时候，隐式等待将会等待一段时间再查找DOM，默认的时间是0。<br>示例：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Firefox()</span><br><span class="line">browser.implicitly_wait(<span class="number">10</span>) <span class="comment">#使用implicitly_wait()方法实现隐式等待</span></span><br><span class="line">browser.get(<span class="string">&quot;https://www.zhihu.com/explore&quot;</span>)</span><br><span class="line"><span class="built_in">input</span> = browser.find_element_by_class_name(<span class="string">&#x27;Input&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>)</span><br></pre></td></tr></table></figure></li>
<li>显式等待<br>隐式等待的结果其实没有那么好，因为我们只规定了一个固定时间，而页面的加载时间会受到网络条件的影响。这里有一种更适合的显式等待方法<br>，它指定要查找的节点，然后指定一个最长等待时间。如果到了规定时间依然没有加载出该节点，则抛出超时异常。示例如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显式等待</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"></span><br><span class="line">browser = webdriver.Firefox()</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.taobao.com&#x27;</span>)</span><br><span class="line">wait = WebDriverWait(browser,<span class="number">10</span>)    <span class="comment">#引入WebDriverWait对象，指定最长等待时间</span></span><br><span class="line"><span class="built_in">input</span> = wait.until(EC.presence_of_element_located((By.ID,<span class="string">&#x27;q&#x27;</span>)))</span><br><span class="line"><span class="comment"># 调用WebDriverWait对象until()方法，传入要等待条件expected_conditions</span></span><br><span class="line">button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR,<span class="string">&#x27;.btn-search&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>,button)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure></li>
<li>等待条件及含义</li>
</ul>
<table>
<thead>
<tr>
<th align="left">等待条件</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">title_is</td>
<td align="left">标题是某内容</td>
</tr>
<tr>
<td align="left">title_contains</td>
<td align="left">标题包含某内容</td>
</tr>
<tr>
<td align="left">presence_of_element_located</td>
<td align="left">节点加载出来，传入<strong>定位元组</strong>,如上例中的（By.ID,’p’)</td>
</tr>
<tr>
<td align="left">visibility_of_element_located</td>
<td align="left">节点可见，传入定位元组</td>
</tr>
<tr>
<td align="left">visibility_of</td>
<td align="left">可见，传入定位对象</td>
</tr>
<tr>
<td align="left">presence_of_all_elements_located</td>
<td align="left">所有节点加载出来</td>
</tr>
<tr>
<td align="left">text_to_be_present_in_element</td>
<td align="left">某个节点文本包含某文字</td>
</tr>
<tr>
<td align="left">text_to_be_present_in_element_value</td>
<td align="left">某个节点值包含某文字</td>
</tr>
<tr>
<td align="left">frame_to_be_available_and_switch_to_it</td>
<td align="left">加载并切换</td>
</tr>
<tr>
<td align="left">invisibility_of_element_located</td>
<td align="left">节点不可见</td>
</tr>
<tr>
<td align="left">element_to_be_clickable</td>
<td align="left">节点可点击</td>
</tr>
<tr>
<td align="left">staleness_of</td>
<td align="left">判断一个节点是否仍在DOM，可以判断页面是否已经刷新</td>
</tr>
<tr>
<td align="left">element_to_be_selected</td>
<td align="left">节点可选择，传入节点对象</td>
</tr>
<tr>
<td align="left">element_located_to_be_selected</td>
<td align="left">节点可选择，传入定位元组</td>
</tr>
<tr>
<td align="left">element_selection_state_to_be</td>
<td align="left">传入节点对象以及状态，相等返回True，否则返回False</td>
</tr>
<tr>
<td align="left">element_located_selection_state_to_be</td>
<td align="left">传入定位元组以及状态，相等返回True，否则返回False</td>
</tr>
<tr>
<td align="left">alert_is_present</td>
<td align="left">是否出现警告</td>
</tr>
<tr>
<td align="left">关于更多等待条件的参数及用法，可以参考<a href="http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.support.expected_conditions">官方文档</a></td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="前进和后退"><a href="#前进和后退" class="headerlink" title="前进和后退"></a>前进和后退</h3><p>平常使用浏览器时都有前进和后退功能，Selenium也可以完成这个操作，它使用back()方法后退，使用forward()方法前进。示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Firefox()</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.taobao.com&#x27;</span>)</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.python.org&#x27;</span>)</span><br><span class="line">browser.back()</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">browser.forward()</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure>

<h3 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Firefox()</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.zhihu.com/explore&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(browser.get_cookies())    <span class="comment"># 获取cookie</span></span><br><span class="line">browser.add_cookie(&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;domain&#x27;</span>:<span class="string">&#x27;www.zhihu.com&#x27;</span>,<span class="string">&#x27;value&#x27;</span>:<span class="string">&#x27;germey&#x27;</span>&#125;) <span class="comment"># 添加cookie</span></span><br><span class="line"><span class="built_in">print</span>(browser.get_cookies())</span><br><span class="line">browser.delete_all_cookies()    <span class="comment"># 删除cookie</span></span><br><span class="line"><span class="built_in">print</span>(browser.get_cookies())</span><br></pre></td></tr></table></figure>

<h3 id="选项卡管理"><a href="#选项卡管理" class="headerlink" title="选项卡管理"></a>选项卡管理</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Firefox()</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)    <span class="comment"># 访问百度</span></span><br><span class="line">browser.execute_script(<span class="string">&#x27;window.open()&#x27;</span>) <span class="comment"># 调用execute_script()方法，执行java语句window.open()开启一个选项卡</span></span><br><span class="line"><span class="built_in">print</span>(browser.window_handles)   <span class="comment"># 调用window_handles属性获取当前开启的所有选项卡，返回的是选项卡代号列表</span></span><br><span class="line">browser.switch_to.window(browser.window_handles[<span class="number">1</span>]) <span class="comment"># 切换选项卡调用switch_to.window()方法，传入参数为选项卡代号</span></span><br><span class="line">browser.get(<span class="string">&quot;https://www.taobao.com&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">browser.switch_to.window(browser.window_handles[<span class="number">0</span>])</span><br><span class="line">browser.get(<span class="string">&quot;https://python.org&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> TimeoutException,NoSuchElementException</span><br><span class="line"></span><br><span class="line">browser = webdriver.Firefox()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    browser.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> TimeoutException:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;time out&quot;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    browser.find_element_by_id(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> NoSuchElementException:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;no element&quot;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    browser.close()</span><br></pre></td></tr></table></figure>
<p>更多异常类见<a href="http://selenium-python.readthedocs.io/api.html#module-selenium.common.exceptions">官方文档</a></p>
]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/2021/03/26/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><strong>字符串</strong>，简称<strong>串</strong>，一种特殊的线性表，表中的每个元素都是一个字符。一个串可以记为$S=”s_{0},s_{1},\dots,s_{n-1}”(n\geqslant 0)$,$S$是串的名字；字符序列$s_{0},s_{1},\dots,s_{n-1}$是串的值；字符个数称为串的长度。长度为0的串称为空串，写成s=””,与空白字符构成的串s=” “不同。</p>
<p><strong>子串</strong>，字符串$s1$中任意个连续的字符组成的子序列$s2$被称为是$s1$的字串，而称$s1$是$s2$的<strong>主串</strong>。空串是任意串的子串，除s外，s的其他子串称为s的真子串。子串在主串中的位置指：该子串的第一个字符在主串中的位置。</p>
<p>两个字符串相等：两个字符串长度相等，且各个对应位置上的字符都相同。</p>
<p>如果整个字符集上有全（线）序关系，则两个字符串之间有如下字典序关系：设$A=a_{0}a_{2}\dots a{n-1},B=b_{0}b_{2}\dots b_{m-1}$,则$A\lt B$: 若存在$k$使$a_{i}=b_{i}(i=0,1,\dots,k-1)$,但是$a_{k}\lt b_{k}$；或者$n&lt;m$,且$a_{i}=b_{i}(i=0,1,\dots,n-1)$。</p>
<h3 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ADT String is </span><br><span class="line">operations</span><br><span class="line">	<span class="function">String <span class="title">createNullStr</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">/*创建一个空串*/</span></span></span><br><span class="line"><span class="function">	<span class="keyword">int</span> <span class="title">IsNullStr</span><span class="params">(String s)</span><span class="comment">/*判断串s是否为空串，若为空串，则返回1，否则返回0*/</span></span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> <span class="title">length</span><span class="params">(String s)</span><span class="comment">/*返回串s的长度*/</span></span></span><br><span class="line"><span class="function">    String <span class="title">concat</span><span class="params">(String s1,String s2)</span><span class="comment">/*返回将串s1和s2拼接在一起构成的一个新串*/</span></span></span><br><span class="line"><span class="function">    String <span class="title">subStr</span><span class="params">(String s,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span><span class="comment">/*在串s中，求从串的第i个字符开始连续j个字符所构成的子串*/</span></span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> <span class="title">index</span><span class="params">(String s1,String s2)</span><span class="comment">/*如果串s2是s1的子串，则可求串s2在串s1中第一次出现的位置*/</span></span></span><br><span class="line"><span class="function">end ADT String</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<h3 id="字符串顺序实现"><a href="#字符串顺序实现" class="headerlink" title="字符串顺序实现"></a>字符串顺序实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SeqString</span> &#123;</span><span class="comment">/*顺序串的类型*/</span></span><br><span class="line">    <span class="keyword">int</span> MAXNUM; <span class="comment">/*串允许的最大字符个数*/</span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="comment">/*串的长度， n&lt;=MAXNUM*/</span></span><br><span class="line">    <span class="keyword">char</span> *c; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SeqString</span> * <span class="title">PSeqString</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建空顺序串</span></span><br><span class="line"><span class="function">PSeqString <span class="title">createNullStr_seq</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    PSeqString pstr = (PSeqString)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct SeqString));</span><br><span class="line">    <span class="keyword">if</span>(pstr!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        pstr-&gt;c = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*m);</span><br><span class="line">        <span class="keyword">if</span>(pstr-&gt;c)&#123;</span><br><span class="line">            pstr-&gt;n=<span class="number">0</span>;</span><br><span class="line">            pstr-&gt;MAXNUM=m;</span><br><span class="line">            <span class="keyword">return</span> pstr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">free</span>(pstr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Out of space!!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//求顺序表示的串的子串</span></span><br><span class="line"><span class="function">PSeqString <span class="title">subStr_seq</span><span class="params">(PSeqString s,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PSeqString s1;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    s1 = createNullStr_seq(j);<span class="comment">/*创建一个空串*/</span></span><br><span class="line">    <span class="keyword">if</span>(s1==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; i&lt;=s-&gt;n &amp;&amp; j&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s-&gt;n&lt;i+j<span class="number">-1</span>)</span><br><span class="line">            j=s-&gt;n-i+<span class="number">1</span>;<span class="comment">/*若从i开始取不了j个字符，则能取几个取几个*/</span></span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;j;k++)</span><br><span class="line">            s1-&gt;c[k] = s-&gt;c[i+k<span class="number">-1</span>];</span><br><span class="line">        s1-&gt;n = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串链接表示"><a href="#字符串链接表示" class="headerlink" title="字符串链接表示"></a>字符串链接表示</h3><p>在串的链接表示中，每个节点包含两个字段：字符和指针，分别用于存放字符和指向下一个节点的指针。这样一个串就可以用一个单链表来表示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StrNode</span>;</span> <span class="comment">/*链串的节点*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StrNode</span> * <span class="title">PStrNode</span>;</span><span class="comment">/*节点指针类型*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StrNode</span>&#123;</span><span class="comment">/*链串的节点结构*/</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    PStrNode link;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StrNode</span> * <span class="title">LinkString</span>;</span><span class="comment">/*链串的类型*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建带头结点的空链表</span></span><br><span class="line"><span class="function">LinkString <span class="title">createNullStr_link</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkString pst;</span><br><span class="line">    pst = (LinkString)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct StrNode));</span><br><span class="line">    <span class="keyword">if</span>(pst!=<span class="literal">NULL</span>)</span><br><span class="line">        pst-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Out of space!\n&quot;</span>);<span class="comment">/*创建失败*/</span></span><br><span class="line">    <span class="keyword">return</span> pst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求单链表表示的串的子串</span></span><br><span class="line"><span class="function">LinkString <span class="title">subStr_link</span><span class="params">(LinkString s,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    <span class="comment">/*求从s所指的带头结点的链串中第i(i&gt;0)个字符开始连续取j个字符所构成的子串。*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	LinkString s1;</span><br><span class="line">    PStrNode p,q,t;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    s1 = <span class="built_in">createNullStr_link</span>();</span><br><span class="line">    <span class="keyword">if</span>(s1==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Out of space!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || j&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> s1;<span class="comment">/*i,j值不合适，返回空串*/</span></span><br><span class="line">    p = s;<span class="comment">/*p为主串*/</span></span><br><span class="line">    <span class="keyword">for</span> (k=<span class="number">1</span>;k&lt;=i;k++)<span class="comment">/*找到第i个节点*/</span></span><br><span class="line">        <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">            p=p-&gt;link;</span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> s1;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    t=s1;<span class="comment">/*t为子串尾*/</span></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=i;k++)<span class="comment">/*连续取j个字符*/</span></span><br><span class="line">        <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q=(PStrNode)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct StrNode));</span><br><span class="line">            <span class="keyword">if</span>(q==<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Out of space!\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> s1;</span><br><span class="line">			&#125;</span><br><span class="line">            q-&gt;c = p-&gt;c;</span><br><span class="line">            q-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">            t-&gt;link=q;<span class="comment">/*将节点放入子链串中*/</span></span><br><span class="line">            t = q;</span><br><span class="line">            p=p-&gt;link;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> s1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//朴素的模式匹配</span></span><br><span class="line"><span class="comment">/*求串p在串t中第一次出现的位置，即p的第一个元素在串t中的序号（下表+1）*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">index</span><span class="params">(PSeqString t,PSeqString p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;<span class="comment">/*初始化*/</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; p-&gt;n &amp;&amp; j &lt; t-&gt;n)<span class="comment">/*反复比较*/</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;c[i] == t-&gt;c[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;++j;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        j = j-i+<span class="number">1</span>;</span><br><span class="line">        i=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*i,j值回溯，再开始下一位置的匹配*/</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=p-&gt;n)</span><br><span class="line">        <span class="keyword">return</span> (j-p-&gt;n+<span class="number">1</span>);<span class="comment">/*匹配成功*/</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">/*匹配失败*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无回溯的模式匹配算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pMatch</span><span class="params">(PSeqString t,PSeqString p,<span class="keyword">int</span> * next)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;<span class="comment">/*初始化*/</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;p-&gt;n &amp;&amp; j&lt;t-&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">  		<span class="comment">/*反复比较*/</span></span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">-1</span> || p-&gt;c[i]==t-&gt;c[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;j++;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = next[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= p-&gt;n)</span><br><span class="line">        <span class="keyword">return</span> (j-p-&gt;n+<span class="number">1</span>);<span class="comment">/*匹配成功，返回p中第一个字符在t中的序号*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">/*匹配失败*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算next数组</span></span><br><span class="line"><span class="comment">/*next是指向next数组的指针参数*/</span></span><br><span class="line"><span class="built_in">makeNext</span>(PSeqString p,<span class="keyword">int</span> * next)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,k=<span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; p-&gt;n <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*计算next[i+1]*/</span></span><br><span class="line">        <span class="keyword">while</span>(k&gt;=<span class="number">0</span> &amp;&amp; p-&gt;c[i]!=p-&gt;c[k])</span><br><span class="line">            k = next[k];</span><br><span class="line">        i++;k++;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;c[i]==p-&gt;c[k])</span><br><span class="line">            next[i] = next[k];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            next[i]=k;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2021/03/26/%E6%A0%88/</url>
    <content><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>栈</strong>是一种特殊的线性表，它所有的插入和删除都限制在表的同一端及逆行，表重允许进行插入、删除操作的一端叫做栈的<strong>顶</strong>，表中的另一端叫做栈的<strong>底</strong>，当栈中没有元素时，称之为<strong>空栈</strong>，栈的插入运算通常称为<strong>进栈</strong>或<strong>入栈</strong>，栈的删除运算通常称为<strong>退栈</strong>或<strong>出栈</strong>。</p>
<img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20200326004247.png"/>

<h3 id="抽象数据结构"><a href="#抽象数据结构" class="headerlink" title="抽象数据结构"></a>抽象数据结构</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ADT Stack is</span><br><span class="line">    operation</span><br><span class="line">    <span class="function">Stack <span class="title">createEmptyStack</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">/*创建一个空栈*/</span></span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> <span class="title">isEmptyStack</span><span class="params">(Stack st)</span><span class="comment">/*判断栈st是否为空*/</span></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">push</span><span class="params">(Stack st,DataType x)</span><span class="comment">/*往栈st的栈顶插入一个值为x的元素*/</span></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">pop</span><span class="params">(Stack st)</span><span class="comment">/*从栈st的栈顶删除一个元素*/</span></span></span><br><span class="line"><span class="function">    DataType <span class="title">top</span><span class="params">(Stack st)</span><span class="comment">/*求栈顶元素的值*/</span></span></span><br><span class="line"><span class="function">end ADT Stack</span></span><br></pre></td></tr></table></figure>

<h3 id="栈的顺序实现"><a href="#栈的顺序实现" class="headerlink" title="栈的顺序实现"></a>栈的顺序实现</h3><p>用顺序的方式表示栈时，栈的类型可定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SeqStack</span>&#123;</span><span class="comment">/*顺序栈类型定义*/</span></span><br><span class="line">    <span class="keyword">int</span> MAXNUM;<span class="comment">/*栈中最大元素个数*/</span></span><br><span class="line">    <span class="keyword">int</span> t;<span class="comment">/*t&lt;MAXNUM,指示栈顶位置，而不是元素个数*/</span></span><br><span class="line">    DataType *s;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SeqStack</span> * <span class="title">PSeqStack</span>;</span><span class="comment">/*顺序栈指针类型*/</span></span><br></pre></td></tr></table></figure>

<p>由于栈是一个动态结构，而数组是静态结构，因此会出现溢出问题。当栈中已经有MAXNUM个元素时，如果再做进栈运算，则会产生溢出，通常称为上溢（overflow），而对空栈进行出栈运算时也会产生溢出，通常称为下溢（underflow)。</p>
<h4 id="进栈运算"><a href="#进栈运算" class="headerlink" title="进栈运算"></a>进栈运算</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_seq</span><span class="params">(PSeqStack pastack,DataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*在栈内压入一个元素*/</span></span><br><span class="line">    <span class="keyword">if</span>(pastack-&gt;t &gt;= MAXNUM<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Overflow!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pastack-&gt;t = pastack-&gt;t+<span class="number">1</span>;</span><br><span class="line">        pastack-&gt;s[pastack-&gt;t] = x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="出栈运算"><a href="#出栈运算" class="headerlink" title="出栈运算"></a>出栈运算</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_seq</span><span class="params">(PSeqStack pastack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*删除栈顶元素*/</span></span><br><span class="line">    <span class="keyword">if</span>(pastack-&gt;t == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Underflow!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pastack-&gt;t = pastack-&gt;t<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="取栈顶元素"><a href="#取栈顶元素" class="headerlink" title="取栈顶元素"></a>取栈顶元素</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">DataType <span class="title">top_seq</span><span class="params">(PSeqStack pastack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*当pastack所指的栈不为空栈时，求栈顶元素的值*/</span></span><br><span class="line">    <span class="keyword">if</span>(pastack-&gt;t == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;It is empty!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in"><span class="keyword">return</span></span> (pastack-&gt;s[pastack-&gt;t]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链接表示"><a href="#链接表示" class="headerlink" title="链接表示"></a>链接表示</h3><p>每个节点的结构可以定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span><span class="comment">/*单链表节点*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">PNode</span>;</span><span class="comment">/*指向节点的指针类型*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*单链表节点定义*/</span></span><br><span class="line">    DataType info;</span><br><span class="line">    Pnode link;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*为了强调栈顶是栈的一个属性，对栈增加了一层封装，引入LinkList结构的定义*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkStack</span>/*链接栈类型定义*/</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PNode top;<span class="comment">/*指向栈顶节点*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkStack</span> *<span class="title">PLinkStack</span>;</span></span><br><span class="line"><span class="comment">/*链接栈类型的指针类型*/</span></span><br></pre></td></tr></table></figure>

<h4 id="创建空链接栈"><a href="#创建空链接栈" class="headerlink" title="创建空链接栈"></a>创建空链接栈</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">PLinkStack <span class="title">createEmptyStack_link</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PLinkStack plstack;</span><br><span class="line">    plstack = (PLinkStack)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LinkStack));</span><br><span class="line">    <span class="keyword">if</span>(plstack != <span class="literal">NULL</span>)</span><br><span class="line">        plstack-&gt;top = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Out of space!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> plstack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断栈是否为空"><a href="#判断栈是否为空" class="headerlink" title="判断栈是否为空"></a>判断栈是否为空</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isEmptyStack_link</span><span class="params">(PLinkStack plstack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (plstack-&gt;top==<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="进栈运算-1"><a href="#进栈运算-1" class="headerlink" title="进栈运算"></a>进栈运算</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_link</span><span class="params">(PLinkStack plstack,DataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PNode p;</span><br><span class="line">    p = (PNode)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct Node));</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Out of space!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;info=x;</span><br><span class="line">        p-&gt;link=plstack-&gt;top;</span><br><span class="line">        plstack-&gt;top=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="出栈运算-1"><a href="#出栈运算-1" class="headerlink" title="出栈运算"></a>出栈运算</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_link</span><span class="params">(PLinkStack plstack)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PNode p;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isEmptyStack_link</span>(plstack))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Empty stack pop!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        p=plstack-&gt;top;</span><br><span class="line">        plstack-&gt;top = plstack-&gt;top-&gt;link;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="取栈顶元素-1"><a href="#取栈顶元素-1" class="headerlink" title="取栈顶元素"></a>取栈顶元素</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">DataType <span class="title">top_link</span><span class="params">(PLinkStack plstack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pastack-&gt;top == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in"><span class="keyword">return</span></span> (plstack-&gt;top-&gt;info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表c</title>
    <url>/2021/03/26/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="线性表的抽象数据类型"><a href="#线性表的抽象数据类型" class="headerlink" title="线性表的抽象数据类型"></a>线性表的抽象数据类型</h2><p>线性表（简称为表）是零个或多个元素的有穷序列。</p>
<p>$L=(k_{0},k_{1},\dots,k_{n-1})$</p>
<p>线性表的逻辑结构：$L=&lt;K,R&gt;$</p>
<p>其中$K={k_{0},k_{1},\dots,k_{n-1}}$,$R={&lt;k_{i},k_{i+1}&gt;|0\le i\le n-2}$,$i$称为元素$k_{i}$的<strong>索引</strong>或<strong>下标</strong>，表中的元素又称<strong>表目</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADT List is</span><br><span class="line">    operations</span><br><span class="line">    <span class="function">List <span class="title">createNullList</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">//创建并返回一个空线性表</span></span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> <span class="title">insertPre</span><span class="params">(List <span class="built_in">list</span>,position p,DataType x)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//在list中p位置前插入值为x的元素，并返回插入成功与否的标志</span></span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> <span class="title">insertPost</span><span class="params">(List <span class="built_in">list</span>, position p,DataType x)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//在list中p位置后插入值为x的元素，并返回插入成功与否的标志</span></span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> <span class="title">deleteV</span><span class="params">(List <span class="built_in">list</span>,DataType x)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//在list中删除一个值为x的元素，并返回删除成功与否的标志</span></span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> <span class="title">deleteP</span><span class="params">(List <span class="built_in">list</span>,position p)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//在list中删除位置为p的元素，并返回删除成功与否的标志</span></span></span><br><span class="line"><span class="function">    Position <span class="title">locate</span><span class="params">(List <span class="built_in">list</span>,DataType x)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//在list中查找值为x的元素的位置</span></span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> <span class="title">isNLL</span><span class="params">(List <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//判断list是否为空线性表</span></span></span><br><span class="line"><span class="function">end ADT List</span>;</span><br></pre></td></tr></table></figure>



<h2 id="顺序表的c语言描述"><a href="#顺序表的c语言描述" class="headerlink" title="顺序表的c语言描述"></a>顺序表的c语言描述</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SeqList</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> MAXNUM;<span class="comment">//顺序表可以存放的元素个数</span></span><br><span class="line">    <span class="keyword">int</span> n;<span class="comment">//实际存放在线性表中元素的个数</span></span><br><span class="line">    DataType * element;<span class="comment">//element[0],……,element[n-1]存放线性表中的元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SeqList</span> *<span class="title">PSeqList</span>;</span></span><br><span class="line"><span class="comment">/*如果palist是一个PSeqList类型的指针变量，则：</span></span><br><span class="line"><span class="comment">palist-&gt;MAXNUM：顺序表中可以存放元素的个数；</span></span><br><span class="line"><span class="comment">palist-&gt;n:顺序表中实际元素的个数</span></span><br><span class="line"><span class="comment">palist-&gt;element[0],……,palist-&gt;element[n-1]:顺序表中的各个元素*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序表的基本操作</span></span><br><span class="line"><span class="comment">//创建空顺序表</span></span><br><span class="line"><span class="function">PSeqList <span class="title">createNullList_seq</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*创建新的顺序表*/</span></span><br><span class="line">    PSeqList palist = (PSeqList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct SeqList));</span><br><span class="line">    <span class="keyword">if</span> (palist!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        palist-&gt;element=(DataType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DataType)*m);</span><br><span class="line">        <span class="keyword">if</span>(palist&gt;element)&#123;</span><br><span class="line">            palist-&gt;MAXNUM=m;</span><br><span class="line">            palist-&gt;n=<span class="number">0</span>;<span class="comment">/*空表长度为0*/</span></span><br><span class="line">            <span class="keyword">return</span> palist;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">free</span> palist;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Out of space!\n&quot;</span>);<span class="comment">/*存储分配失败*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断线性表是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isNullList_seq</span><span class="params">(PSeqList palist)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*判别palist所指顺序表是否为空表*/</span></span><br><span class="line">    <span class="keyword">return</span> (palist-&gt;n==<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在顺序表中求某元素的下标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">locate_seq</span><span class="params">(PSeqList palist,DataType x)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*求x在palist所指顺序表中的下标*/</span></span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="keyword">for</span> (q=<span class="number">0</span>;q&lt;palist-&gt;n;q++)</span><br><span class="line">        <span class="keyword">if</span> (palist-&gt;element[q]==x)</span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序表的插入</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insertPre_seq</span><span class="params">(PSeqList palist,<span class="keyword">int</span> p,DataType x)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*在palist所指顺序表中下标为p的元素之前插入元素x*/</span></span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="keyword">if</span> (palist-&gt;n &gt;= palist-&gt;MAXNUM)&#123; <span class="comment">/*溢出*/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Overflow!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p&lt;<span class="number">0</span> || p&gt;palist-&gt;n)&#123;  <span class="comment">/*不存在下表为p的元素*/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not Exist!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(q=palist-&gt;n<span class="number">-1</span>;q&gt;=p;q--) <span class="comment">/*插入位置及之后的元素均后移一个位置*/</span></span><br><span class="line">        palist-&gt;element[q+<span class="number">1</span>] = palist-&gt;element[q];</span><br><span class="line">    palist-&gt;element[p]=x;  <span class="comment">/*插入元素x*/</span></span><br><span class="line">    palist-&gt;n=palist-&gt;n+<span class="number">1</span>; <span class="comment">/*元素个数加1*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序表中按下标删除元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteP_seq</span><span class="params">(PSeqList palist,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*在palist所指顺序表中删除下标为p的元素*/</span></span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="keyword">if</span> (p&lt;<span class="number">0</span>||p&gt;palist-&gt;n<span class="number">-1</span>)&#123; <span class="comment">/*不存在下标志为p的元素*/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not exist!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(q=p;q&lt;palist-&gt;n<span class="number">-1</span>;p++)&#123; <span class="comment">/*被删除元素之后的元素均前移一个位置*/</span></span><br><span class="line">        palist-&gt;element[q]=palist-&gt;element[q+<span class="number">1</span>];</span><br><span class="line">   	palist-&gt;n=palist-&gt;n<span class="number">-1</span>;  <span class="comment">/*元素个数减1*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序表中按值删除元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteV_seq</span><span class="params">(PSeqList palist,DataType x)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*实现的算法只要首先调用locate_seq(palist,x),在palist所指顺序表中寻找一个值为x的元素的下标，假设为p，然后调用deleteP_seq(palist,p)即可*/</span></span><br><span class="line">    p=locate_seq(palist,x);</span><br><span class="line">    deleteP_seq(palist,p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单链表的C语言描述"><a href="#单链表的C语言描述" class="headerlink" title="单链表的C语言描述"></a>单链表的C语言描述</h2><p>每个节点包括两个域：</p>
<ol>
<li><p>数据域：存放元素本身信息。</p>
</li>
<li><p>指针域：存放其后继节点的存储位置</p>
<p>（1）最后一个元素的指针不指向任何节点，称为空指针，用“NULL”表示；</p>
<p>（2）指向链表中第一个节点的指针称为这个链表的头指针。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span>	<span class="comment">//单链表节点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">PNode</span>;</span> <span class="comment">//节点指针类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span>	<span class="comment">//单链表节点结构</span></span><br><span class="line">    DataType info;</span><br><span class="line">    PNode link;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">LinkList</span>;</span>	<span class="comment">/*单链表类型*/</span></span><br><span class="line">LinkList llist;	<span class="comment">/*llist是一个链表的头指针*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个带头结点的空单链表</span></span><br><span class="line"><span class="function">LinkList <span class="title">createNullList_link</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    LinkList llist;</span><br><span class="line">    <span class="comment">//申请头节点空间</span></span><br><span class="line">    llist = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">    <span class="keyword">if</span> (llist!=<span class="literal">NULL</span>)</span><br><span class="line">        llist-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Out of space!\n&quot;</span>);<span class="comment">//创建失败</span></span><br><span class="line">    <span class="keyword">return</span> llist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断单链表是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isNullList_link</span><span class="params">(LinkList llist)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (llist-&gt;link==<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/*因为llist指向头节点，总是非空，所以算法中只要检查llist-&gt;link是否为空即可*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在带头节点的单链表llist中找第一个值为x的节点存储位置</span></span><br><span class="line"><span class="function">PNode <span class="title">locate_link</span><span class="params">(LinkList llist, Datatype x)</span></span>&#123;</span><br><span class="line">    PNode p;</span><br><span class="line">    <span class="keyword">if</span> (llist==<span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//找不到时返回空指针</span></span><br><span class="line">    p = llist-&gt;link;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; p-&gt;info!=x)</span><br><span class="line">        p=p-&gt;link;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在带头结点的单链表llist中下表为p的节点后插入值为x的新节点*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insertPost_link</span><span class="params">(LinkList llist,PNode p,Datatype x)</span></span>&#123;</span><br><span class="line">    PNode q = (PNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Struct Node)); <span class="comment">/*申请新节点*/</span></span><br><span class="line">    <span class="keyword">if</span> (q==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Out of space!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        q-&gt;info = x;</span><br><span class="line">        q-&gt;link = p-&gt;link;<span class="comment">/*注意指针更新次序*/</span></span><br><span class="line">        p-&gt;link = q;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在单链表中求p所指节点的前驱</span></span><br><span class="line"><span class="function">PNode <span class="title">locatePre_link</span><span class="params">(LinkList llist, PNode p)</span></span>&#123;</span><br><span class="line">    PNode p1;</span><br><span class="line">    <span class="keyword">if</span>(llist==<span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    p1 = llist;</span><br><span class="line">    <span class="keyword">while</span>(p1!=<span class="literal">NULL</span> &amp;&amp; p1-&gt;link!=p)</span><br><span class="line">        p1 = p1-&gt;link;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在带头结点的单链表llist中，删除第一个元素值为x的节点（这里要求DataType可以使用！=比较）*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteV_link</span><span class="params">(LinkList llist,DataType x)</span></span>&#123;</span><br><span class="line">    PNode p,q;</span><br><span class="line">    p = llist;</span><br><span class="line">    <span class="keyword">if</span> (p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;link != <span class="literal">NULL</span> &amp;&amp; p-&gt;link-&gt;info!=x)</span><br><span class="line">        p = p-&gt;link;<span class="comment">/*找到值为x的节点的前驱节点的存储位置*/</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;link == <span class="literal">NULL</span>)&#123;<span class="comment">/*没有找到值为x的节点*/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not exists!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        q = p-&gt;link;<span class="comment">/*找到值为x的节点*/</span></span><br><span class="line">        p-&gt;link = q-&gt;link;<span class="comment">/*删除该节点*/</span></span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>队列</title>
    <url>/2021/03/26/%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="队列学习笔记"><a href="#队列学习笔记" class="headerlink" title="队列学习笔记"></a>队列学习笔记</h2><h3 id="队列及其抽象数据类型"><a href="#队列及其抽象数据类型" class="headerlink" title="队列及其抽象数据类型"></a>队列及其抽象数据类型</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>队列</strong>是一种只允许在表的一端进行插入操作，而在另一端进行删除操作的线性表（<em><strong>先进先出表</strong></em>）。允许进行删除的这一段叫做队列的<strong>头</strong>，允许进行插入的这一端叫做队列的<strong>尾</strong>。当队列中没有任何元素时，称为<strong>空队列</strong>。队列的插入操作通常称为<strong>进队列</strong>或<strong>入队列</strong>，队列的删除操作通常称为<strong>退队列</strong>或<strong>出队列</strong>。</p>
<h4 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADT Queue is</span><br><span class="line">    operations</span><br><span class="line">    <span class="function">Queue <span class="title">createEmptyQueue</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">/*创建一个空队列*/</span></span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> <span class="title">isEmptyQueue</span><span class="params">(Queue qu)</span><span class="comment">/*判断队列qu是否为空队列*/</span></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(Queue qu,DataType x)</span></span></span><br><span class="line"><span class="function">    <span class="comment">/*往队列qu尾部插入一个值为x的元素*/</span></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">deQueue</span><span class="params">(Queue qu)</span></span></span><br><span class="line"><span class="function">    <span class="comment">/*往队列qu头部删除一个元素*/</span></span></span><br><span class="line"><span class="function">    DataType <span class="title">frontQueue</span><span class="params">(Queue qu)</span></span></span><br><span class="line"><span class="function">    <span class="comment">/*求队列qu头部元素的值*/</span></span></span><br><span class="line"><span class="function">end ADT Queue</span></span><br></pre></td></tr></table></figure>

<h3 id="队列的顺序表示"><a href="#队列的顺序表示" class="headerlink" title="队列的顺序表示"></a>队列的顺序表示</h3><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SeqQueue</span>&#123;</span><span class="comment">/*顺序队列类型定义*/</span></span><br><span class="line">    <span class="keyword">int</span> MAXNUM;	<span class="comment">/*队列中最大元素个数*/</span></span><br><span class="line">    <span class="keyword">int</span> f,r;	<span class="comment">/*f指出实际队头元素所在的位置，r指出实际队尾元素所在位置的下一个位置*/</span></span><br><span class="line">    DataType *q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SeqQueue</span> * <span class="title">PSeqQueue</span>;</span></span><br><span class="line"><span class="comment">/*顺序队列类型的指针类型*/</span></span><br></pre></td></tr></table></figure>

<p>假设<code>paqu</code>是<code>PSeqQueue</code>类型的变量,则：</p>
<ol>
<li><code>paqu-&gt;f</code>存放即将要被删除的元素的下标</li>
<li><code>paqu-&gt;r</code>存放即将要被插入的元素的下标</li>
<li><code>paqu-&gt;q[paqu-&gt;f]</code>表示当前队列头部的元素</li>
<li><code>paqu-&gt;q[paqu-&gt;r]</code>表示当前队列尾部的（即将插入的）的元素</li>
<li>初始时<code>paqu-&gt;f=paqu-&gt;r=0</code></li>
<li>当前队列中元素个数为<code>paqu-&gt;r-paqu-&gt;f</code></li>
<li>当<code>paqu-&gt;r=paqu-&gt;f</code>时，元素的个数为0，即为空队列。</li>
</ol>
<h4 id="队列溢出"><a href="#队列溢出" class="headerlink" title="队列溢出"></a>队列溢出</h4><p>在队列中，由于数组是静态结构，而队列是动态结构，可能出现队列溢出问题。当队列满时，再作进队操作，这种现象称为<strong>上溢</strong>，当对空时，作删除操作，这种现象称为<strong>下溢</strong>。</p>
<p>由于队列中经常要执行插入和删除运算，而每运行一次插入或删除，<code>paqu-&gt;r</code>或<code>paqu-&gt;f</code>就增加1，使得队列中的元素被删除后，其空间就永远使用不到了，当<code>paqu-&gt;r=MAXNUM</code>时，再作插入运算就会产生溢出，而实际上这时队列的前端可能还有许多可用的位置，因此，这种现象称为<strong>假溢出</strong>。</p>
<h4 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h4><p>解决假溢出通常采用的方法是：把数组<code>paqu-&gt;q[MAXNUM]</code>从逻辑上看成一个环，这种队列也成为<strong>环形队列</strong>。当表中已有<code>MAXNUM-1</code>个节点时，如果还要插入，<code>paqu-&gt;r</code>和<code>paqu-&gt;f</code>就会重合，这与空队列的情形相同，为了区分空队列与满队列两种情况的环形队列，一般是牺牲队列中的一个节点，当的队列中已有<code>MAXNUM-1</code>个节点时就称为满，再要插入就发生溢出。</p>
<h4 id="基本运算的实现"><a href="#基本运算的实现" class="headerlink" title="基本运算的实现"></a>基本运算的实现</h4><h5 id="创建一个空队列"><a href="#创建一个空队列" class="headerlink" title="创建一个空队列"></a>创建一个空队列</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*创建一个空队列*/</span></span><br><span class="line"><span class="function">PSeqQueue  <span class="title">createEmptyQueue_seq</span><span class="params">( <span class="keyword">void</span> )</span> </span>&#123;  </span><br><span class="line">    PSeqQueue paqu = (PSeqQueue)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct SeqQueue));</span><br><span class="line">    <span class="keyword">if</span> (paqu==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Out of space!! \n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        paqu-&gt;f = paqu-&gt;r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> paqu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="判断队列是否为空"><a href="#判断队列是否为空" class="headerlink" title="判断队列是否为空"></a>判断队列是否为空</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*判队列是否为空队列*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">isEmptyQueue_seq</span><span class="params">( PSeqQueue paqu )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> paqu-&gt;f == paqu-&gt;r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="进队运算"><a href="#进队运算" class="headerlink" title="进队运算"></a>进队运算</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enQueue_seq</span><span class="params">(PSeqQueue paqu, DataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*再队尾插入元素x*/</span></span><br><span class="line">    <span class="keyword">if</span>((paqu-&gt;r + <span class="number">1</span>)%MAXNUM == paqu-&gt;f)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Full Queue!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        paqu-&gt;q[paqu-&gt;r] = x;</span><br><span class="line">        paqu-&gt;r = (paqu-&gt;r+<span class="number">1</span>)%MAXNUM;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="出队运算"><a href="#出队运算" class="headerlink" title="出队运算"></a>出队运算</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deQueue_seq</span><span class="params">(PSeqQueue paqu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*删除队列头部元素*/</span></span><br><span class="line">    <span class="keyword">if</span>(paqu-&gt;f == paqu-&gt;r)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Empty Queue.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        paqu-&gt;f = (paqu-&gt;f+<span class="number">1</span>)%MAXNUM;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="取队列头部元素运算"><a href="#取队列头部元素运算" class="headerlink" title="取队列头部元素运算"></a>取队列头部元素运算</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DataType <span class="title">fromtQueue_seq</span><span class="params">(PSeqQueue paqu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(paqu-&gt;f == paqu-&gt;r)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Empty Queue.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (paqu-&gt;q[paqu-&gt;f]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="队列的链接表示"><a href="#队列的链接表示" class="headerlink" title="队列的链接表示"></a>队列的链接表示</h3><h4 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h4><p>队列的链接表示就是用一个单链表来表示队列，队列中的每个元素对应链表中的一个结点，结点的结构与单链表中结点的结构一样。为了强调队头和队尾都是队列的属性，对队列增加了一层封裝，引入 <code>LinkQueue</code>结构的定义。这样存储的队列简称<strong>链接队列</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">PNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span><span class="comment">/*节点结构*/</span></span><br><span class="line">    DataType info;</span><br><span class="line">    PNode link;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkQueue</span>&#123;</span><span class="comment">/*链接队列类型定义*/</span></span><br><span class="line">	PNode f;	<span class="comment">/*头指针*/</span></span><br><span class="line">	PNode r;	<span class="comment">/*尾指针*/</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkQueue</span> * <span class="title">PLinkQueue</span>;</span></span><br><span class="line"><span class="comment">/*链接队列类型的指针类型*/</span></span><br></pre></td></tr></table></figure>

<p>假设<code>plqu</code>是<code>PLinkQueue</code>类型的变量，则：</p>
<ol>
<li><code>plqu-&gt;f</code>为队列的头指针，指向队列中第一个节点</li>
<li><code>plqu-&gt;r</code>是队列的尾指针，指向队列中<em>最后一个节点</em></li>
<li>当<code>plqu-&gt;f</code>或<code>plqu-&gt;r</code>为NULL时队列为空</li>
</ol>
<h4 id="基本运算的实现-1"><a href="#基本运算的实现-1" class="headerlink" title="基本运算的实现"></a>基本运算的实现</h4><h5 id="创建空队列"><a href="#创建空队列" class="headerlink" title="创建空队列"></a>创建空队列</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">PLinkQueue <span class="title">createEmptyQueue_link</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    PLinkQueue plqu;</span><br><span class="line">    plqu = (PLinkQueue)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LinkQueue));</span><br><span class="line">    <span class="keyword">if</span> (plqu != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        plqu-&gt;f = <span class="literal">NULL</span>;</span><br><span class="line">        plqu-&gt;r = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Out of Space!!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> plqu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="判断队列是否为空-1"><a href="#判断队列是否为空-1" class="headerlink" title="判断队列是否为空"></a>判断队列是否为空</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isEmptyQueue_link</span><span class="params">(PLinkQueue plqu)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (plqu-&gt;f == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="进队列运算"><a href="#进队列运算" class="headerlink" title="进队列运算"></a>进队列运算</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enQueue_link</span><span class="params">(PLinkQueue plqu,DataType x)</span></span>&#123;</span><br><span class="line">    PNode p;</span><br><span class="line">    p = (PNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">    <span class="comment">/*申请新节点空间*/</span></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)<span class="comment">/*申请新节点失败*/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;out of space!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;info = x;</span><br><span class="line">        p-&gt;link = <span class="literal">NULL</span>;<span class="comment">/*填写新节点信息*/</span></span><br><span class="line">        <span class="keyword">if</span>(plqu-&gt;f == <span class="literal">NULL</span>)<span class="comment">/*插入前是空队列*/</span></span><br><span class="line">            plqu-&gt;f = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            plqu-&gt;r-&gt;link = p <span class="comment">/*将新节点插入*/</span></span><br><span class="line">        plqu-&gt;r = p;<span class="comment">/*修改队尾指针*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="出队列运算"><a href="#出队列运算" class="headerlink" title="出队列运算"></a>出队列运算</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deQueue_link</span><span class="params">(PLinkQueue plqu)</span></span>&#123;</span><br><span class="line">    PNode p;</span><br><span class="line">    <span class="keyword">if</span>(plqu-&gt;f==<span class="literal">NULL</span>)<span class="comment">/*队列已空*/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Empty queue.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = plqu-&gt;f;</span><br><span class="line">        plqu-&gt;f = p-&gt;link;<span class="comment">/*修改对头指针*/</span></span><br><span class="line">        <span class="built_in">free</span>(p);<span class="comment">/*释放已经删除节点空间*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="取队列头部元素的值"><a href="#取队列头部元素的值" class="headerlink" title="取队列头部元素的值"></a>取队列头部元素的值</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DataType <span class="title">frontQueue_link</span><span class="params">(PLinkQueue plqu)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (plqu-&gt;f == <span class="literal">NULL</span>)<span class="comment">/*队列已空*/</span></span><br><span class="line">       	<span class="built_in">printf</span>(<span class="string">&quot;Empty queue\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (plqu-&gt;f-&gt;info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>黄金矿工easyx</title>
    <url>/2021/03/26/GoldMiner/</url>
    <content><![CDATA[<p>《高级语言程序课设》课设作业，基于easyx模拟黄金矿工，是我的第一个编程项目，虽然很简单而且存在很多问题，但还是把代码留存吧。</p>
<h4 id="GoldMiner-h"><a href="#GoldMiner-h" class="headerlink" title="GoldMiner.h"></a>GoldMiner.h</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;easyx.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;graphics.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;Winmm.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDTH 850</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEIGHT 700</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.1415926</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>; <span class="comment">//初始化图形界面</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawAlpha</span><span class="params">(IMAGE* picture, <span class="keyword">int</span>  picture_x, <span class="keyword">int</span> picture_y)</span></span>;<span class="comment">//载入PNG图片，并去除空白部分</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span>;<span class="comment">//获取用户名和密码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>; <span class="comment">//登陆</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;	<span class="comment">//开始游戏界面</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gameGUI</span><span class="params">()</span></span>; <span class="comment">//游戏界面</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hook</span><span class="params">()</span></span>;	<span class="comment">//钩子</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateWithoutInput</span><span class="params">()</span></span>; <span class="comment">//与用户输入无关的更新</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateWithInput</span><span class="params">()</span></span>; <span class="comment">//与用户输入有关的更新</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span></span>;	<span class="comment">//游戏部分</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gameOver</span><span class="params">()</span></span>;	<span class="comment">//游戏结束</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="GoldMiner-cpp"><a href="#GoldMiner-cpp" class="headerlink" title="GoldMiner.cpp"></a>GoldMiner.cpp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS	</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;GoldMiner.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************结构体及变量定义************************************/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span> <span class="comment">//矿石边缘</span></span><br><span class="line">	<span class="keyword">int</span> left;</span><br><span class="line">	<span class="keyword">int</span> top;</span><br><span class="line">	<span class="keyword">int</span> right;</span><br><span class="line">	<span class="keyword">int</span> bottom;</span><br><span class="line">&#125;EDGE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">thing</span> &#123;</span> <span class="comment">//矿石结构体</span></span><br><span class="line">	IMAGE img;</span><br><span class="line">	<span class="keyword">int</span> x; <span class="comment">//左上角横坐标</span></span><br><span class="line">	<span class="keyword">int</span> y; <span class="comment">//左上角纵坐标</span></span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">1</span>; <span class="comment">//矿石状态</span></span><br><span class="line">	<span class="keyword">int</span> score; <span class="comment">//分数</span></span><br><span class="line">	<span class="keyword">int</span> weight; <span class="comment">//重量</span></span><br><span class="line">	EDGE e; <span class="comment">//边缘（左，上，右，下）</span></span><br><span class="line">&#125;TH;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">users</span> &#123;</span> <span class="comment">//定义用户结构体</span></span><br><span class="line">	<span class="keyword">char</span> id[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">char</span> pwd[<span class="number">20</span>];</span><br><span class="line">&#125;USERS;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span> <span class="comment">/*单链表节点结构*/</span></span><br><span class="line">	TH *info;	<span class="comment">/*存储地址，直接存储值会抛出异常*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">link</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">LinkList</span>;</span> <span class="comment">/*单链表类型*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> centerx = <span class="number">400</span>, centery = <span class="number">150</span>;	<span class="comment">//钩子旋转中心坐标</span></span><br><span class="line"><span class="keyword">int</span> hookx = <span class="number">390</span>, hooky = <span class="number">155</span>;		<span class="comment">//钩子顶点坐标</span></span><br><span class="line"><span class="keyword">int</span> r = <span class="number">30</span>, angle = <span class="number">0</span>;				<span class="comment">//钩子转动半径、角度</span></span><br><span class="line"><span class="keyword">int</span> angle_v = <span class="number">1</span>, dig_v = <span class="number">5</span>;			<span class="comment">//钩子转动速度、挖矿速度</span></span><br><span class="line"><span class="keyword">int</span> flag_dig = <span class="number">0</span>;					<span class="comment">//是否向下挖</span></span><br><span class="line"><span class="keyword">int</span> number = <span class="number">0</span>,money=<span class="number">0</span>, count = <span class="number">0</span>;			<span class="comment">//抓到矿石个数、金钱、简单倒计时所用常量</span></span><br><span class="line"><span class="keyword">int</span> num_s = <span class="number">0</span>, num_d = <span class="number">0</span>, num_g = <span class="number">0</span>; <span class="comment">//存储抓取到的石头、钻石、金子个数</span></span><br><span class="line"><span class="keyword">int</span> checkpoint = <span class="number">1</span>;			<span class="comment">//关卡</span></span><br><span class="line"><span class="keyword">int</span> retime = <span class="number">0</span>;					<span class="comment">//倒计时</span></span><br><span class="line"><span class="keyword">int</span> target_money = <span class="number">1000</span>;			<span class="comment">//目标金币</span></span><br><span class="line">TH prop1[<span class="number">10</span>];						<span class="comment">//加载矿石</span></span><br><span class="line">IMAGE temp2;	<span class="comment">//用于钩子抓取到矿石后收回</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************链表相关函数***************************************/</span></span><br><span class="line"><span class="function">LinkList <span class="title">createNullList_link</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;<span class="comment">/*创建空链表*/</span></span><br><span class="line">	LinkList llist = (LinkList)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct Node)); <span class="comment">/*申请表头节点空间*/</span></span><br><span class="line">	llist-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> llist;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="function">LinkList <span class="title">createNode</span><span class="params">(TH* data)</span> </span>&#123; <span class="comment">/*创建节点*/</span></span><br><span class="line">	LinkList newNode = (LinkList)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct Node));</span><br><span class="line">	newNode-&gt;info = data;</span><br><span class="line">	newNode-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertNodeByHead</span><span class="params">(LinkList headNode, TH* data)</span> </span>&#123; <span class="comment">//插入节点，头插法</span></span><br><span class="line">	LinkList newNode = <span class="built_in">createNode</span>(data);</span><br><span class="line">	newNode-&gt;link = headNode-&gt;link;</span><br><span class="line">	headNode-&gt;link = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************工具函数*****************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawAlpha</span><span class="params">(IMAGE* picture, <span class="keyword">int</span>  picture_x, <span class="keyword">int</span> picture_y)</span> <span class="comment">//载入PNG图并去透明部分,x为载入图片的X坐标，y为Y坐标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 变量初始化</span></span><br><span class="line">	DWORD* dst = <span class="built_in">GetImageBuffer</span>();    <span class="comment">// GetImageBuffer()函数，用于获取绘图设备的显存指针，EASYX自带</span></span><br><span class="line">	DWORD* draw = <span class="built_in">GetImageBuffer</span>();</span><br><span class="line">	DWORD* src = <span class="built_in">GetImageBuffer</span>(picture); <span class="comment">//获取picture的显存指针</span></span><br><span class="line">	<span class="keyword">int</span> picture_width = picture-&gt;<span class="built_in">getwidth</span>(); <span class="comment">//获取picture的宽度，EASYX自带</span></span><br><span class="line">	<span class="keyword">int</span> picture_height = picture-&gt;<span class="built_in">getheight</span>(); <span class="comment">//获取picture的高度，EASYX自带</span></span><br><span class="line">	<span class="keyword">int</span> graphWidth = <span class="built_in">getwidth</span>();       <span class="comment">//获取绘图区的宽度，EASYX自带</span></span><br><span class="line">	<span class="keyword">int</span> graphHeight = <span class="built_in">getheight</span>();     <span class="comment">//获取绘图区的高度，EASYX自带</span></span><br><span class="line">	<span class="keyword">int</span> dstX = <span class="number">0</span>;    <span class="comment">//在显存里像素的角标</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 实现透明贴图 公式： Cp=αp*FP+(1-αp)*BP ， 贝叶斯定理来进行点颜色的概率计算</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> iy = <span class="number">0</span>; iy &lt; picture_height; iy++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> ix = <span class="number">0</span>; ix &lt; picture_width; ix++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> srcX = ix + iy * picture_width; <span class="comment">//在显存里像素的角标</span></span><br><span class="line">			<span class="keyword">int</span> sa = ((src[srcX] &amp; <span class="number">0xff000000</span>) &gt;&gt; <span class="number">24</span>); <span class="comment">//0xAArrggbb;AA是透明度</span></span><br><span class="line">			<span class="keyword">int</span> sr = ((src[srcX] &amp; <span class="number">0xff0000</span>) &gt;&gt; <span class="number">16</span>); <span class="comment">//获取RGB里的R</span></span><br><span class="line">			<span class="keyword">int</span> sg = ((src[srcX] &amp; <span class="number">0xff00</span>) &gt;&gt; <span class="number">8</span>);   <span class="comment">//G</span></span><br><span class="line">			<span class="keyword">int</span> sb = src[srcX] &amp; <span class="number">0xff</span>;              <span class="comment">//B</span></span><br><span class="line">			<span class="keyword">if</span> (ix &gt;= <span class="number">0</span> &amp;&amp; ix &lt;= graphWidth &amp;&amp; iy &gt;= <span class="number">0</span> &amp;&amp; iy &lt;= graphHeight &amp;&amp; dstX &lt;= graphWidth * graphHeight)</span><br><span class="line">			&#123;</span><br><span class="line">				dstX = (ix + picture_x) + (iy + picture_y) * graphWidth; <span class="comment">//在显存里像素的角标</span></span><br><span class="line">				<span class="keyword">int</span> dr = ((dst[dstX] &amp; <span class="number">0xff0000</span>) &gt;&gt; <span class="number">16</span>);</span><br><span class="line">				<span class="keyword">int</span> dg = ((dst[dstX] &amp; <span class="number">0xff00</span>) &gt;&gt; <span class="number">8</span>);</span><br><span class="line">				<span class="keyword">int</span> db = dst[dstX] &amp; <span class="number">0xff</span>;</span><br><span class="line">				draw[dstX] = ((sr * sa / <span class="number">255</span> + dr * (<span class="number">255</span> - sa) / <span class="number">255</span>) &lt;&lt; <span class="number">16</span>)  <span class="comment">//公式： Cp=αp*FP+(1-αp)*BP  ； αp=sa/255 , FP=sr , BP=dr</span></span><br><span class="line">					| ((sg * sa / <span class="number">255</span> + dg * (<span class="number">255</span> - sa) / <span class="number">255</span>) &lt;&lt; <span class="number">8</span>)         <span class="comment">//αp=sa/255 , FP=sg , BP=dg</span></span><br><span class="line">					| (sb * sa / <span class="number">255</span> + db * (<span class="number">255</span> - sa) / <span class="number">255</span>);              <span class="comment">//αp=sa/255 , FP=sb , BP=db</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">playMusic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">PlaySound</span>(<span class="string">&quot;src\\gameGUI\\music.wav&quot;</span>, <span class="literal">NULL</span>, SND_ASYNC | SND_FILENAME | SND_LOOP);<span class="comment">//异步播放背景音乐</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************程序功能函数*****************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">initgraph</span>(WIDTH, HEIGHT<span class="comment">/*, SHOWCONSOLE*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span><span class="comment">//获取用户输入</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">loginCheck</span><span class="params">(<span class="keyword">char</span> id[], <span class="keyword">char</span> pwd[])</span></span>;</span><br><span class="line">	<span class="keyword">wchar_t</span> c = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> startx = <span class="number">105</span>;</span><br><span class="line">	USERS a, b;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)	<span class="comment">//startx&lt;250</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">MouseHit</span>()) &#123;</span><br><span class="line">			MOUSEMSG msg = <span class="built_in">GetMouseMsg</span>();</span><br><span class="line">			<span class="keyword">if</span> (_kbhit() || ((msg.uMsg == WM_LBUTTONDOWN) &amp;&amp; msg.x &gt;= <span class="number">100</span> &amp;&amp; msg.x &lt;= <span class="number">250</span> &amp;&amp; msg.y &gt;= <span class="number">500</span> &amp;&amp; msg.y &lt;= <span class="number">525</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">settextstyle</span>(<span class="number">15</span>, <span class="number">0</span>, <span class="string">&quot;consoals&quot;</span>);	<span class="comment">//设置为等宽字体</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">					c = _getch();</span><br><span class="line">					a.id[i] = c;</span><br><span class="line">					<span class="keyword">if</span> (c == <span class="number">9</span> || c == <span class="number">7</span> || c == <span class="number">13</span> || ((msg.uMsg == WM_LBUTTONDOWN) &amp;&amp; msg.x &gt;= <span class="number">100</span> &amp;&amp; msg.x &lt;= <span class="number">250</span> &amp;&amp; msg.y &gt;= <span class="number">535</span> &amp;&amp; msg.y &lt;= <span class="number">560</span>))	<span class="comment">//tab或esc或enter或者密码输入框内点击</span></span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">if</span> (c == <span class="number">8</span> &amp;&amp; startx &gt;= <span class="number">100</span>) &#123;	<span class="comment">//backspace</span></span><br><span class="line">						<span class="built_in">setfillcolor</span>(BLACK);</span><br><span class="line">						<span class="built_in">solidrectangle</span>(startx - <span class="number">7</span>, <span class="number">501</span>, startx, <span class="number">524</span>);	<span class="comment">//覆盖上一个字符的位置</span></span><br><span class="line">						startx -= <span class="number">7</span>;</span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="built_in">outtextxy</span>(startx, <span class="number">503</span>, a.id[i]);</span><br><span class="line">					startx += <span class="number">7</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				startx = <span class="number">105</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">					c = _getch();</span><br><span class="line">					<span class="keyword">if</span> (c == <span class="number">9</span> || c == <span class="number">7</span>)	<span class="comment">//tab或esc</span></span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">if</span> (c == <span class="number">8</span> &amp;&amp; startx &gt;= <span class="number">100</span>) &#123;	<span class="comment">//backspace</span></span><br><span class="line">						<span class="built_in">setfillcolor</span>(BLACK);</span><br><span class="line">						<span class="built_in">solidrectangle</span>(startx - <span class="number">7</span>, <span class="number">536</span>, startx, <span class="number">559</span>);</span><br><span class="line">						startx -= <span class="number">7</span>;</span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					a.pwd[i] = c;</span><br><span class="line">					<span class="built_in">outtextxy</span>(startx, <span class="number">538</span>, _T(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">					startx += <span class="number">7</span>;</span><br><span class="line">					<span class="keyword">if</span> (c == <span class="number">13</span> || ((msg.uMsg == WM_LBUTTONDOWN) &amp;&amp; msg.x &gt;= <span class="number">178</span> &amp;&amp; msg.x &lt;= <span class="number">265</span> &amp;&amp; msg.y &gt;= <span class="number">139</span> &amp;&amp; msg.y &lt;= <span class="number">193</span>)||(<span class="built_in">loginCheck</span>(a.id,a.pwd)))	<span class="comment">//如果用户输入enter或者点击“开始”，调用start()函数</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="built_in">start</span>(); <span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loginCheck</span><span class="params">(<span class="keyword">char</span> id[],<span class="keyword">char</span> pwd[])</span> </span>&#123;</span><br><span class="line">	FILE* fp;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> s[<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">char</span> u[<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	fp = <span class="built_in">fopen</span>(<span class="string">&quot;info.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (fp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">while</span> (!<span class="built_in">feof</span>(fp)) &#123;</span><br><span class="line">			<span class="built_in">fgets</span>(s, <span class="built_in"><span class="keyword">sizeof</span></span>(s), fp);</span><br><span class="line">			<span class="built_in">fgets</span>(u, <span class="built_in"><span class="keyword">sizeof</span></span>(u), fp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, id)==<span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(u, pwd)==<span class="number">0</span>) &#123;</span><br><span class="line">			flag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			flag = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">()</span>	<span class="comment">//登陆界面</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	IMAGE img1, img2, img3;</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;img1, <span class="string">&quot;src\\login\\01.png&quot;</span>, WIDTH, HEIGHT, <span class="literal">true</span>);</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;img2, <span class="string">&quot;src\\login\\02.png&quot;</span>, <span class="number">100</span>, <span class="number">50</span>, <span class="literal">true</span>);</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;img3, <span class="string">&quot;src\\login\\03.png&quot;</span>, <span class="number">180</span>, <span class="number">120</span>, <span class="literal">true</span>);</span><br><span class="line">	<span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;img1);	<span class="comment">//登陆主界面</span></span><br><span class="line">	<span class="built_in">putimage</span>(<span class="number">125</span>, <span class="number">440</span>, &amp;img2);	<span class="comment">//贴图login</span></span><br><span class="line">	<span class="built_in">drawAlpha</span>(&amp;img3, <span class="number">260</span>, <span class="number">240</span>);</span><br><span class="line">	<span class="comment">//setfillcolor(RGB(254, 219, 35));</span></span><br><span class="line">	<span class="built_in">setfillcolor</span>(BLACK);</span><br><span class="line">	<span class="built_in">fillrectangle</span>(<span class="number">100</span>, <span class="number">500</span>, <span class="number">250</span>, <span class="number">525</span>);	<span class="comment">//用户名输入框</span></span><br><span class="line">	<span class="built_in">fillrectangle</span>(<span class="number">100</span>, <span class="number">535</span>, <span class="number">250</span>, <span class="number">560</span>);	<span class="comment">//密码输入框</span></span><br><span class="line">	<span class="built_in">setfillcolor</span>(BLACK);</span><br><span class="line"></span><br><span class="line">	RECT account = &#123; <span class="number">30</span>, <span class="number">500</span>, <span class="number">85</span>, <span class="number">525</span> &#125;;</span><br><span class="line">	RECT password = &#123; <span class="number">30</span>, <span class="number">535</span>, <span class="number">85</span>, <span class="number">560</span> &#125;;</span><br><span class="line">	<span class="built_in">drawtext</span>(_T(<span class="string">&quot;用户名:&quot;</span>), &amp;account, DT_SINGLELINE | DT_VCENTER);</span><br><span class="line">	<span class="built_in">drawtext</span>(_T(<span class="string">&quot;密  码:&quot;</span>), &amp;password, DT_SINGLELINE | DT_VCENTER);</span><br><span class="line">	<span class="built_in">setcolor</span>(WHITE);</span><br><span class="line">	<span class="built_in">input</span>();</span><br><span class="line">	<span class="comment">/*system(&quot;pause&quot;)*/</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123; <span class="comment">//游戏介绍界面</span></span><br><span class="line">	<span class="built_in">cleardevice</span>();<span class="comment">//清空之前绘制窗体</span></span><br><span class="line">	<span class="built_in">FlushMouseMsgBuffer</span>();<span class="comment">//清空鼠标消息缓冲区</span></span><br><span class="line">	IMAGE img, img2, img3, img4;</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;img, <span class="string">&quot;src\\start\\01.png&quot;</span><span class="comment">/*, WIDTH, HEIGHT, true*/</span>);</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;img2, <span class="string">&quot;src\\start\\02.png&quot;</span>, <span class="number">200</span>, <span class="number">100</span>, <span class="literal">true</span>);</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;img3, <span class="string">&quot;src\\start\\03.png&quot;</span>);</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;img4, <span class="string">&quot;src\\start\\04.png&quot;</span>);</span><br><span class="line">	<span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;img);</span><br><span class="line">	<span class="built_in">drawAlpha</span>(&amp;img2, <span class="number">335</span>, <span class="number">92</span>);<span class="comment">//边框花纹</span></span><br><span class="line">	<span class="built_in">setfillcolor</span>(<span class="built_in">RGB</span>(<span class="number">0</span>, <span class="number">122</span>, <span class="number">204</span>));</span><br><span class="line">	<span class="built_in">solidrectangle</span>(<span class="number">85</span>, <span class="number">175</span>, <span class="number">780</span>, <span class="number">620</span>);<span class="comment">//游戏介绍背景</span></span><br><span class="line">	<span class="built_in">drawAlpha</span>(&amp;img3, <span class="number">60</span>, <span class="number">172</span>);</span><br><span class="line">	<span class="built_in">drawAlpha</span>(&amp;img4, <span class="number">350</span>, <span class="number">585</span>);<span class="comment">//开始游戏按钮</span></span><br><span class="line">	<span class="built_in">setcolor</span>(WHITE);</span><br><span class="line">	<span class="built_in">settextstyle</span>(<span class="number">25</span>, <span class="number">0</span>, <span class="string">&quot;simsun&quot;</span>);</span><br><span class="line">	<span class="built_in">setbkmode</span>(TRANSPARENT);<span class="comment">//背景透明</span></span><br><span class="line">	RECT info1 = &#123; <span class="number">175</span>,<span class="number">265</span>,<span class="number">690</span>,<span class="number">365</span> &#125;;</span><br><span class="line">	<span class="built_in">drawtext</span>(_T(<span class="string">&quot;\t黄金矿工是一款益智休闲类游戏,在游戏中，\n玩家通过不断挖矿，获取金子，只有在一定的\n时间内金子数量达到要求才能够进入下一关。\n&quot;</span>), &amp;info1, DT_LEFT);</span><br><span class="line">	RECT info2 = &#123; <span class="number">175</span>,<span class="number">370</span>,<span class="number">690</span>,<span class="number">410</span> &#125;;</span><br><span class="line">	<span class="built_in">settextstyle</span>(<span class="number">30</span>, <span class="number">0</span>, <span class="string">&quot;simsun&quot;</span>);</span><br><span class="line">	<span class="built_in">drawtext</span>(_T(<span class="string">&quot;操作介绍:&quot;</span>), &amp;info2, DT_LEFT);</span><br><span class="line">	RECT info3&#123; <span class="number">175</span>, <span class="number">420</span>, <span class="number">690</span>, <span class="number">460</span> &#125;;</span><br><span class="line">	<span class="built_in">drawtext</span>(_T(<span class="string">&quot;按\&quot;S\&quot;键开始捞金子&quot;</span>), &amp;info3, DT_CENTER);</span><br><span class="line">	<span class="comment">/*RECT info4 = &#123; 175,465,690,540 &#125;;</span></span><br><span class="line"><span class="comment">	drawtext(_T(&quot;按\&quot;↑\&quot;键放炸弹(如果有)&quot;), &amp;info4, DT_CENTER);*/</span></span><br><span class="line">	RECT info5 = &#123; <span class="number">175</span>,<span class="number">540</span>,<span class="number">690</span>,<span class="number">600</span> &#125;;</span><br><span class="line">	<span class="built_in">settextstyle</span>(<span class="number">25</span>, <span class="number">0</span>, <span class="string">&quot;TimesNewRoman&quot;</span>);</span><br><span class="line">	<span class="built_in">drawtext</span>(_T(<span class="string">&quot;Have a nice day!&quot;</span>), &amp;info5, DT_CENTER | DT_VCENTER);</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		MOUSEMSG msg = <span class="built_in">GetMouseMsg</span>();</span><br><span class="line">		<span class="keyword">if</span> ((msg.uMsg == WM_LBUTTONDOWN) &amp;&amp; msg.x &gt;= <span class="number">350</span> &amp;&amp; msg.x &lt;= <span class="number">512</span> &amp;&amp; msg.y &gt;= <span class="number">585</span> &amp;&amp; msg.y &lt;= <span class="number">627</span>) &#123;</span><br><span class="line">			<span class="built_in">playGame</span>();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (_kbhit()) &#123;</span><br><span class="line">			<span class="keyword">wchar_t</span> c = _getch();</span><br><span class="line">			<span class="keyword">if</span> (c == <span class="number">13</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">playGame</span>();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gameGUI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	IMAGE img1, img2, img3;</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;img1, <span class="string">&quot;src\\gameGUI\\01.jpg&quot;</span>, WIDTH, HEIGHT - <span class="number">150</span>, <span class="literal">true</span>); <span class="comment">//背景</span></span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;img2, <span class="string">&quot;src\\gameGUI\\02.png&quot;</span>, WIDTH, <span class="number">150</span>, <span class="literal">true</span>);</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;img3, <span class="string">&quot;src\\gameGUI\\hook.png&quot;</span>);</span><br><span class="line">	<span class="built_in">drawAlpha</span>(&amp;img3, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;img2);</span><br><span class="line">	<span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">150</span>, &amp;img1);</span><br><span class="line">	<span class="built_in">setlinecolor</span>(BLACK);</span><br><span class="line">	<span class="built_in">setlinestyle</span>(PS_SOLID, <span class="number">2</span>);</span><br><span class="line">	<span class="built_in">line</span>(<span class="number">430</span>, <span class="number">100</span>, <span class="number">430</span>, <span class="number">155</span>);	<span class="comment">//画滚筒和钩子之间的连线</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loadMines</span><span class="params">()</span> </span>&#123;	<span class="comment">//加载矿石图片</span></span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;prop1[<span class="number">0</span>].img, <span class="string">&quot;src\\stones\\stone1.png&quot;</span>);</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;prop1[<span class="number">1</span>].img, <span class="string">&quot;src\\stones\\stone2.png&quot;</span>);</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;prop1[<span class="number">2</span>].img, <span class="string">&quot;src\\stones\\stone3.png&quot;</span>);</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;prop1[<span class="number">3</span>].img, <span class="string">&quot;src\\stones\\stone4.png&quot;</span>);</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;prop1[<span class="number">4</span>].img, <span class="string">&quot;src\\stones\\gold1.png&quot;</span>);</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;prop1[<span class="number">5</span>].img, <span class="string">&quot;src\\stones\\gold2.png&quot;</span>);</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;prop1[<span class="number">6</span>].img, <span class="string">&quot;src\\stones\\gold3.png&quot;</span>);</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;prop1[<span class="number">7</span>].img, <span class="string">&quot;src\\stones\\gold4.png&quot;</span>);</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;prop1[<span class="number">8</span>].img, <span class="string">&quot;src\\stones\\gold5.png&quot;</span>);</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;prop1[<span class="number">9</span>].img, <span class="string">&quot;src\\stones\\diamond.png&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initMines</span><span class="params">()</span> </span>&#123; <span class="comment">//初始化矿石相关参数</span></span><br><span class="line">	<span class="built_in">loadMines</span>();</span><br><span class="line">	<span class="built_in">srand</span>((<span class="keyword">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  <span class="comment">//设置矿石边缘</span></span><br><span class="line">		prop1[i].e.left = prop1[i].x = <span class="built_in">rand</span>() % (WIDTH<span class="number">-200</span>)+<span class="number">100</span>;</span><br><span class="line">		prop1[i].e.top = prop1[i].y = <span class="built_in">rand</span>() % (HEIGHT<span class="number">-350</span>) + <span class="number">200</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		prop1[i].e.right = prop1[i].e.left + prop1[i].img.<span class="built_in">getwidth</span>();</span><br><span class="line">		prop1[i].e.bottom = prop1[i].e.top + prop1[i].img.<span class="built_in">getheight</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//初始化矿石分数、重量</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">		prop1[i].score = <span class="number">50</span> * (i + <span class="number">1</span>); <span class="comment">//石头</span></span><br><span class="line">		prop1[i].weight = i + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt; <span class="number">9</span>; i++) &#123; <span class="comment">//黄金</span></span><br><span class="line">		prop1[i].score = <span class="number">100</span> * (i - <span class="number">3</span>);</span><br><span class="line">		prop1[i].weight = i - <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	prop1[<span class="number">9</span>].score = <span class="number">500</span>; <span class="comment">//钻石</span></span><br><span class="line">	prop1[<span class="number">9</span>].weight = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putMines</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">//绘制矿石</span></span><br><span class="line">		<span class="keyword">if</span> (prop1[i].flag != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(prop1[i].y &gt;= <span class="number">150</span>)</span><br><span class="line">				<span class="built_in">drawAlpha</span>(&amp;prop1[i].img, prop1[i].x, prop1[i].y);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">victory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cleardevice</span>();</span><br><span class="line">	<span class="built_in">settextcolor</span>(<span class="built_in">RGB</span>(<span class="number">181</span>, <span class="number">136</span>, <span class="number">47</span>));</span><br><span class="line">	<span class="built_in">settextstyle</span>(<span class="number">60</span>, <span class="number">0</span>, _T(<span class="string">&quot;Consolas&quot;</span>));</span><br><span class="line">	IMAGE img;</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;img, <span class="string">&quot;src\\gameOver\\victory.jpg&quot;</span>);</span><br><span class="line">	<span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;img);</span><br><span class="line">	<span class="built_in">outtextxy</span>(<span class="number">160</span>, <span class="number">370</span>, _T(<span class="string">&quot;你获得金币：&quot;</span>));</span><br><span class="line">	<span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">	<span class="built_in">outtextxy</span>(<span class="number">500</span>, <span class="number">370</span>, _itoa(money, s, <span class="number">10</span>));</span><br><span class="line">	<span class="built_in">outtextxy</span>(<span class="number">500</span>, <span class="number">370</span>, _itoa(money, s, <span class="number">10</span>));</span><br><span class="line">	<span class="built_in">outtextxy</span>(<span class="number">160</span>, <span class="number">440</span>, _T(<span class="string">&quot;挖到金块：&quot;</span>));</span><br><span class="line">	<span class="built_in">outtextxy</span>(<span class="number">450</span>, <span class="number">440</span>, _itoa(num_g, s, <span class="number">10</span>));</span><br><span class="line">	<span class="built_in">outtextxy</span>(<span class="number">160</span>, <span class="number">510</span>, _T(<span class="string">&quot;挖到石头：&quot;</span>));</span><br><span class="line">	<span class="built_in">outtextxy</span>(<span class="number">450</span>, <span class="number">510</span>, _itoa(num_s, s, <span class="number">10</span>));</span><br><span class="line">	<span class="built_in">outtextxy</span>(<span class="number">160</span>, <span class="number">580</span>, _T(<span class="string">&quot;挖到钻石：&quot;</span>));</span><br><span class="line">	<span class="built_in">outtextxy</span>(<span class="number">450</span>, <span class="number">580</span>, _itoa(num_d, s, <span class="number">10</span>));</span><br><span class="line">	<span class="built_in">Sleep</span>(<span class="number">6000</span>);</span><br><span class="line">	<span class="built_in">gameOver</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">defeat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cleardevice</span>();</span><br><span class="line">	<span class="built_in">settextcolor</span>(<span class="built_in">RGB</span>(<span class="number">181</span>, <span class="number">136</span>, <span class="number">47</span>));</span><br><span class="line">	<span class="built_in">settextstyle</span>(<span class="number">60</span>, <span class="number">0</span>, _T(<span class="string">&quot;Consolas&quot;</span>));</span><br><span class="line">	IMAGE img;</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;img, <span class="string">&quot;src\\gameOver\\defeat.jpg&quot;</span>);</span><br><span class="line">	<span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;img);</span><br><span class="line">	<span class="built_in">outtextxy</span>(<span class="number">160</span>, <span class="number">370</span>, _T(<span class="string">&quot;你获得金币：&quot;</span>));</span><br><span class="line">	<span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">	<span class="built_in">outtextxy</span>(<span class="number">500</span>, <span class="number">370</span>, _itoa(money, s, <span class="number">10</span>));</span><br><span class="line">	<span class="built_in">outtextxy</span>(<span class="number">160</span>, <span class="number">440</span>, _T(<span class="string">&quot;挖到金块：&quot;</span>));</span><br><span class="line">	<span class="built_in">outtextxy</span>(<span class="number">450</span>, <span class="number">440</span>, _itoa(num_g, s, <span class="number">10</span>));</span><br><span class="line">	<span class="built_in">outtextxy</span>(<span class="number">160</span>, <span class="number">510</span>, _T(<span class="string">&quot;挖到石头：&quot;</span>));</span><br><span class="line">	<span class="built_in">outtextxy</span>(<span class="number">450</span>, <span class="number">510</span>, _itoa(num_s, s, <span class="number">10</span>));</span><br><span class="line">	<span class="built_in">outtextxy</span>(<span class="number">160</span>, <span class="number">580</span>, _T(<span class="string">&quot;挖到钻石：&quot;</span>));</span><br><span class="line">	<span class="built_in">outtextxy</span>(<span class="number">450</span>, <span class="number">580</span>, _itoa(num_d, s, <span class="number">10</span>));</span><br><span class="line">	<span class="built_in">Sleep</span>(<span class="number">6000</span>);</span><br><span class="line">	<span class="built_in">gameOver</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isCatched</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y, EDGE e)</span> </span>&#123;  <span class="comment">//判断是否抓取到矿石</span></span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (x &gt;= e.left &amp;&amp; x &lt;= e.right &amp;&amp; y &gt;= e.top &amp;&amp; y &lt;= e.bottom)</span><br><span class="line">		flag = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateWithoutInput</span><span class="params">()</span> </span>&#123; <span class="comment">//与用户输入无关的更新</span></span><br><span class="line">	<span class="built_in">BeginBatchDraw</span>();</span><br><span class="line">	<span class="built_in">hook</span>();		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateWithInput</span><span class="params">()</span> </span>&#123;  <span class="comment">//与用户输入有关的更新</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">1</span>, root = r, m = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">char</span> kb,s2[<span class="number">10</span>];</span><br><span class="line">	IMAGE tmp2;</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;tmp2, <span class="string">&quot;src\\temp\\tmp2.jpg&quot;</span>);</span><br><span class="line">	LinkList list = <span class="built_in">createNullList_link</span>();</span><br><span class="line">	<span class="keyword">if</span> (_kbhit()) &#123;</span><br><span class="line">		kb = _getch();</span><br><span class="line">		<span class="keyword">if</span> (kb == <span class="string">&#x27;S&#x27;</span> || kb == <span class="string">&#x27;s&#x27;</span>) &#123;</span><br><span class="line">			flag_dig = <span class="number">1</span>; <span class="comment">//下挖，将flag设置为1</span></span><br><span class="line">			<span class="keyword">while</span> (flag) &#123;</span><br><span class="line">				r += dig_v;</span><br><span class="line">				<span class="built_in">hook</span>();</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">//抓取到</span></span><br><span class="line">					<span class="comment">//根据hookx和hooky计算钩子的中心位置，据此判断是否抓取到矿石</span></span><br><span class="line">					<span class="keyword">int</span> judge_x = hookx+<span class="number">30</span>, judge_y = hooky+<span class="number">27</span>;</span><br><span class="line">					<span class="keyword">if</span> (prop1[i].flag != <span class="number">0</span> &amp;&amp; <span class="built_in">isCatched</span>(judge_x, judge_y, prop1[i].e)) &#123;</span><br><span class="line">						prop1[i].flag = <span class="number">2</span>;</span><br><span class="line">						<span class="comment">//dig_v -= prop1[i].weight;</span></span><br><span class="line">						dig_v = -dig_v;	<span class="comment">//收回钩子</span></span><br><span class="line">						m = i;</span><br><span class="line">						<span class="comment">//dig_v += (10 - prop1[m].weight);</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> ((hookx+<span class="number">65</span>) &gt;= <span class="number">850</span> || hookx &lt;= <span class="number">0</span> || (hooky+<span class="number">40</span>) &gt;= <span class="number">700</span>) dig_v = -dig_v;		<span class="comment">//碰到边界收回钩子</span></span><br><span class="line">				<span class="keyword">if</span> (r == root) &#123;</span><br><span class="line">					dig_v = -dig_v;	</span><br><span class="line">					flag = <span class="number">0</span>;					<span class="comment">//收到原来的r时停止</span></span><br><span class="line">					flag_dig = <span class="number">0</span>;				<span class="comment">//停止下挖dig</span></span><br><span class="line">					<span class="keyword">if</span> (m != <span class="number">-1</span>) &#123;				<span class="comment">//m必须有初值 否则遇到没有抓到东西时会出错</span></span><br><span class="line">						prop1[m].flag = <span class="number">0</span>;</span><br><span class="line">						<span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;tmp2);</span><br><span class="line">						money += prop1[m].score;</span><br><span class="line">						<span class="built_in">insertNodeByHead</span>(list, &amp;prop1[m]);</span><br><span class="line">						<span class="built_in">outtextxy</span>(<span class="number">100</span>, <span class="number">8</span>, _itoa(money, s2, <span class="number">10</span>));</span><br><span class="line">						<span class="built_in"><span class="keyword">switch</span></span> (m)</span><br><span class="line">						&#123;</span><br><span class="line">						<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">						<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">						<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">						<span class="keyword">case</span> <span class="number">3</span>: num_s += <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">						<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">						<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">						<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">						<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">						<span class="keyword">case</span> <span class="number">8</span>: num_g += <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">						<span class="keyword">case</span> <span class="number">9</span>: num_d += <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						m = <span class="number">-1</span>;</span><br><span class="line">						number++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				count++;							<span class="comment">//模拟倒计时</span></span><br><span class="line">				<span class="keyword">if</span> (count % <span class="number">50</span> == <span class="number">0</span>) retime--;</span><br><span class="line">				IMAGE img;</span><br><span class="line">				<span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">				<span class="built_in">loadimage</span>(&amp;img, <span class="string">&quot;src\\gameGUI\\time.jpg&quot;</span>);</span><br><span class="line">				<span class="built_in">putimage</span>(<span class="number">700</span>, <span class="number">0</span>, &amp;img);</span><br><span class="line">				<span class="built_in">outtextxy</span>(<span class="number">780</span>, <span class="number">8</span>, _itoa(retime, s, <span class="number">10</span>));</span><br><span class="line">				<span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">150</span>, &amp;temp2); <span class="comment">//刷新矿石</span></span><br><span class="line">				<span class="built_in">putMines</span>();	</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">EndBatchDraw</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hook</span><span class="params">()</span> </span>&#123;	<span class="comment">//钩子</span></span><br><span class="line">	<span class="built_in">Sleep</span>(<span class="number">10</span>);</span><br><span class="line">	IMAGE img1, temp, img2;</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;img1, <span class="string">&quot;src\\gameGUI\\hook_01.jpg&quot;</span>);	<span class="comment">//加载原图</span></span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;img2, <span class="string">&quot;src\\gameGUI\\hook_01bg.jpg&quot;</span>); <span class="comment">//加载掩码图</span></span><br><span class="line">	<span class="built_in">BeginBatchDraw</span>(); <span class="comment">//开始批量绘图</span></span><br><span class="line">	<span class="keyword">if</span> (angle &gt;= <span class="number">90</span> || angle &lt;= <span class="number">-90</span>) </span><br><span class="line">		angle_v = -angle_v;</span><br><span class="line">	<span class="keyword">if</span> (!flag_dig) <span class="comment">//不向下挖</span></span><br><span class="line">		angle += angle_v;</span><br><span class="line">	hookx = centerx + r * <span class="built_in">sin</span>(angle * PI / <span class="number">180</span>);  <span class="comment">//使用圆上的坐标 x= x0 + r*sin# ; y = y + r*cos# 逆时针旋转</span></span><br><span class="line">	hooky = centery + r * <span class="built_in">cos</span>(angle * PI / <span class="number">180</span>);</span><br><span class="line">	<span class="built_in">getimage</span>(&amp;temp,hookx,hooky,hookx+<span class="number">75</span>,hookx+<span class="number">75</span>);</span><br><span class="line">	<span class="comment">//drawAlpha(&amp;img1, hookx, hooky);</span></span><br><span class="line">	<span class="built_in">putimage</span>(hookx, hooky, &amp;img2, SRCAND); <span class="comment">//贴钩子的时候使用drawAlpah会导致异常，因此使用掩码图贴透明图</span></span><br><span class="line">	<span class="built_in">putimage</span>(hookx, hooky, &amp;img1, SRCPAINT);</span><br><span class="line">	<span class="built_in">FlushBatchDraw</span>();</span><br><span class="line">	<span class="built_in">putimage</span>(hookx,hooky,&amp;temp);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (prop1[i].flag == <span class="number">2</span>) &#123; <span class="comment">//如果矿石被抓到</span></span><br><span class="line">			prop1[i].x = centerx + r * <span class="built_in">sin</span>(angle * PI / <span class="number">180</span>) - prop1[i].img.<span class="built_in">getwidth</span>() / <span class="number">2</span>;</span><br><span class="line">			prop1[i].y = centery + r * <span class="built_in">cos</span>(angle * PI / <span class="number">180</span>) - <span class="number">20</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">FlushConsoleInputBuffer</span>(<span class="built_in">GetStdHandle</span>(STD_INPUT_HANDLE));<span class="comment">//清空键盘缓存</span></span><br><span class="line">	<span class="built_in">playMusic</span>();</span><br><span class="line">	<span class="built_in">gameGUI</span>();</span><br><span class="line">	<span class="comment">//saveimage(&quot;d:\\desktop\\test.jpg&quot;);</span></span><br><span class="line">	<span class="built_in">initMines</span>();</span><br><span class="line">	<span class="built_in">putMines</span>();</span><br><span class="line">	retime = <span class="number">30</span>;</span><br><span class="line">	IMAGE tmp1;</span><br><span class="line">	<span class="keyword">char</span> s[<span class="number">10</span>],c[<span class="number">10</span>];</span><br><span class="line">	<span class="built_in">settextcolor</span>(<span class="built_in">RGB</span>(<span class="number">181</span>, <span class="number">136</span>, <span class="number">47</span>));</span><br><span class="line">	<span class="built_in">settextstyle</span>(<span class="number">60</span>, <span class="number">0</span>, _T(<span class="string">&quot;Consolas&quot;</span>));</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;temp2, <span class="string">&quot;src\\gameGUI\\01.jpg&quot;</span>, WIDTH, HEIGHT - <span class="number">150</span>, <span class="literal">true</span>);</span><br><span class="line">	<span class="built_in">getimage</span>(&amp;tmp1, <span class="number">700</span>, <span class="number">0</span>, <span class="number">850</span>, <span class="number">75</span>);</span><br><span class="line">	<span class="built_in">outtextxy</span>(<span class="number">750</span>, <span class="number">75</span>, _itoa(checkpoint, c, <span class="number">10</span>));</span><br><span class="line">	<span class="built_in">outtextxy</span>(<span class="number">100</span>, <span class="number">80</span>, _itoa(target_money, s, <span class="number">10</span>));</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="built_in">settextcolor</span>(<span class="built_in">RGB</span>(<span class="number">181</span>, <span class="number">136</span>, <span class="number">47</span>));</span><br><span class="line">		<span class="built_in">settextstyle</span>(<span class="number">60</span>, <span class="number">0</span>, _T(<span class="string">&quot;Consolas&quot;</span>));</span><br><span class="line">		<span class="built_in">putimage</span>(<span class="number">700</span>, <span class="number">0</span>, &amp;tmp1);</span><br><span class="line">		<span class="keyword">char</span> s1[<span class="number">10</span>];</span><br><span class="line">		<span class="built_in">outtextxy</span>(<span class="number">780</span>, <span class="number">8</span>, _itoa(retime, s1, <span class="number">10</span>)); <span class="comment">//将整型转化为字符串后输出</span></span><br><span class="line">		<span class="built_in">hook</span>();</span><br><span class="line">		<span class="built_in">updateWithInput</span>();</span><br><span class="line">		<span class="built_in">updateWithInput</span>();</span><br><span class="line">		count++;							<span class="comment">//模拟倒计时</span></span><br><span class="line">		<span class="keyword">if</span> (count % <span class="number">50</span> == <span class="number">0</span>) retime--;</span><br><span class="line">		<span class="keyword">if</span> (retime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">EndBatchDraw</span>();</span><br><span class="line">			<span class="keyword">if</span> (money&gt;=target_money) &#123;</span><br><span class="line">				<span class="built_in">victory</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">defeat</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gameOver</span><span class="params">()</span> </span>&#123; <span class="comment">//游戏结束界面</span></span><br><span class="line">	<span class="built_in">cleardevice</span>();</span><br><span class="line">	<span class="built_in">FlushMouseMsgBuffer</span>(); <span class="comment">//清空鼠标缓冲区</span></span><br><span class="line">	IMAGE img1;</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;img1, <span class="string">&quot;src\\gameover\\01.png&quot;</span>); <span class="comment">//贴游戏结束背景图片</span></span><br><span class="line">	<span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;img1);</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">MouseHit</span>()) &#123;<span class="comment">//如果有鼠标点击</span></span><br><span class="line">			MOUSEMSG msg = <span class="built_in">GetMouseMsg</span>();</span><br><span class="line">			<span class="keyword">if</span> ((msg.uMsg == WM_LBUTTONDOWN) &amp;&amp; msg.x &gt;= <span class="number">100</span> &amp;&amp; msg.x &lt;= <span class="number">355</span> &amp;&amp; msg.y &gt;= <span class="number">510</span> &amp;&amp; msg.y &lt;= <span class="number">590</span>) &#123;<span class="comment">//点击继续游戏 msg.MLBUTTONDOWM	</span></span><br><span class="line">				target_money += <span class="number">600</span>;</span><br><span class="line">				checkpoint += <span class="number">1</span>;</span><br><span class="line">				<span class="built_in">playGame</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> ((msg.uMsg == WM_LBUTTONDOWN) &amp;&amp; msg.x &gt;= <span class="number">480</span> &amp;&amp; msg.x &lt;= <span class="number">735</span> &amp;&amp; msg.y &gt;= <span class="number">510</span> &amp;&amp; msg.y &lt;= <span class="number">590</span>) &#123; <span class="comment">//点击退出游戏</span></span><br><span class="line">				<span class="built_in">closegraph</span>();</span><br><span class="line">				<span class="built_in">PlaySound</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, SND_FILENAME); <span class="comment">//结束播放背景音乐</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123; <span class="comment">//点击其他地方</span></span><br><span class="line">				<span class="built_in">Sleep</span>(<span class="number">6000</span>);</span><br><span class="line">				<span class="built_in">closegraph</span>();</span><br><span class="line">				<span class="built_in">PlaySound</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, SND_FILENAME);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">Sleep</span>(<span class="number">6000</span>);</span><br><span class="line">			<span class="built_in">closegraph</span>();</span><br><span class="line">			<span class="built_in">PlaySound</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, SND_FILENAME);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;GoldMiner.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">login</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类与对象</title>
    <url>/2021/03/26/java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="Java-类与对象"><a href="#Java-类与对象" class="headerlink" title="Java 类与对象"></a><strong>Java 类与对象</strong></h2><hr>
<blockquote>
<p>在一个面向对象的系统中，对象是对现实世界中事物的抽象，是Java程序的基本封装单位，是类的实例；类是对象的抽象，是数据和操作的封装体；属性是事物静态特征的抽象，在程序中使用数据成员加以描述；操作是事物动态特征的抽象，在程序中使用成员方法来实现。</p>
</blockquote>
<h3 id="类与对象概念"><a href="#类与对象概念" class="headerlink" title="类与对象概念"></a><strong>类与对象概念</strong></h3><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a><strong>对象</strong></h4><ol>
<li><p><em>客观世界的事物映射</em>为<strong>对象</strong>，对象是面向对象程序设计中用来描述客观事物的基本单位。</p>
</li>
<li><p><strong>类</strong>是对象的抽象和归纳，对象是类的实例。</p>
</li>
<li><p>对象的特征：</p>
<ol>
<li>对象标识：即对象的名字，是用户和系统识别它的唯一标志。（外部和内部）</li>
<li>属性：用来描述对象的静态特征的一组数据。</li>
<li>方法：对对象动态特征（行为）的描述，也称为服务或操作。</li>
</ol>
</li>
</ol>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a><strong>类</strong></h4><ol>
<li><p>类是一个独立的程序单位，是具有相同属性和方法的一组对象的集合。</p>
<p><u>在定义对象之前应该先定义类</u></p>
</li>
<li><p>描述一个类需要指明三个方面的内容：</p>
<ol>
<li>类标识：类的一个有别于其他类的名字。</li>
<li>属性说明：用来描述相同对象的静态特征。</li>
<li>方法说明：用来描述相同对象的动态特征。</li>
</ol>
<p>example： person类：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class Person		<span class="comment">//class指出这是一个类，Person是类标识</span></span><br><span class="line">&#123;</span><br><span class="line">    String head;		<span class="comment">//类的属性</span></span><br><span class="line">    String hands;</span><br><span class="line">    String feet;</span><br><span class="line">    <span class="function">Public <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span>		<span class="comment">//类的方法</span></span></span><br><span class="line"><span class="function">    </span>&#123;...&#125;</span><br><span class="line">    <span class="function">Public <span class="keyword">void</span> <span class="title">ShowPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>类与对象的关系</strong>：</li>
</ol>
<blockquote>
<p>==对象是对事物的抽象，而类是对对象的抽象和归纳，给出了属于该类的全部对象的抽象定义，对象是符合这种定义的一个实体==。在面向对象的程序设计中，对象被称作类的一个实例，而类是对象的模板。</p>
</blockquote>
<h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a><strong>类的定义</strong></h3><h4 id="类修饰符"><a href="#类修饰符" class="headerlink" title="类修饰符"></a><strong>类修饰符</strong></h4><ol>
<li><p><strong>无修饰符</strong>：</p>
<p>如果一个类前无修饰符，则这个类只能被同一个包里的类使用。<u>Java规定，同一个程序文件中的所有类都在同一个包内</u>。也就是说，==无修饰符的类可以被同一个程序文件中的类使用==，但是不能在其他程序文件中的类（即其他包中的类）使用。</p>
</li>
<li><p><strong>public修饰符</strong>：</p>
<p>如果一个类的修饰符是public，则这个类是公共类。<u>公共类既可供它所在包中的其他类使用，也可以供其他包中的类使用</u>，在程序中可以使用import引用其他包中的public类。<strong>Java规定，在一个程序文件中，只能定义一个public类</strong>，否则编译的时候系统会报错。</p>
</li>
<li><p><strong>final修饰符</strong>：</p>
<p><strong>用final修饰的类被成为最终类，最终类不能被任何其他类所继承</strong>。final类可以将它的内容、属性和功能固定下来，与它的类名形成稳定的映射关系，从而保证引用这个类所实现的功能是正确无误的。将类定义为final类可以用来完成某种标准功能，也可以提高程序的可读性和安全性。</p>
</li>
<li><p><strong>abstract修饰符：</strong></p>
<p>用abstract修饰符修饰的类称为抽象类。<strong>抽象类刻画了研究对象的公有行为特征，并通过继承机制将这些特征传送给它的派生类</strong>。抽象类的作用是将许多有关的类组织在一起，提供一个公共的基类，为派生具体类奠定基础。<em>当一个类中出现一个或多个用abstract修饰符定义的方法时，必须将这个类定义为抽像类</em>。</p>
</li>
</ol>
<p>可以同时使用两个修饰符来修饰一个类（修饰符之间用空格分开，写在class之前，修饰符的顺序对类的性质没有任何影响。<em><strong>类不能被修饰为abstract final</strong></em>[^1]。</p>
<h4 id="声明类的一般格式"><a href="#声明类的一般格式" class="headerlink" title="声明类的一般格式"></a><strong>声明类的一般格式</strong></h4><p>类的声明部分用于描述类的名称以及类的其他属性（类的访问权限、与其他类的关系等）。声明类的语法如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">[public] [abstract | final] class &lt;className&gt; [extends superClass-Name] [implements interfaceNameList]&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ol>
<li>“[]”代表可选项，“&lt;&gt;”表示必选项，“|”表示多选一。</li>
<li>public、abstract或final：指定类的访问权限及其属性，用于说明定义类的相关特征。</li>
<li>class：Java语言的关键字，表明这是一个类的定义。</li>
<li>className：指定类的名称（合法的java标识符）</li>
<li>extends superClassName：指定所定义的类继承于哪一个父类。<em>当使用extends关键字时，父类名称为必选参数</em></li>
<li>implements interfaceNameList：指定该类实现哪些接口。<em>当使用implements关键字时，父类名称为必选参数</em></li>
<li>{…}：花括号中的内容时类体的定义。类体提供了类的对象在生命周期中需要的代码，具体包括：<ol>
<li>构造和初始化新对象的构造方法。</li>
<li>表示类及其对象状态的变量，即数据成员</li>
<li>实现类及其对象的方法，即成员方法</li>
<li>进行对象消除的finalize方法。</li>
</ol>
</li>
</ol>
<h4 id="数据成员-2"><a href="#数据成员-2" class="headerlink" title="数据成员[^2]"></a><strong>数据成员</strong>[^2]</h4><p><strong>一、数据成员的声明</strong></p>
<p>一般情况下，声明一个数据成员时必须给出这个数据成员的标识符并指明它所属的数据类型，声明数据成员的语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">public</span> | <span class="keyword">protected</span> | <span class="keyword">private</span>] [<span class="keyword">static</span>] [<span class="keyword">final</span>] [<span class="keyword">transient</span>] [<span class="keyword">volatile</span>] &lt;type&gt;&lt;variableName&gt;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ol>
<li>public、protected、private：指定变量的访问权限。</li>
<li>static：指定数据成员为静态数据成员，也称为类变量（class variable）。它被保存在内存区的公共存储单元中，而非某个对象的内存区中，因此，一个类的任何对象访问它的时候，存取到的都是相同的数值。<em>如果省略该关键字，表示数据成员为实例变量（instance variab）</em>。</li>
<li>final：指定数据成员为常量。</li>
<li>transient；声明数据成员为一个暂时性变量，它告知JVM该变量不属于对象的持久状态，从而不能被持久存储。<em>如果省略该关键字（默认情况下），则类中所有变量都是对象持久状态的一部分，当对象被保存到外存时，这些变量必须同时被保存</em>。</li>
<li>volatile：指定数据成员在被多个并发线程共享时，系统将采取更优化的控制方法提高线程并发执行的效率。</li>
<li>type：指定数据成员的数据类型。</li>
<li>variableName：指定数据成员的名称。</li>
</ol>
<p><strong>二、静态初始化器</strong></p>
<p>静态数据成员的初始化可以有用户在定义时进行，也可以由<u>静态初始化器</u>[^3]来完成。</p>
<p>eg:在类ClassPractice的定义中，用静态初始化器对静态数据成员进行初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassPractice</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> nn;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;n = <span class="number">20</span>;&#125;</span><br><span class="line">    ClassPractice()</span><br><span class="line">    &#123;nn = n++;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> java.applet.Applet;</span><br><span class="line"><span class="keyword">import</span> java.awt.Graphics;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPractice_1</span> <span class="keyword">extends</span> <span class="title">Applet</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics g)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ClassPractice m = <span class="keyword">new</span> ClassPractice();</span><br><span class="line">        ClassPractice n = <span class="keyword">new</span> ClassPractice();</span><br><span class="line">        g.drawString(<span class="string">&quot;m=&quot;</span>+m.nn,<span class="number">20</span>,<span class="number">50</span>);</span><br><span class="line">        g.drawString(<span class="string">&quot;n=&quot;</span>+n.nn,<span class="number">20</span>,<span class="number">90</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20200227215710.png" alt="程序运行结果"></p>
<p><strong>三、用final修饰的最终数据成员</strong></p>
<p>如果一个类的数据成员用final修饰符修饰，则这个数据成员就被限定为最终数据成员。最终数据成员可以在声明时进行初始化，也可以通过构造方法赋值，但不能在程序的其他部分赋值，他的值在程序的整个执行过程中时不能改变的。</p>
<h4 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h4><p><strong>成员方法描述对象所具有的功能或操作，反映对象的行为，是具有某种相对独立功能的程序模块</strong>。<em>一个类或对象可以有多个成员方法，对象通过执行它的成员方法对传来的消息做出响应，完成特定的功能</em>。（按来源可分为类库成员方法和用户自定义的成员方法）</p>
<p><strong>一、声明成员方法的格式</strong></p>
<p>类的成员方法由方法声明和方法体两部分组成，声明成员方法的语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[accessLevel] [<span class="keyword">static</span>] [<span class="keyword">final</span> | <span class="keyword">abstract</span>] [<span class="keyword">native</span>] [<span class="keyword">synchronized</span>] &lt;return_type&gt;&lt;name&gt; ([&lt;argument_list&gt;]) [<span class="keyword">throws</span> &lt;exception_list&gt;]&#123;</span><br><span class="line">    [block]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ol>
<li><p>accessLevel：确定方法的被访问权限，可选值为public、protected和private</p>
</li>
<li><p>static：将成员方法指定为静态方法，它是属于整个类的类方法，不用static修饰符限定的方法是属于某个具体类的对象的方法。static方法使用特点如下：</p>
<p>（1）static犯法是属于整个类的，它在内存中的代码段将随着类的定义二被分配和装载。而非static的方法是属于某个对象的方法，当这个对象创建时，在对象的内存中拥有的这个方法的专用代码段。</p>
<p>（2）引用静态方法时，可以使用与对象关联的引用变量名作为前缀，也可以使用类名作为前缀。</p>
<p>（3）static方法只能访问静态数据成员，不能访问非静态数据成员，但非static方法可以访问静态数据成员。</p>
<p>（4）static方法只能访问static方法，不能访问非static方法，但非static方法可以访问static方法。</p>
<p>（5）static方法是不能被覆盖，即这个类的子类不能由相同名及相同参数的方法。</p>
<p>（5）main方法是静态方法。Java的每个Application程序中，都必须有且只能有一个main方方法，它是Application程序运行的入口。</p>
</li>
<li><p>final：指明该成员方法为最终方法不能被重写[^4]。</p>
</li>
<li><p>abstract：指名该方法是抽象成员方法。</p>
</li>
<li><p>native：指明该方法时本地成员方法，即该成员用其他语言实现。<em>用此类方法的目的时将C、C++等语言嵌入到Java语言中</em>。</p>
</li>
<li><p>synchronized：控制多个并发线程对共享数据的访问。</p>
</li>
<li><p>return_type：确定方法的返回之类型，如果方法没有返回之，则可以使用关键字void标识。</p>
</li>
<li><p>name：指定成员方法的名称。</p>
</li>
<li><p>argument_list:形式参数列表，成员方法可以分为带参数和不带参数的两种。</p>
</li>
<li><p>throws<exception_list>：列出该方法将要抛出的一系列异常。</p>
</li>
<li><p>block：方法体，描述该方法所要完成的功能，是方法的实现部分。</p>
</li>
<li><p>```Java<br>public class ClassPractice2{</p>
<pre><code>public static void main(String[] args)&#123;
    int a=2,b=3;
    int f=add(a,b);
    System.out.println(&quot;f=&quot;+f);
&#125;
static int add(int x,int y)
&#123;
    int z,d;
    z=x+y;
    return z;
</code></pre>
<p>}<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**二、成员方法的引用**</span><br><span class="line"></span><br><span class="line">成员方法引用的四种方式：</span><br><span class="line"></span><br><span class="line">1. 方法语句。成员方法作为一个独立的语句被引用。</span><br><span class="line">2. 方法表达式。成员方法作为表达式中的一部分，通过表达式被引用。</span><br><span class="line">3. 方法作为参数。一个成员方法作为另一个成员方法的参数别引用。</span><br><span class="line">4. 通过对象来引用。</span><br><span class="line"></span><br><span class="line">#### Java类库</span><br><span class="line"></span><br><span class="line">Java的类库是系统提供的已实现的标准类的集合，是Java编程的API，在Java中，系统定义好的类根据实现功能的不同，可以划分成不同的集合，每个集合称为一个包，所有包合称为类库。</span><br><span class="line"></span><br><span class="line">对于类库中系统定义好的类，有三种使用方式：一是直接使用系统类，第二种方式是继承系统类，在用户程序里创建系统类的子类，例如每个JavaApplet的朱磊都是java.applet包中的Applet类的子类；第三种方式是创建系统类的对象。</span><br><span class="line"></span><br><span class="line">Java程序设计中常用的包：</span><br><span class="line"></span><br><span class="line">1. java.lang包</span><br><span class="line"></span><br><span class="line">   是Java的核心类库，包含了运行Java程序必不可少的系统类，每个Java程序运行时，系统都会自动地引入java.lang包。</span><br><span class="line"></span><br><span class="line">2. java.io包</span><br><span class="line"></span><br><span class="line">   包中包含了实现Java程序与操作系统、用户界面以及其他Java程序之间进行数据交换所使用的类。（凡是需要完成与操作系统有关的较低层的输入&#x2F;输出操作的Java程序都要用到java.io包）</span><br><span class="line"></span><br><span class="line">3. java.awt包</span><br><span class="line"></span><br><span class="line">   是java语言用来构建图形用户界面的类库，它包含许多界面元素和资源，主要在三个方面提供界面支持：</span><br><span class="line"></span><br><span class="line">   （1）低级绘图操作，如Graphics类等。</span><br><span class="line"></span><br><span class="line">   （2）图形界面组件和布局管理，如Checkbox类、Container类、Layout-Manager类等。</span><br><span class="line"></span><br><span class="line">   （3）界面用户交互控制和时间响应，如Event类。</span><br><span class="line"></span><br><span class="line">4. java.awt.event包</span><br><span class="line"></span><br><span class="line">   是JDK1.0版本中原有的Event类的一个扩充，它使得程序可以用不同方式来处理不同类型的事件，并使每个图形界面的元素本身可以拥有处理它上面事件的能力。</span><br><span class="line"></span><br><span class="line">5. java.awt.image包</span><br><span class="line"></span><br><span class="line">   是用来处理和操纵来自网上图片的Java工具类库。</span><br><span class="line"></span><br><span class="line">6. java.applet包</span><br><span class="line"></span><br><span class="line">   是用来实现运行于Internet浏览器中的JavaApplet工具类库，它仅包含少量几个接口和一个非常有用的类java.applet.Applet.</span><br><span class="line"></span><br><span class="line">7. java.net包</span><br><span class="line"></span><br><span class="line">   是Java语言用来实现网络功能的类库，目前已经实现的Java网络功能主要有：底层的网络通信类；编写用户自己的Telnet、FTP、邮件服务等实现网上通信的类；用于访问Internet上资源和进行CGI网关调用的类等。</span><br><span class="line"></span><br><span class="line">8. java.rmi包、java.rmi.registry包和java.rmi.server包</span><br><span class="line"></span><br><span class="line">   这三个包用来实现RMI(Remote Method Invocation,远程方法调用)功能，利用RMI功能，用户程序可以在远程计算机（服务器）上创建对象，并在本地计算机（客户机）上使用这个对象。</span><br><span class="line"></span><br><span class="line">9. java.util包</span><br><span class="line"></span><br><span class="line">   包括了Java语言中一些低级的使用工具，如处理事件的Date类，处理变长数组的Vector类，实现栈的Socket类和实现哈希表的HashTable类等。</span><br><span class="line"></span><br><span class="line">10. java.sql包</span><br><span class="line"></span><br><span class="line">    是实现JDBC的类库，利用这个包可以使Java程序具有访问不同种类数据库的功能。（只要安装了合适的驱动程序，同一个Java程序不许修改就可以存取、修改这些不同数据库中的数据。</span><br><span class="line"></span><br><span class="line">11. java.security包、java.security.acl包和java.security.interface包</span><br><span class="line"></span><br><span class="line">    这三个包提供了更完善的Java程序安全性控制和管理，利用他们可以对Java程序加密，也可以把特定的JavaApplet标记为“可信赖的”，是它能够具有于JavaApplication相近的安全权限。</span><br><span class="line"></span><br><span class="line">12. java.awt.peer包</span><br><span class="line"></span><br><span class="line">    包是实现Java语言跨平台特性的手段之一，它的作用是将不同的平台包裹、隐藏起来，是这些平台在用户程序面前呈现基本基本相同的面貌。</span><br><span class="line"></span><br><span class="line">13. java.util.zip </span><br><span class="line"></span><br><span class="line">    用来实现文件压缩功能。</span><br><span class="line"></span><br><span class="line">14. java.awt.datatransfer包</span><br><span class="line"></span><br><span class="line">    提供处理数串数的工具类，包括剪贴板、字符串发送器等。</span><br><span class="line"></span><br><span class="line">15. java.lang.reflect包</span><br><span class="line"></span><br><span class="line">    提供了用于反射对象的工具，反射允许程序监视一个正在运行的对象并获得它的构造函数、方法和属性。</span><br><span class="line"></span><br><span class="line">16. java.corba包和java.corba.orb包</span><br><span class="line"></span><br><span class="line">     这两个包将CORBA嵌入到java环境中，使得Java程序可以存取、调用CORBA对象，并于CORBA对象共同工作，这样，Java程序就可以方便、动态地使用已经存在的由Java或其他面向对象开发的部件，简化软件的开发。</span><br><span class="line"></span><br><span class="line">### 对象的创建</span><br><span class="line"></span><br><span class="line">创建对象通常包括引用变量、创建对象和初始化三步，在Java中，对象是通过类创建的，对象是类的动态实例。一个对象在程序运行期间的生命周期包括创建、使用和销毁三个阶段。</span><br><span class="line"></span><br><span class="line">#### 声明对象</span><br><span class="line"></span><br><span class="line">​	在Java中，创建一个对象前，要先声明该对象，语法如下:</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;Java</span><br><span class="line">&lt;className&gt;&lt;objectName&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>其中：className指定一个已经定义的类，objectName指定对象名称（对象名必须是合法的Java标识符）。<strong>在声明对象是，只是在内存中为其分配了一个引用空间，并置初始值为null，表示不指向任何存储空间</strong>。</p>
<h4 id="建立对象"><a href="#建立对象" class="headerlink" title="建立对象"></a>建立对象</h4><p>在声明对象时，只确定了对象的名称和它所属的类，并没有为对象分配存储空间，此时对象还不是类的实例。只有通过建立对象，才为对象分配内存，使该对象称为类的实例，这个过程称为对象的实例化，使用关键字new来完成，它的语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;objectName&gt;=<span class="keyword">new</span> &lt;someClass&gt; ([argument_list])</span><br></pre></td></tr></table></figure>

<p>其中：bojectName指定已经声明的对象名；someClass指定需要调用的构造方法名，即类名；argument_list指定构造方法的入口参数。</p>
<h4 id="初始化对象"><a href="#初始化对象" class="headerlink" title="初始化对象"></a>初始化对象</h4><p>初始化对象是指由一个类生成对象时，为这个对象去欸的那个初始状态的过程，初始化对象由三种实现方法：</p>
<p>一、用默认初始化原则赋初值</p>
<table border="1" align="center">
    <caption><strong>Java提供的数据成员默认初始化规则</strong></caption>
    <th>
        <td align="center">数据成员类型</td>
        <td align="center">默认取值</td>
    </th>
    <tr>
        <td>1</td>
        <td align="center">Byte</td>
        <td align="center">0</td>
    </tr>
    <tr>
        <td>2</td>
        <td align="center">Short</td>
        <td align="center">0</td>
    </tr>
    <tr>
        <td>3</td>
        <td align="center">Int</td>
        <td align="center">0</td>
    </tr>
    <tr>
        <td>4</td>
        <td align="center">Long</td>
        <td align="center">0</td>
    </tr>
    <tr>
        <td>5</td>
        <td align="center">Char</td>
        <td align="center">"\u0000"</td>
    </tr>
    <tr>
        <td>6</td>
        <td align="center">Float</td>
        <td align="center">0</td>
    </tr>
    <tr>
        <td>7</td>
        <td align="center">Double</td>
        <td align="center">0</td>
    </tr>
    <tr>
        <td>8</td>
        <td align="center">Boolean</td>
        <td align="center">False</td>
    </tr>
    <tr>
        <td>9</td>
        <td align="center">所有引用类型</td>
        <td align="center">Null</td>
    </tr>
</table>

<p>二、用赋值语句赋处置。</p>
<p>三、由Java提供的<u>构造方法</u>来完成它[^5]。每当使用new关键字创建一个对象，为新建对象开辟了内存空间之后，Java系统将自动调用构造方法初始化这个新建对象。，构造方法是类的一种特殊方法，它的特殊性体现在以下几个方面:</p>
<ol>
<li>构造方法的方法名与类名相同；</li>
<li>构造方法是类的方法，它能够简化对象数据成员的初始化操作；</li>
<li>不能地构造方法指定类型，它有隐含的返回之，该值由系统内部使用；</li>
<li>构造方法一般不能由编程认源显示地直接调用，在创建一个类对象的同时，系统会自动调用该类的构造方法将新对象年糕初始化；</li>
<li>构造方法可以重载，即可以定义多个具有不同参数的构造方法；</li>
<li>构造方法可以继承，即子类可以继承父类的构造方法；</li>
<li>如果用户在一个自定义类中为定义该类的构造方法，系统将为这个类定义一个缺省的空构造方法。这个空构造方法没有形式参数，没有任何具体语法，不能完成任何操作，但在创建一个类的新对象时，系统要调用该类的构造方法将新对象初始化。</li>
</ol>
<h4 id="使用对象"><a href="#使用对象" class="headerlink" title="使用对象"></a>使用对象</h4><p>当一个对象被创建之后，这个对象就拥有了自己的数据成员和成员方法，可以通过与之关联的引用变量名来引用对象的成员。引用方法如下：<code>objectReference.variableName</code>;</p>
<p>其中：objdctReference指定调用成员变量的对象名称（引用）；variableName指定需要调用的数据成员的名称。对象成员方法的引用方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">objectReference.methodName([argument_list])</span><br></pre></td></tr></table></figure>

<p>其中objectReference指定调用成员变量的对象名称，methodName指定需要调用的成员方法的名称，argument_list指定需要调用的成员方法的参数列表。</p>
<h4 id="对象的消除"><a href="#对象的消除" class="headerlink" title="对象的消除"></a>对象的消除</h4><p>在Java中程序员创建的对象可以不必删除，因为Java系统提供的垃圾回收机制可以自动判断对象是否还在使用，并能够自动销毁不再使用的对象，回收对象所占用的资源。</p>
<p>Object类提供了finalize()方法，自定义的Java类可以覆盖finalize()方法，并在这个方法中进行释放对象所占资源的操作。当垃圾回收器要释放无用对象的存储空间时，将先调用该对象的finalize()方法。</p>
<h3 id="封装机制"><a href="#封装机制" class="headerlink" title="封装机制"></a>封装机制</h3><p>封装是面向对像的一个重要特征，一般地，封装将客户端不应看到信息包裹起来，使内部的执行对外部看来是一种不透明的黑箱，客户端不需要了解内部资源就能够达到目的。</p>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装也称为数据隐藏，是指将对象的数据与操作数据的方法相结合，通过方法将对象的数据与显示细节保护起来，只保留一些对外接口，以便与外部发生联系。封装具有如下特征：</p>
<p>（1）在类的定义中设置访问对象属性（数据成员）及方法（成员方法）的权限，限制该类对象及其他类的对象的使用范围</p>
<p>（2）提供一个接口来描述其他对象的使用方法。</p>
<p>（3）其他对象不能直接修改对象所拥有的属性和方法</p>
<p>封装反映了事物的相对独立性，在变成上的作用是使对象以外的部分不能随意存取对象的内部数据（属性），从而有效地避免了外部错误和对它的影响。</p>
<h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><p>访问控制是通过在类的定义中使用权限修饰符实现的，以达到，保护类的变量和方法的目的。Java支持四种不同的访问权限：private、public、protected和default。</p>
<table>
    <caption><b>Java类成员的四种访问控制权限及其可见性</b></caption>
</table>

<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">同一个类</th>
<th align="center">同一个包</th>
<th align="center">不同包的子类</th>
<th align="center">任何场合</th>
</tr>
</thead>
<tbody><tr>
<td align="center">private</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">public</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">default</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h4 id="package和import"><a href="#package和import" class="headerlink" title="package和import"></a>package和import</h4><p>一、package</p>
<p>包的创建就是将原程序文件中的接口与类纳入指定的包中，创建包可以通过类和接口的源文件使用package语句实现。声明package语句的语法如下：<code>package pk1[.pk2]…</code>，其中符号“.”代表目录分隔符，pk<del>n</del>为包。</p>
<p>创建一个包就是在当前文件夹下床架一个子文件夹，粗放这个包中包含的所有类的.class文件。Java编译器把包对应于文件系统的目录进行管理，因此包可以嵌套使用。</p>
<p>二、import</p>
<p>将类组织成包的目的是为了更好地利用包中的类，通常，一个类只能引用与它在同一个包中的类，如果要使用其他包中的public类，可以通过两种方式实现：</p>
<p>（1）使用长名导入包中的类，这种方法是在想要导入的每个类名前面加上完整的包名。</p>
<p>（2）使用import语句导入包中的类，语句格式为：</p>
<p><code>import pkg1[.pkg2]&lt;类名|*&gt;</code>其中<code>pkg1[.pkg2]</code>表示包的层次，与package语句相同，它对应于文件的目录，类名指明所要导入的类，“*”可用来导入多个类。</p>
<p>[^1]: abstract类自身没有对象，需要派生子类后再创建对象，而final类不能派生子类，所以不存在用abstract final两个修饰符<br>[^2]: 类中用来表述研究对象静态特征的变量称为数据成员，也称为成员变量或变量<br>[^3]: 静态初始化器是由关键字static引导的一对花括号括起来的语法快，其作用是在它所属的类加载到内存时，由系统调用执行，初始化类的静态数据成员。<br>[^4]: 如果类某个方法被final修饰符所限定，则该类的子类就不能覆盖父类的方法，即不能重新定义与此方法同名的自己的方法，而仅能使用从父类继承来的方法。<br>[^5]: 构造方法是一个类的方法中方法名与类名相同的类方法。</p>
]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2021/03/26/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="二叉树学习笔记"><a href="#二叉树学习笔记" class="headerlink" title="二叉树学习笔记"></a>二叉树学习笔记</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>二叉树可以定义为节点的有限集合，这个集合或者为空集，或者由一个根及两棵不相交的分别称作这个根的左子树和右子树的二叉树组成。（<strong>二叉树的定义是一个递归定义</strong>），二叉树可以是空集合，此时的二叉树称为空二叉树；二叉树也可可以是只有一个节点的集合，这个节点只能是根；它的左子树和右子树均是空二叉树。（图片源自张乃孝$PPT$）</p>
<img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20200407213059.png"/>

<img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20200407213221.png"/>

<ul>
<li><strong>满二叉树</strong>：如果一棵二叉树的任何节点或者是树叶，或有两棵非空子树，则此二叉树称作满二叉树。</li>
<li><strong>完全二叉树</strong>：如果一棵二叉树至多只有最下面的两层节点读书可以小于2，其余各层节点度数^节点分支数^都必须为2，并且最下面一层的节点都集中在该层最左边的若干位置上，则此二叉树称为完全二叉树。（<em>完全二叉树不一定是满二叉树</em>）</li>
</ul>
<img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20200407215308.png"/>

<ul>
<li><strong>扩容二叉树</strong>：把原二叉树的节点都变为度数为2的分支节点，也就是说，如果原节点的度数为2，则不变；度数为1，则增加一个分支；度数为0，则增加两个分支。新增加的节点都用小方框表示，称为<strong>外部节点</strong>，树中原有的节点称为<strong>内部节点</strong>。特别地，对空二叉树扩容得到的扩容二叉树只有一个外部节点。</li>
</ul>
<img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20200407220724.png"/>

<ul>
<li><strong>外部路径长度E</strong>:在扩容的二叉树中从根到每个外部节点的路径长度之和。<strong>内部路径长度I</strong>：在扩容的二叉树中从根到每个内部节点的路径长度之和。</li>
</ul>
<h3 id="主要性质"><a href="#主要性质" class="headerlink" title="主要性质"></a>主要性质</h3><p>1、在二叉树的$i$层上至多有$2^i$个节点（$i\ge 0$）</p>
<p>2、高度为$k$的二叉树中最多有$2^{k+1}-1$个节点（$k \ge 0$）</p>
<p>3、对于任何一棵二叉树，如果叶节点个数为$n_{0}$，度<a href="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%A6%E6%98%AF%E6%8C%87%E6%A0%91%E4%B8%AD%E6%89%80%E4%BB%A5%E7%BB%93%E7%82%B9%E7%9A%84%E5%BA%A6%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC,%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%A6%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E2%E3%80%82">^1</a>为2的节点个数为$n_{2}$，则有：$n_{0}=n_{2}+1$。（$n_{0}+n_{1}+n_{2}=n_{1}+2*n_{2}+1$）</p>
<p>4、具有$n$个节点的完全二叉树的深度$k$为$[log_{2}n]$。</p>
<p>5、对于具有$n$个节点的完全二叉树，如果按照从上（根节点）到下（叶节点）和从左到右的顺序对二叉树中的所有节点从0开始到$n-1$进行编号，则对于任意的下表为$i$的节点，有：</p>
<p>​    (1).如果$i=0$，则它是根节点，它没有父节点；如果$i\gt 0$，则它的父节点的下表为$[(i-1)/2]$；</p>
<p>​    (2).如果$2i+1 \le n-1$，则下标为$i$的节点的下标为$2i+1$；否则，下标为$i$的节点没有左子节点；</p>
<p>​    (3).如果$2i+2 \le n-1$，则下标为$i$的节点的右子节点的下标为$2i+2$；否则，下标$i$的节点没有右子节点。</p>
<p>6、在满二叉树中，叶节点的个数比分支节点个数多1。（$n_{0}=n_{2}+1$）</p>
<p>7、在扩充二叉树中，外部节点个数比内部节点个数多1。</p>
<p>8、对任意扩充二叉树，外部路径长度$E$和内部路径长度$I$之间满足关系：$E=I+2n$，其中$n$是内部节点个数。</p>
<h3 id="抽象数据结构"><a href="#抽象数据结构" class="headerlink" title="抽象数据结构"></a>抽象数据结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADT BinTree is</span><br><span class="line">    operations</span><br><span class="line">    <span class="function">BinTree <span class="title">createEmptyBinTree</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">/*创建一棵空的二叉树*/</span></span></span><br><span class="line"><span class="function">    BinTree <span class="title">consBinTree</span><span class="params">(BinTreeNode root,BinTree left,BinTree right)</span><span class="comment">/*返回一棵二叉树，其根节点是root，左右二叉树分别为left和right。*/</span></span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> <span class="title">isNull</span><span class="params">(BinTree t)</span><span class="comment">/*判断二叉树t是否为空*/</span></span></span><br><span class="line"><span class="function">    BinTreeNode <span class="title">root</span><span class="params">(BinTree t)</span><span class="comment">/*返回二叉树t的根节点。若为空二叉树，则返回一特殊值*/</span></span></span><br><span class="line"><span class="function">    BinTreeNode <span class="title">parent</span><span class="params">(BinTree t,BinTreeNode p)</span></span></span><br><span class="line"><span class="function">    <span class="comment">/*返回节点p的父节点，当指定的节点为根时，返回一个特殊值*/</span></span></span><br><span class="line"><span class="function">    BinTree <span class="title">leftChild</span><span class="params">(BinTree t,BinTreeNode p)</span></span></span><br><span class="line"><span class="function">    <span class="comment">/*返回p节点的左子树，当指定节点没有左子树时，返回一个特殊值*/</span></span></span><br><span class="line"><span class="function">    BinTree <span class="title">rightChild</span><span class="params">(BinTree t,BinTreeNode p)</span></span></span><br><span class="line"><span class="function">    <span class="comment">/*返回p节点的右子树，当指定节点没有右子树时，返回一个特殊值*/</span></span></span><br><span class="line"><span class="function">end ADT BinTree    </span></span><br></pre></td></tr></table></figure>

<h3 id="二叉树的周游"><a href="#二叉树的周游" class="headerlink" title="二叉树的周游"></a>二叉树的周游</h3><p><strong>二叉树的周游</strong>是指按某种方式访问二叉树中的所有节点，使每个节点被访问一次且只能被访问一次。</p>
<h4 id="深度优先周游"><a href="#深度优先周游" class="headerlink" title="深度优先周游"></a>深度优先周游</h4><p>若以符号$D$、$L$、$R$分别表示根节点、左子树、右子树，则二叉树的周游共有六种方式：$DLR$、$LDR$、$LRD$、$DRL$、$RDL$和$RLD$。如果限定先左后右，则只能采用前三种周游方式：</p>
<ul>
<li>$DLR$ &lt;—-&gt; 先根次序（简称先序或前序）周游</li>
</ul>
<p>若二叉树不空，则先访问根；然后按先根次序周游左子树；最后按先根次序周游右子树。$eg$.下图二叉树先根次序周游得到的节点序列为：A、B、D、C、E、G、F、H、I。  </p>
<img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20200407232739.png"/>

<ul>
<li>$LRD$ &lt;—-&gt; 后根次序（简称后序）周游</li>
</ul>
<p>若二叉树不空，则先按后根次序周游左子树；然后按后根次序周游右子树；最后访问根。上图所示的二叉树，后根次序周游得到的节点序列为：D、B、G、E、H、I、F、C、A。</p>
<ul>
<li>$LDR$ &lt;—-&gt; 中根次序（简称中序或对称序）周游</li>
</ul>
<p>若二叉树不空，则先按对称序周游左子树，然后访问根；最后按对称序周游右子树。前图所示的二叉树，按对称序周游一棵二叉树得到的节点序列为：D、B、A、E、G、C、H、F、I。</p>
<p>对于给定的二叉树，可以唯一确定它的先根序列、后根序列和对称序列。但是反过来，给定一个二叉树的任意一种周游的序列，无法唯一确定这个二叉树。如果已知一个二叉树的对称序列，又知道另外一种周游序列就可以唯一确定这个二叉树。</p>
<h4 id="广度优先周游"><a href="#广度优先周游" class="headerlink" title="广度优先周游"></a>广度优先周游</h4><p>若二叉树的高度为$h$，则从0到$h$逐层如下处理：从左到右逐个访问存在的节点。广度优先周游一棵二叉树所得到的节点序列，叫做这棵二叉树的<strong>层次序列</strong>。前图二叉树广度优先周游所得到的节点层次序列为：A、B、C、D、E、F、G、H、I。</p>
<p>$eg$.对下图二叉树进行先根、后根和中根周游所得到的线性序列分别为：</p>
<table>
<thead>
<tr>
<th>图片</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td><img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20200407234932.png"/></td>
<td><img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20200407235600.png"/></td>
</tr>
</tbody></table>
<p>上述结果分别被称为表达式的前缀表达式、后缀表达式和中缀表达式。</p>
<h4 id="周游的抽象算法"><a href="#周游的抽象算法" class="headerlink" title="周游的抽象算法"></a>周游的抽象算法</h4><h5 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h5><ul>
<li>先根次序周游</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BinTree t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    visit(root(t));</span><br><span class="line">    preOrder(leftChild(t));</span><br><span class="line">    preOrder(rightChild(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对称序周游</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BinTree t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    inOrder(leftChild(t));</span><br><span class="line">    visit(root(t));</span><br><span class="line">    inOrder(rightChild(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>后根次序周游</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(BinTree t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    postOrder(leftChild(t));</span><br><span class="line">    postOrder(rightChild(t));</span><br><span class="line">    visit(root(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="非递归算法"><a href="#非递归算法" class="headerlink" title="非递归算法"></a>非递归算法</h5><ul>
<li>先根次序周游</li>
</ul>
<ol>
<li>把根节点压入栈中；2、从栈顶中取出元素（包括退栈），只要取出元素非空，就访问该节点；3、顺序将其右子节点和左子节点进栈。重复执行2、3，直到当从栈顶中取出的元素（包括退栈）为空，并且栈也为空时，周游结束。</li>
</ol>
<p>算法时间代价：假设栈的主要操作只要常量时间，算法中每个二叉树恰好进栈、出栈各一次，所以它的时间代价为$O(n)$，其中$n$为二叉树中子二叉树（也是节点）的个数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nPreOrder</span><span class="params">(BinTree t)</span></span>&#123;</span><br><span class="line">    Stack s;<span class="comment">/*栈元素的类型是BinTree*/</span></span><br><span class="line">    BinTreeNode *c;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    s = createEmptyStack();</span><br><span class="line">    push(s,t);</span><br><span class="line">    <span class="keyword">while</span>(!isEmptyStack(s)&#123;<span class="comment">/*每当栈不为空*/</span></span><br><span class="line">        c = top(s);pop(s);	<span class="comment">/*取栈顶，出栈*/</span></span><br><span class="line">        <span class="keyword">if</span>(c!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            visit(root(c));<span class="comment">/*访问*/</span></span><br><span class="line">            push(s,rightChild(c));<span class="comment">/*右子树进栈*/</span></span><br><span class="line">            push(s,leftChild(c));<span class="comment">/*左子树进栈*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对称序周游</li>
</ul>
<p>1、若当前二叉树不为空时，则沿其左子树尽量前进，在前进过程中，把所经过的二叉树逐个压入栈中，知道左子树为空。</p>
<p>2、弹出栈顶元素为当前二叉树，并访问该二叉树的根；</p>
<p>3、如果当前二叉树有右子树，再进入它的右子树（作为当前二叉树），从1开始执行上述过程；</p>
<p>4、如果当前二叉树没有右子树，但是栈不空，转2。</p>
<p>重复上述过程，直到当前二叉树没有右子树并且栈也为空时，周游结束。</p>
<p>算法时间代价：假设栈的主要操作只要常量时间，算法中每个二叉树恰好进栈、出栈各一次，所以它的时间代价为$O(n)$，其中$n$为二叉树中子二叉树（也是节点）的个数。（外表看上去是一个双重循环，但时间代价还是线性的）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nInOrder</span><span class="params">(BinTree t)</span></span>&#123;</span><br><span class="line">    Stack s = createEmptyStack();<span class="comment">/*栈元素类型为BinTree*/</span></span><br><span class="line">    BinTree c = t;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(c!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            push(s,c);</span><br><span class="line">            c=leftChild(c);</span><br><span class="line">        &#125;</span><br><span class="line">        c=top(s);pop(s);visit(root(c));</span><br><span class="line">        c=rightChild(c);</span><br><span class="line">    &#125;<span class="keyword">while</span>(c!=<span class="literal">NULL</span> || !isEmptyStack(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>后根次序周游</li>
</ul>
<p>1、首先由该二叉树找到其左子树，周游其左子树，周游完返回到这个二叉树的根；</p>
<p> 2、然后由该二叉树找到其右子树，周游其右子树，周游完再次返回到这个二叉树的根；</p>
<p>3、最后才能访问该二叉树的根结点。</p>
<p>为此必须在算法中增加对二叉树出栈的判断： 如果是从栈顶二叉树的左子树回来，就直接进入右子树周游；如果是从栈顶二叉树的右子树回来，就执行出栈，访问该二叉树的根结点。（时间代价仍为$O(n)$）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nPostOrder</span><span class="params">(BinTree t)</span></span>&#123;</span><br><span class="line">    Stack s = createEmptyStack();</span><br><span class="line">    BinTree p = t;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> || !isEmptyStack(s))&#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            push(s,p);</span><br><span class="line">            p=leftChild(p)?leftChild(p):rightChild(p);</span><br><span class="line">            <span class="comment">/*循环到当前需要处理的节点*/</span></span><br><span class="line">		&#125;</span><br><span class="line">        p=top(s);pop(s);visit(root(p));</span><br><span class="line">        <span class="comment">/*栈顶二叉树的根时应访问节点*/</span></span><br><span class="line">        <span class="keyword">if</span>(!isEmptyStack(s) &amp;&amp; leftChild(top(s)==p))</span><br><span class="line">            p=rightChild(top(s));<span class="comment">/*栈不空，且为从左子树退回*/</span></span><br><span class="line">        <span class="keyword">else</span> p=<span class="literal">NULL</span>;<span class="comment">/*从右子树回来，推到上一层处理*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>广度优先周游</li>
</ul>
<p>首先把二叉树送入队列；其后，每当从队首取出一个二叉树访问根之后，马上把它的子二叉树按从左到右的次序送入队列尾端；重复此过程直到队列为空。</p>
<p>算法代价：每个二叉树进队列一次出队列一次，所需时间代价为$O(n)$。主要空间代价时需要队列的附加空间。若二叉树节点个数为$n$，最坏的情况出现再完全二叉树时，需要大约$n/2$个队列元素的空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(BinTree t)</span></span>&#123;</span><br><span class="line">    BinTree c,cc;</span><br><span class="line">    Queue q=createEmptyQueue();</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    c=t;enQueue(q,c);<span class="comment">/*将二叉树送入队列*/</span></span><br><span class="line">    <span class="keyword">while</span>(!isEmptyQueue(q))&#123;</span><br><span class="line">        c=frontQueue(q);deQueue(q);visit(root(c));</span><br><span class="line">        <span class="comment">/*从队列首部取出二叉树并访问*/</span></span><br><span class="line">        cc=leftChild(c);<span class="keyword">if</span>(cc!=<span class="literal">NULL</span>) enQueue(q,cc);</span><br><span class="line">        <span class="comment">/*将左子树送入队列*/</span></span><br><span class="line">        cc=rightChild(c);<span class="keyword">if</span>(cc!=<span class="literal">NULL</span>) enQueue(q,cc);</span><br><span class="line">        <span class="comment">/*将右子树送入队列*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的实现"><a href="#二叉树的实现" class="headerlink" title="二叉树的实现"></a>二叉树的实现</h3><h4 id="顺序表示"><a href="#顺序表示" class="headerlink" title="顺序表示"></a>顺序表示</h4><p>采用一组连续的存储单元来存放二叉树中的节点</p>
<p>对于完全二叉树，按照从上（根节点）到下（叶节点）和从左到右的顺序，对二叉树中的所有节点从0到$n-1$编号，这样存放到一维数组中，只要通过数组元素的下标关系，就可以确定二叉树中节点之间的逻辑关系。<img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20200408130456.png"/></p>
<p>对于一般的二叉树，采用顺序表示，首先要对它进行扩充，增加一些并不存在的空节点，使之成为一棵完全二叉树，然后再用一维数组顺序存储。<img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20200408130929.png"/></p>
<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SeqBinTree</span>&#123;</span>	<span class="comment">/*顺序二叉树类型定义*/</span></span><br><span class="line">    <span class="keyword">int</span> MAXNUM;	<span class="comment">/*完全二叉树中允许节点的最大个数*/</span></span><br><span class="line">    <span class="keyword">int</span> n;	<span class="comment">/*改造成完全二叉树后，节点的实际个数*/</span></span><br><span class="line">    DataType * nodelist;	<span class="comment">/*存放节点的数组*/</span></span><br><span class="line">&#125;;	</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SeqBinTree</span> * <span class="title">PSeqBinTree</span>;</span></span><br><span class="line"><span class="comment">/*顺序二叉树类型的指针类型*/</span></span><br></pre></td></tr></table></figure>

<h5 id="运算实现"><a href="#运算实现" class="headerlink" title="运算实现"></a>运算实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*返回下标为p的节点的父节点的下标*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parent_seq</span><span class="params">(PSeqBinTree t,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;<span class="number">0</span> || p&gt;= t-&gt;n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> (p<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回下标为p的节点的左子节点的下标*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leftChild_seq</span><span class="params">(PSeqBinTree t,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;<span class="number">0</span> || p&gt;= t-&gt;n) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*p+<span class="number">1</span> <span class="comment">/*可能不存在*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回下标为p的节点的右子节点的下标*/</span></span><br><span class="line"><span class="keyword">int</span> rightChild_seq(PSeqBinTree t,<span class="keyword">int</span> p)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;<span class="number">0</span> || p&gt;= t-&gt;n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*(p+<span class="number">1</span>);<span class="comment">/*可能不存在*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="链接表示"><a href="#链接表示" class="headerlink" title="链接表示"></a>链接表示</h4><p>二叉树中的每个节点对应链表中的一个节点，每个节点中，除了存储节点本身的数据外，再设置两个指针字段：llink和rlink，分别存储节点的左子节点和右子节点的位置。当节点的某个子树为空时，则相应的指针为空指针。这种表示方法称为<strong>左-右指针表示法</strong>。</p>
<img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20200408132328.png"/>

<h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinTreeNode</span>;</span>	<span class="comment">/*二叉树中节点*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BinTreeNode</span> *<span class="title">PBinTreeNode</span>;</span></span><br><span class="line"><span class="comment">/*节点的指针类型*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinTreeNode</span>&#123;</span></span><br><span class="line">    DataType info;	<span class="comment">/*数据域*/</span></span><br><span class="line">    PBinTreeNode llink;	<span class="comment">/*指向左子节点*/</span>	</span><br><span class="line">    PBinTreeNode rlink;	<span class="comment">/*指向右子节点*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="运算实现-1"><a href="#运算实现-1" class="headerlink" title="运算实现"></a>运算实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*返回节点p的左子节点的地址*/</span></span><br><span class="line"><span class="function">PBinTreeNode <span class="title">leftChild_link</span><span class="params">(PBinTreeNode p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;llink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回节点p的右子节点的地址*/</span></span><br><span class="line"><span class="function">PBinTreeNode <span class="title">rightChild_link</span><span class="params">(PBinTreeNode p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;rlink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h5><p>线索二叉树是对于左-右指针表示法的一种修改，它利用节点的空左指针（$llink$)存储该节点再某种周游序列中的前驱节点的位置；利用节点的空右指针（$rlink$）存储该节点在同种周游序列中的后继节点的位置。这种附加的指向前驱节点和后继节点的指针称作<strong>线索</strong>，加进了线索的二叉树左-右指针表示称作<strong>线索二叉树</strong>。</p>
<p>为区分左右指针和线索，需要在每个节点里增加两个标志位$ltag$,和$rtag$。<img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20200408185612.png"/></p>
<p>增加了标志域的节点结构为：<img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20200408185709.png"/></p>
<p><strong>线索二叉树示例：</strong><img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/20200408185813.png"/></p>
<h6 id="线索二叉树定义"><a href="#线索二叉树定义" class="headerlink" title="线索二叉树定义"></a>线索二叉树定义</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThrTreeNode</span>;</span>	<span class="comment">/*线索二叉树中的节点*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThrTreeNode</span> * <span class="title">PThrTreeNode</span>;</span></span><br><span class="line"><span class="comment">/*指向线索二叉树节点的指针类型*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThrTreeNode</span>&#123;</span>	<span class="comment">/*线索二叉树中节点的定义*/</span></span><br><span class="line">    DataType info;</span><br><span class="line">    PThrTreeNode llink,rlink;</span><br><span class="line">    <span class="keyword">int</span> ltag,rtag;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThrTreeNode</span> * <span class="title">ThrTree</span>;</span></span><br><span class="line"><span class="comment">/*线索二叉树类型的定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> ThrTree * PThrTree;<span class="comment">/*线索二叉树类型的指针类型*/</span></span><br></pre></td></tr></table></figure>

<h6 id="按对称序线索化二叉树"><a href="#按对称序线索化二叉树" class="headerlink" title="按对称序线索化二叉树"></a>按对称序线索化二叉树</h6><p>在未线索化之前，所有结点的$llink$和$rlink$ 都是指向子结点指针，因此所有$ltag$和$rtag$ 的初始状态都为0。给出一棵二叉树，要 将它按对称序线索化，其做法就是按对称 序周游此二叉树，在周游的过程中用线索 代替空指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread</span><span class="params">(ThrTree t)</span></span>&#123;</span><br><span class="line">    PSeqStack st = createEmptyStack(M);</span><br><span class="line">    <span class="comment">/*栈元素的类型是ThrTree，M一般取t的高度*/</span></span><br><span class="line">    ThrTree p, pr;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    p = t; pr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            push_seq(st,p);</span><br><span class="line">            p = p-&gt;link;</span><br><span class="line">        &#125;</span><br><span class="line">        p=top_seq(st);</span><br><span class="line">        pop_seq(st);</span><br><span class="line">        <span class="keyword">if</span>(pr!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pr-&gt;rlink==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="comment">/*修改前驱节点的右指针*/</span></span><br><span class="line">                pr-&gt;rlink=p;</span><br><span class="line">                pr-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;llink==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="comment">/*修改该节点的左指针*/</span></span><br><span class="line">                p-&gt;llink=pr;</span><br><span class="line">                p-&gt;ltag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pr=p;p=p-&gt;rlink;</span><br><span class="line">    &#125;<span class="keyword">while</span>(!isEmptyStack_seq(st)||p!=<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="按对称序周游对称序线索二叉树"><a href="#按对称序周游对称序线索二叉树" class="headerlink" title="按对称序周游对称序线索二叉树"></a>按对称序周游对称序线索二叉树</h6><p>要按对称序周游对称序线索二叉树，首先找到对称序列 中的第一个结点，然后依次找到结点的后继结点，直至其后继结点为空即可。<br>        第一个结点很容易找，只要从根结点出发沿着左指针不断往下走，直至左指针为空，到达“最左下”的结点， 这就是对称序第一个结点。<br>        找任意结点的对称序后继时，也非常容易做：一个结点的右指针字段如果是线索，则它就指向该结点在对称序 下的后继；如果不是线索，则它指向该结点右子树的根， 而该结点在对称序下的后继应是此右子树的最左下结点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nInOrder</span><span class="params">(ThrTree t)</span></span>&#123;</span><br><span class="line">    ThrTree p = t;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;llink!=<span class="literal">NULL</span> &amp;&amp; p-&gt;ltag==<span class="number">0</span>)</span><br><span class="line">        p=p-&gt;llink;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        visit(*p);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rlink!=<span class="literal">NULL</span> &amp;&amp; p-&gt;rtag==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">/*右子树不是线索时*/</span></span><br><span class="line">            p = p-&gt;rlink;</span><br><span class="line">            <span class="keyword">while</span>(p-&gt;llink!=<span class="literal">NULL</span> &amp;&amp; p-&gt;ltag==<span class="number">0</span>)</span><br><span class="line">                p=p-&gt;llink;</span><br><span class="line">            <span class="comment">/*顺右子树的左子树一直向下*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            p=p-&gt;rlink;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>ibus无法输入中文</title>
    <url>/2022/03/03/ibus%20%E6%97%A0%E6%B3%95%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87/</url>
    <content><![CDATA[<h1 id="ibus-无法在某些应用里面输入中文"><a href="#ibus-无法在某些应用里面输入中文" class="headerlink" title="ibus 无法在某些应用里面输入中文"></a>ibus 无法在某些应用里面输入中文</h1><p>在启动文件(<code>.sh</code>)中输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export XMODIFIERS="@im=ibus"</span><br><span class="line">export GTK_IM_MODULE="ibus"</span><br><span class="line">export QT_IM_MODULE="ibus"</span><br></pre></td></tr></table></figure>

<p>重启后wps可以正常输入中文，但webstorm仍无法输入，随后查询官网得到解决方案，<a href="https://youtrack.jetbrains.com/issue/IDEA-246833" target="_blank" rel="noopener">链接</a>。</p>
<p><img src="https://gitee.com/mwszksnmdyz/image/raw/master/img/image-20220303154136768.png" alt="image-20220303154136768"></p>
]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
</search>
